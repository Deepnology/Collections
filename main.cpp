#define _HashMap_
#define _Design_
#define _Math_
#define _BitNumberOperation_
#define _Random_
#define _StackQueue_
#define _1DArray_
#define _SortSearchSelect_
#define _Interval_
#define _PermuteCombinePartition_
#define _TrieSuffixArray_
#define _FindSubstringSubsequence_
#define _CompareString_
#define _TextLines_
#define _LinkedList_
#define _2DGrid_
#define _BinaryTree_
#define _QuadTree_
#define _Heap_
#define _Graph_
#define _RMQLCA_
#define _Scheduling_
#define _ThreadSafe_
#define _DesignPattern_
#define _CPP_
//#define _PrintFileNameByTag_
//#define _PrintVSSolutionTree_

/*HashMap*/
#include "HashMap/ImplementHashMap.h"
#include "HashMap/ConsistentHashing.h"

/*Design*/
#include "Design/LRUCache.h"
#include "Design/LFUCache.h"
#include "Design/AllOoneIncrDecrGetMaxMin.h"
#include "Design/ClientsCreditsInfo.h"
#include "Design/DesignTwitter.h"
#include "Design/LoggerRateLimiter.h"
#include "Design/DesignHitCounter.h"
#include "Design/DesignPhoneDirectory.h"
#include "Design/InsertDeleteGetRandom.h"
#include "Design/InsertDeleteGetWeightedRandom.h"
#include "Design/DesignSearchAutocompleteSystem.h"
#include "Design/DesignLogStorageSystem.h"
#include "Design/ExcelSumFormula.h"
#include "Design/DesignTypeaheadSuggestion.h"
#include "Design/DesignAPIRateLimiter.h"
#include "Design/AddGetTopKStockPrice.h"
#include "Design/AddGetFraudulentTransactionsInOrder.h"
#include "Design/TimeBasedKeyValStore.h"
#include "Design/NumberOfRecentCalls.h"
#include "Design/SnapshotArray.h"

/*Math*/
#include "Math/EggDrop.h"
#include "Math/WaterAndJugProblem.h"
#include "Math/TrainPassCaveProblem.h"
#include "Math/Custom21Game.h"

/*Bit Number Operation*/
#include "BitNumberOperation/SwapInPlace.h"
#include "BitNumberOperation/PlusOne.h"
#include "BitNumberOperation/Add2BinaryStr.h"
#include "BitNumberOperation/Add2IntLinkedList.h"
#include "BitNumberOperation/PlusOneLinkedList.h"
#include "BitNumberOperation/Add2IntWoArithmeticOp.h"
#include "BitNumberOperation/Add2IntStr.h"
#include "BitNumberOperation/Multiply2IntStr.h"
#include "BitNumberOperation/Divide2IntWoMulDivMod.h"
#include "BitNumberOperation/Sqrtx.h"
#include "BitNumberOperation/ValidPerfectSquare.h"
#include "BitNumberOperation/ReverseInteger.h"
#include "BitNumberOperation/FibonacciNumber.h"
#include "BitNumberOperation/Factorial.h"
#include "BitNumberOperation/SetSubstrBits.h"
#include "BitNumberOperation/DecimalToBinStr.h"
#include "BitNumberOperation/NextPrevNumWSameBits.h"
#include "BitNumberOperation/PowOf2.h"
#include "BitNumberOperation/PowOf4.h"
#include "BitNumberOperation/PowOf3.h"
#include "BitNumberOperation/DiffBitsBtw2Int.h"
#include "BitNumberOperation/SwapOddEvenBits.h"
#include "BitNumberOperation/AggregatedNumber.h"
#include "BitNumberOperation/TrailingZerosInFactorial.h"
#include "BitNumberOperation/MaxOf2NumWoComp.h"
#include "BitNumberOperation/LongestContinuousBinary0s.h"
#include "BitNumberOperation/NextPrevNumWSameDigits.h"
#include "BitNumberOperation/IsPrime.h"
#include "BitNumberOperation/NextPrime.h"
#include "BitNumberOperation/AllPrimeFactors.h"
#include "BitNumberOperation/AllNonGreaterPrimes.h"
#include "BitNumberOperation/NumOf2s.h"
#include "BitNumberOperation/IntegerToEnglish.h"
#include "BitNumberOperation/Modulus.h"
#include "BitNumberOperation/MinNumByAllSingleDigitFactors.h"
#include "BitNumberOperation/GreatestCommonDivisor.h"
#include "BitNumberOperation/LeastCommonMultiple.h"
#include "BitNumberOperation/StrCompOrderNumSeq.h"
#include "BitNumberOperation/Pow.h"
#include "BitNumberOperation/CatalanNumber.h"
#include "BitNumberOperation/BinomialCoefficient.h"
#include "BitNumberOperation/MultipleOf3.h"
#include "BitNumberOperation/MultipleOf9.h"
#include "BitNumberOperation/MultiplyBy7.h"
#include "BitNumberOperation/IntToBinStr.h"
#include "BitNumberOperation/GetSetToggleBit.h"
#include "BitNumberOperation/Mul2IntWoArithmeticOp.h"
#include "BitNumberOperation/TwosComplement.h"
#include "BitNumberOperation/IsolateRightmostSetBit.h"
#include "BitNumberOperation/MaskOfTrailingZeros.h"
#include "BitNumberOperation/SwapTwoBits.h"
#include "BitNumberOperation/ReverseBits.h"
#include "BitNumberOperation/CountSetBits.h"
#include "BitNumberOperation/CountSetBitsFrom1toN.h"
#include "BitNumberOperation/IndexOfOnlyOneSetBit.h"
#include "BitNumberOperation/ParityOfNum.h"
#include "BitNumberOperation/IntToDecimalStr.h"
#include "BitNumberOperation/StringToInteger.h"
#include "BitNumberOperation/Base1ToBase2.h"
#include "BitNumberOperation/XpowYmodZ.h"
#include "BitNumberOperation/SuperPow.h"
#include "BitNumberOperation/Count1toNWoDigit4.h"
#include "BitNumberOperation/DivisionToDecimalStrWRepeat.h"
#include "BitNumberOperation/IncrementDigitStream.h"
#include "BitNumberOperation/TheOpenDoorsProblem.h"
#include "BitNumberOperation/ClosestNumWSameBits.h"
#include "BitNumberOperation/ValidNumber.h"
#include "BitNumberOperation/RomanToInteger.h"
#include "BitNumberOperation/CountAndSay.h"
#include "BitNumberOperation/FirstKAPlusBSqrt2.h"
#include "BitNumberOperation/CollatzConjecture.h"
#include "BitNumberOperation/ConvertExcelColumnId.h"
#include "BitNumberOperation/ShortestStraightLineProgramXPowN.h"
#include "BitNumberOperation/NthUglyNum.h"
#include "BitNumberOperation/MissingIPaddress.h"
#include "BitNumberOperation/RunLengthEncodedString.h"
#include "BitNumberOperation/EliasGammaEncodedString.h"
#include "BitNumberOperation/GrayCode.h"
#include "BitNumberOperation/ClimbingStairs.h"
#include "BitNumberOperation/HappyNumber.h"
#include "BitNumberOperation/BitwiseANDofNumRange.h"
#include "BitNumberOperation/ClockAngle.h"
#include "BitNumberOperation/AddDigits.h"
#include "BitNumberOperation/IntegerBreak.h"
#include "BitNumberOperation/PerfectSquares.h"
#include "BitNumberOperation/StrobogrammaticNumber.h"
#include "BitNumberOperation/EncodeDecodeStrings.h"
#include "BitNumberOperation/NimGame.h"
#include "BitNumberOperation/NextPrePalindromeNum.h"
#include "BitNumberOperation/ClosestPalindromeNum.h"
#include "BitNumberOperation/PalindromeNumber.h"
#include "BitNumberOperation/IntToHexStr.h"
#include "BitNumberOperation/NumberComplement.h"
#include "BitNumberOperation/ValidUTF8OctetSequence.h"
#include "BitNumberOperation/BinaryWatch.h"
#include "BitNumberOperation/MinNumByEliminateKDigits.h"
#include "BitNumberOperation/MaxSumRotateFunction.h"
#include "BitNumberOperation/FindNthDigitFrom1toInfinity.h"
#include "BitNumberOperation/MagicalString.h"
#include "BitNumberOperation/EncodeDecodeTinyURL.h"
#include "BitNumberOperation/ComplexNumberMultiplication.h"
#include "BitNumberOperation/LargestPalindromeProduct.h"
#include "BitNumberOperation/PoorPigs.h"
#include "BitNumberOperation/StringCompression.h"
#include "BitNumberOperation/SelfDividingNumbers.h"
#include "BitNumberOperation/LargestMonotoneIncrNum.h"
#include "BitNumberOperation/DotProductOfArrays.h"
#include "BitNumberOperation/ValidateIPAddress.h"
#include "BitNumberOperation/MaxNumBySwap2Digits.h"
#include "BitNumberOperation/CountPrimeSetBitsOfNums.h"
#include "BitNumberOperation/CountBinaryNumsConvertableToEitherOf3.h"
#include "BitNumberOperation/CountConsecuNumsWTgtSum.h"
#include "BitNumberOperation/RunLenEncodedIterator.h"
#include "BitNumberOperation/RunLenEncodedIterator2.h"
#include "BitNumberOperation/CountNumsWSameDigitDiff.h"
#include "BitNumberOperation/IsLittleEndian.h"
#include "BitNumberOperation/KthSymbolInGrammar.h"
#include "BitNumberOperation/DecodeNestedRepeatedStrAtIndex.h"
#include "BitNumberOperation/NextGreaterPrimePalindromeNum.h"
#include "BitNumberOperation/NumOfDaysInGivenMonth.h"
#include "BitNumberOperation/IsArmstrongNumber.h"

/*Random*/
#include "Random/ShuffleArray.h"
#include "Random/ReservoirSampling.h"
#include "Random/RandomFromStream.h"
#include "Random/RandomFromProbDist.h"
#include "Random/AliasMethod.h"
#include "Random/Rand7FromRand5.h"
#include "Random/Rand10FromRand7.h"
#include "Random/Rand1toNExcludeKSortedNum.h"
#include "Random/UniformRandFromRand2.h"
#include "Random/OfflineSampling.h"
#include "Random/RandWoModuloBias.h"
#include "Random/RandomPermutation.h"
#include "Random/RandomSubset.h"
#include "Random/RandomFromExponentialDist.h"
#include "Random/RandomPickIndicesOfTarget.h"
#include "Random/RandomPickNumsInRangeWoRepeat.h"
#include "Random/Rand2DPointInNonOvlpRects.h"

/*Stack Queue*/
#include "StackQueue/SortStack.h"
#include "StackQueue/QueueBy2Stacks.h"
#include "StackQueue/SetOfStacks.h"
#include "StackQueue/StackWithMin.h"
#include "StackQueue/MultiStacksByAnArray.h"
#include "StackQueue/StackBy2Queues.h"
#include "StackQueue/QueueWithMin.h"
#include "StackQueue/EvalReversePolishNotation.h"
#include "StackQueue/EvalPolishNotation.h"
#include "StackQueue/ValidParentheses.h"
#include "StackQueue/SimplifyPath.h"
#include "StackQueue/LongestAbsFilePath.h"
#include "StackQueue/CircularQueueByArray.h"
#include "StackQueue/DequeByCircularArray.h"
#include "StackQueue/StackByHeap.h"
#include "StackQueue/QueueByHeap.h"
#include "StackQueue/BasicCalculator.h"
#include "StackQueue/BasicCalculator2.h"
#include "StackQueue/MovingAvgFromDataStream.h"
#include "StackQueue/StackReproduceDiffOrderArray.h"
#include "StackQueue/StackWithMax.h"
#include "StackQueue/StackPermutation.h"
#include "StackQueue/MaxFreqStack.h"
#include "StackQueue/ScoreOfParentheses.h"
#include "StackQueue/RemoveOutermostParenOfEachPrimitive.h"

/*1D Array*/
#include "1DArray/AllUniqueElements.h"
#include "1DArray/RemoveSomeElementFromArray.h"
#include "1DArray/RemoveReplaceElementFromArr.h"
#include "1DArray/RemoveDupsFromUnsortedArray.h"
#include "1DArray/ReverseWords.h"
#include "1DArray/Candy.h"
#include "1DArray/GasStation.h"
#include "1DArray/JumpGame.h"
#include "1DArray/LenOfLastWord.h"
#include "1DArray/RotatedStr.h"
#include "1DArray/RotateArray.h"
#include "1DArray/CoinsInLine.h"
#include "1DArray/MinRemovalOfEndInArrayUntil.h"
#include "1DArray/MultiplicationOfNums.h"
#include "1DArray/OddOccurNum.h"
#include "1DArray/MajorityElement.h"
#include "1DArray/GeneralizedMajorityElements.h"
#include "1DArray/AllStockSpans.h"
#include "1DArray/MaxBandwidthOverWindowTimeInterval.h"
#include "1DArray/SingleDupInIdxSeqArray.h"
#include "1DArray/MissingDupPairInIdxSeqArray.h"
#include "1DArray/TwoDiffDupInIdxSeqArray.h"
#include "1DArray/MultiDupInIdxSeqArray.h"
#include "1DArray/Vector.h"
#include "1DArray/ReplaceAllSpacesWPercent20.h"
#include "1DArray/RearrangeToWaveArray.h"
#include "1DArray/FirstDupInUnsortedArray.h"
#include "1DArray/TwoIncrElementsWMaxDistInArr.h"
#include "1DArray/BestTimeBuySellStock.h"
#include "1DArray/FrequencyOfIdxSeqArray.h"
#include "1DArray/SnakestringStr.h"
#include "1DArray/MinAndMaxInArrayWMinComp.h"
#include "1DArray/SalaryThresholdForSmallerBudget.h"
#include "1DArray/HouseMajority.h"
#include "1DArray/MinWaitingTime.h"
#include "1DArray/MissingRangesInSortedArray.h"
#include "1DArray/SummaryRangesInSortedArray.h"
#include "1DArray/FirstMissingPositive.h"
#include "1DArray/LargestRectHistogram.h"
#include "1DArray/ContainerWMostWater.h"
#include "1DArray/TrappingRainWater.h"
#include "1DArray/DrawSkylineOfBuildings.h"
#include "1DArray/BuildingsViewSunset.h"
#include "1DArray/ThreeSum.h"
#include "1DArray/ThreeSumClosest.h"
#include "1DArray/ThreeSumWithMultiplicity.h"
#include "1DArray/FourSum.h"
#include "1DArray/TwoSum.h"
#include "1DArray/TwoSumAbsSortedArray.h"
#include "1DArray/MaxProductOf3.h"
#include "1DArray/TwoDifference.h"
#include "1DArray/ZigZagConversion.h"
#include "1DArray/ZigzagIterator.h"
#include "1DArray/AltPosNegNumArray.h"
#include "1DArray/MissingBitIntegerInIdxSeqArray.h"
#include "1DArray/ContainsDuplicate.h"
#include "1DArray/PeekingIterator.h"
#include "1DArray/FlipGame.h"
#include "1DArray/ReverseVowelsOfString.h"
#include "1DArray/ValidateCapitalString.h"
#include "1DArray/FrogJump.h"
#include "1DArray/PickNumberAddToSumGame.h"
#include "1DArray/SuperWashingMachines.h"
#include "1DArray/MinMovesToEqualArrayElements.h"
#include "1DArray/CircularArrayLoop.h"
#include "1DArray/ReconstructOriginalDigitsFromEnglish.h"
#include "1DArray/MoveZerosToEndOfArray.h"
#include "1DArray/SwapAdjacentInLRString.h"
#include "1DArray/AsteroidCollision.h"
#include "1DArray/MoveEvenNumsToFrontInArray.h"
#include "1DArray/NumOfFriendRequests.h"
#include "1DArray/AltEvenOddNumArray.h"
#include "1DArray/FindNRepeatedNumInSize2NArray.h"
#include "1DArray/PushDomino1DArray.h"
#include "1DArray/PrisonCell1DArrayAfterNDays.h"
#include "1DArray/MinSwapToPairCouplesInArray.h"
#include "1DArray/MinRoundTripTicketFrom2Arr.h"
#include "1DArray/FindPairWithMaxAppeal.h"
#include "1DArray/TwoSumLessEqualClosestK.h"
#include "1DArray/MinDiceFlipToAllSameFaces.h"
#include "1DArray/MinNumRefuelingStops.h"
#include "1DArray/RepeatRemoveAdjDuplicatesInString.h"
#include "1DArray/CountPairWSumDivisibleByK.h"
#include "1DArray/RepeatReverseSubstrsInParentheses.h"
#include "1DArray/NumOfEquivalentDominoPairs.h"

/*Sort Search Select*/
#include "SortSearchSelect/Partition.h"
#include "SortSearchSelect/BinarySearch.h"
#include "SortSearchSelect/BinarySearchFixedPoint.h"
#include "SortSearchSelect/QuickSort.h"
#include "SortSearchSelect/MergeSort.h"
#include "SortSearchSelect/BubbleSort.h"
#include "SortSearchSelect/InsertionSort.h"
#include "SortSearchSelect/SelectionSort.h"
#include "SortSearchSelect/HeapSort.h"
#include "SortSearchSelect/ShellSort.h"
#include "SortSearchSelect/CountingSort.h"
#include "SortSearchSelect/CountingSort2.h"
#include "SortSearchSelect/BucketSort.h"
#include "SortSearchSelect/MedianOfMedians.h"
#include "SortSearchSelect/Median2SortedArrays.h"
#include "SortSearchSelect/KthSmallestElement2SortedArrays.h"
#include "SortSearchSelect/MedianOfIntegerStream.h"
#include "SortSearchSelect/Merge2SortedArrays.h"
#include "SortSearchSelect/SearchInRotatedSortedArray.h"
#include "SortSearchSelect/RemoveDuplicatesFromSortedArray.h"
#include "SortSearchSelect/KthSmallestElement.h"
#include "SortSearchSelect/SortColors.h"
#include "SortSearchSelect/SearchInterspersedSortedStrArray.h"
#include "SortSearchSelect/SearchForRange.h"
#include "SortSearchSelect/SearchInsertionPos.h"
#include "SortSearchSelect/Anagrams.h"
#include "SortSearchSelect/MinRangeOverKSortedLists.h"
#include "SortSearchSelect/KwayMergeSort.h"
#include "SortSearchSelect/StablePartition.h"
#include "SortSearchSelect/SortHeightsWFrontTallers.h"
#include "SortSearchSelect/ShortestUnsortedSubarr.h"
#include "SortSearchSelect/KthSmallestPairSum2SortedArrays.h"
#include "SortSearchSelect/MinPairDiff2SortedArrays.h"
#include "SortSearchSelect/SortNearlySortedArray.h"
#include "SortSearchSelect/MinCostConnectRopes.h"
#include "SortSearchSelect/SortByPermutationOrder.h"
#include "SortSearchSelect/ApplyPermutationOrder.h"
#include "SortSearchSelect/InversePermutationArray.h"
#include "SortSearchSelect/MaxNumWLeastGreaterEqualCount.h"
#include "SortSearchSelect/InversionsInArray.h"
#include "SortSearchSelect/ReversePairs.h"
#include "SortSearchSelect/UnionIntersection2SortedArrays.h"
#include "SortSearchSelect/MatchingNutsBoltsProblem.h"
#include "SortSearchSelect/Sort1toNAvgOutside2Nums.h"
#include "SortSearchSelect/InterpolationSearch.h"
#include "SortSearchSelect/SortKIncrDecrArray.h"
#include "SortSearchSelect/FirstKClosestStars.h"
#include "SortSearchSelect/FirstKClosestToMedianElements.h"
#include "SortSearchSelect/LocalMinimaInUnsortedArray.h"
#include "SortSearchSelect/LocalMaximumInUnsortedArray.h"
#include "SortSearchSelect/BinarySearchUnknownLength.h"
#include "SortSearchSelect/KthSmallestElementUnknownLength.h"
#include "SortSearchSelect/IndirectSortTextLineLengthInFile.h"
#include "SortSearchSelect/LeastDistanceSort.h"
#include "SortSearchSelect/MedianElement.h"
#include "SortSearchSelect/WeightedMedianElement.h"
#include "SortSearchSelect/RearrangeArrWEqualEntriesKAway.h"
#include "SortSearchSelect/KthSmallestElementInSortedMatrix.h"
#include "SortSearchSelect/KthSmallestElementInMatrix.h"
#include "SortSearchSelect/Search2dSortedMatrix.h"
#include "SortSearchSelect/SaddlebackSearchSortedMatrix.h"
#include "SortSearchSelect/YoungTableau.h"
#include "SortSearchSelect/MaxGapOfSortedSuccessiveNum.h"
#include "SortSearchSelect/AllPairsWSmallerEqualSum.h"
#include "SortSearchSelect/GroupShiftedStrings.h"
#include "SortSearchSelect/HIndex.h"
#include "SortSearchSelect/FirstBadVersion.h"
#include "SortSearchSelect/GuessNumberHigherOrLower.h"
#include "SortSearchSelect/CreateMaxNumberFrom2Arrays.h"
#include "SortSearchSelect/TopKFrequentElements.h"
#include "SortSearchSelect/TopKFrequentStrings.h"
#include "SortSearchSelect/SortTransformedArray.h"
#include "SortSearchSelect/MaxTop3AvgScoreStudent.h"
#include "SortSearchSelect/SinglesFrom2SortedStrArr.h"
#include "SortSearchSelect/SortCharsByFrequency.h"
#include "SortSearchSelect/SlidingWindowMedian.h"
#include "SortSearchSelect/NextGreaterElement.h"
#include "SortSearchSelect/MaxCapitalForIPO.h"
#include "SortSearchSelect/AssignCookiesToMaxNumChildren.h"
#include "SortSearchSelect/ArrangeCoinsStaircaseShape.h"
#include "SortSearchSelect/GenericPartition.h"
#include "SortSearchSelect/FindAnagramMappings.h"
#include "SortSearchSelect/SortByMinSwapPairsOf2Arrays.h"
#include "SortSearchSelect/MaxDropLToRIn1PeakValleyArr.h"
#include "SortSearchSelect/TwoPairsSum.h"
#include "SortSearchSelect/OneSwapToSortedArr.h"
#include "SortSearchSelect/SortArrWithMultiSortedSubArrs.h"
#include "SortSearchSelect/SortStringsWithNewAlphabet.h"
#include "SortSearchSelect/CutWoodsToKPiecesWSameLen.h"
#include "SortSearchSelect/PrintSeqInOrderFromUnorderedStream.h"
#include "SortSearchSelect/LoginCountFromUnorderedStream.h"
#include "SortSearchSelect/EqualGlobalAndLocalInversions.h"
#include "SortSearchSelect/MinimizeMaxDistToGasStation.h"
#include "SortSearchSelect/MaxNumPartitionsToSort.h"
#include "SortSearchSelect/MinCostHireKWorkers.h"
#include "SortSearchSelect/KClosest2DPointsToOrigin.h"
#include "SortSearchSelect/MonotonicArray.h"
#include "SortSearchSelect/MinFlip01StrToMonotoneIncr.h"
#include "SortSearchSelect/RevealCardsInIncrOrder.h"
#include "SortSearchSelect/MaxProfitAssignWork.h"
#include "SortSearchSelect/MinNumBoatsToSavePeople.h"
#include "SortSearchSelect/KthSmallestNumInMissingRangeOfSortedArr.h"
#include "SortSearchSelect/PancakeSort.h"
#include "SortSearchSelect/MinCostScheduleHalfHalfTo2Cities.h"

/*Interval*/
#include "Interval/MergeIntervals.h"
#include "Interval/InsertInterval.h"
#include "Interval/IntersectionOfIntervals.h"
#include "Interval/LeastPointsCoveringAllIntervals.h"
#include "Interval/ViewFromAboveIntervals.h"
#include "Interval/DataStreamAsDisjointIntervals.h"
#include "Interval/MinRemovalForNonOverlapIntervals.h"
#include "Interval/FindRightInterval.h"
#include "Interval/TeemoAttacking.h"
#include "Interval/Heaters.h"
#include "Interval/CalendarInterval.h"
#include "Interval/IntersectionOfListsOfIntervals.h"
#include "Interval/LeastNumOfIntervalsCoverRange.h"
#include "Interval/AddBoldTagInStrMergeInterval.h"
#include "Interval/FallingSquares.h"
#include "Interval/RangeModule.h"
#include "Interval/NonCoverredFromListsOfNonOvlpIntervals.h"
#include "Interval/ExamRoom.h"

/*Permute Combine Partition*/
#include "PermuteCombinePartition/Permutations.h"
#include "PermuteCombinePartition/Permutations2.h"
#include "PermuteCombinePartition/KthPermutationSequence.h"
#include "PermuteCombinePartition/Combinations.h"
#include "PermuteCombinePartition/Combinations2.h"
#include "PermuteCombinePartition/CombinationSum.h"
#include "PermuteCombinePartition/KSum.h"
#include "PermuteCombinePartition/SubsetSumProblem.h"
#include "PermuteCombinePartition/CombinationPrimeSum1toN.h"
#include "PermuteCombinePartition/DiceCombinationSum.h"
#include "PermuteCombinePartition/FactorCombinations.h"
#include "PermuteCombinePartition/Subsets.h"
#include "PermuteCombinePartition/Knapsack.h"
#include "PermuteCombinePartition/FractionalKnapsack.h"
#include "PermuteCombinePartition/MatrixChainMultiplication.h"
#include "PermuteCombinePartition/MaxVerticesSumOfPolygon.h"
#include "PermuteCombinePartition/MaxSumParenthesizeArithmeticExpr.h"
#include "PermuteCombinePartition/MinCostPolygonTriangulation.h"
#include "PermuteCombinePartition/RestoreIPAddress.h"
#include "PermuteCombinePartition/DecodeWays.h"
#include "PermuteCombinePartition/NextPermutation.h"
#include "PermuteCombinePartition/PreviousPermutation.h"
#include "PermuteCombinePartition/LetterCombinationPhoneNum.h"
#include "PermuteCombinePartition/ParenthesesCombination.h"
#include "PermuteCombinePartition/Swap0ConvertPermutation.h"
#include "PermuteCombinePartition/ParenthesizeBoolExpr.h"
#include "PermuteCombinePartition/SynthesizeExpression.h"
#include "PermuteCombinePartition/SynthesizeExpressionEquation.h"
#include "PermuteCombinePartition/PaintersPartitionFairWorkload.h"
#include "PermuteCombinePartition/MaxMinSubarrSumToPartitionKSubarr.h"
#include "PermuteCombinePartition/Fair2TaskAssignment.h"
#include "PermuteCombinePartition/BalancedPartitionWMin2SumDiff.h"
#include "PermuteCombinePartition/BalancedPartitionWEqual2Sum.h"
#include "PermuteCombinePartition/BinPacking.h"
#include "PermuteCombinePartition/BinPacking2.h"
#include "PermuteCombinePartition/AllSubArrayPartitions.h"
#include "PermuteCombinePartition/MinNonSubsetSumSortedArray.h"
#include "PermuteCombinePartition/MeasureWithDefectiveJugs.h"
#include "PermuteCombinePartition/MonotoneDecimalNums.h"
#include "PermuteCombinePartition/StricklyMonotoneDecimalNums.h"
#include "PermuteCombinePartition/FirstFitPacking.h"
#include "PermuteCombinePartition/MaxPermutedConcatNum.h"
#include "PermuteCombinePartition/MinSumOf2IntFromADigitArr.h"
#include "PermuteCombinePartition/MaxProductCutting.h"
#include "PermuteCombinePartition/MaxPriceCutting.h"
#include "PermuteCombinePartition/MaxPriceCutting2.h"
#include "PermuteCombinePartition/AllBinaryStrWithWildCard.h"
#include "PermuteCombinePartition/WordBreak.h"
#include "PermuteCombinePartition/LongestWordMadeOfOthers.h"
#include "PermuteCombinePartition/ParenthesizeArithmeticExpr.h"
#include "PermuteCombinePartition/PaintHouseCombinations.h"
#include "PermuteCombinePartition/PaintFenceCombinations.h"
#include "PermuteCombinePartition/BurstBallons.h"
#include "PermuteCombinePartition/BombsInACircle.h"
#include "PermuteCombinePartition/GeneralizedAbbreviation.h"
#include "PermuteCombinePartition/ConvertAllWordsToMinUniqueAbbrs.h"
#include "PermuteCombinePartition/PatchingArray.h"
#include "PermuteCombinePartition/CountNumbersWithUniqueDigits.h"
#include "PermuteCombinePartition/EqualSum2SubArrPartition.h"
#include "PermuteCombinePartition/EquilibriumIndexOfArray.h"
#include "PermuteCombinePartition/MinEqualSumSubArrPartition.h"
#include "PermuteCombinePartition/HouseRobber.h"
#include "PermuteCombinePartition/TwoAssemblyLineScheduling.h"
#include "PermuteCombinePartition/Interleave2Strings.h"
#include "PermuteCombinePartition/InterleavingString.h"
#include "PermuteCombinePartition/KPalindrome.h"
#include "PermuteCombinePartition/WordPattern.h"
#include "PermuteCombinePartition/PalindromePartitioning.h"
#include "PermuteCombinePartition/PermutedPalindrome.h"
#include "PermuteCombinePartition/ScrambleString.h"
#include "PermuteCombinePartition/abcCombination_1b_2cs.h"
#include "PermuteCombinePartition/BinaryStrWoConsecu1s.h"
#include "PermuteCombinePartition/BinStrCombinationWGiven0n1Count.h"
#include "PermuteCombinePartition/PlusMinusCombinationSum.h"
#include "PermuteCombinePartition/SmallestPermutationFromIncrDecrArray.h"
#include "PermuteCombinePartition/BeautifulArrangement.h"
#include "PermuteCombinePartition/MatchsticksToSquare.h"
#include "PermuteCombinePartition/EqualSum4SubArrExcludeSplitter.h"
#include "PermuteCombinePartition/OptimalDivision.h"
#include "PermuteCombinePartition/RemoveBoxes.h"
#include "PermuteCombinePartition/MaxSumOfPairMins.h"
#include "PermuteCombinePartition/RemoveConsecuSameChars.h"
#include "PermuteCombinePartition/PartitionSameCharsInSingleSubstr.h"
#include "PermuteCombinePartition/NextClosestTime.h"
#include "PermuteCombinePartition/PartitionIntoFibonacciSeq.h"
#include "PermuteCombinePartition/MinStickersToSpellWord.h"
#include "PermuteCombinePartition/Game24.h"
#include "PermuteCombinePartition/MaxPointsDeleteAndEarn.h"
#include "PermuteCombinePartition/PartitionArrToDoubleValuedPairs.h"
#include "PermuteCombinePartition/PartitionSameNumsInGroupsWSameSizes.h"
#include "PermuteCombinePartition/ArrPermutationConsecuNumSumIsSquare.h"
#include "PermuteCombinePartition/MinCostOfMultiDayPassTickets.h"
#include "PermuteCombinePartition/AssignBikesToWorkersWShortestDist.h"
#include "PermuteCombinePartition/CountPermu1toNWPrimeOnPrimeIdx.h"
#include "PermuteCombinePartition/PartitionArrMinimizeSumOfEachSubArrMax.h"

/*Trie Suffix Array*/
#include "TrieSuffixArray/SuffixArray.h"
#include "TrieSuffixArray/TrieST.h"
#include "TrieSuffixArray/TST.h"
#include "TrieSuffixArray/Rope.h"
#include "TrieSuffixArray/FirstUniqueURL.h"
#include "TrieSuffixArray/MaxXORof2NumsInArray.h"
#include "TrieSuffixArray/SearchWordWithPrefixSuffix.h"
#include "TrieSuffixArray/SerializeDeserializeTrie.h"
#include "TrieSuffixArray/OneCharMismatchDictionary.h"
#include "TrieSuffixArray/DesignInMemoryFileSystem.h"
#include "TrieSuffixArray/StreamCharacterChecker.h"

/*Find Substring Subsequence*/
#include "FindSubstrSubseq/AllSubstr.h"
#include "FindSubstrSubseq/LongestRepeatedSubstr.h"
#include "FindSubstrSubseq/LIS.h"
#include "FindSubstrSubseq/LongestNondecreasingSubseq.h"
#include "FindSubstrSubseq/LongestAlternatingSubseq.h"
#include "FindSubstrSubseq/LongestWeaklyAlternatingSubseq.h"
#include "FindSubstrSubseq/LongestConvexSubseq.h"
#include "FindSubstrSubseq/LBS.h"
#include "FindSubstrSubseq/LISPairs.h"
#include "FindSubstrSubseq/LongestIncreasingPairs.h"
#include "FindSubstrSubseq/LongestChainOfPairs.h"
#include "FindSubstrSubseq/BoxStacking.h"
#include "FindSubstrSubseq/MaxSumIncrSubseq.h"
#include "FindSubstrSubseq/LISubstr.h"
#include "FindSubstrSubseq/LongestSubstrWoRepeatChars.h"
#include "FindSubstrSubseq/LongestSubArrWDistinctEntries.h"
#include "FindSubstrSubseq/LongestValidParentheses.h"
#include "FindSubstrSubseq/LongestConsecutiveSeq.h"
#include "FindSubstrSubseq/ShortestSubstrContainAllChars.h"
#include "FindSubstrSubseq/ShortestSubArrContainAllEntries.h"
#include "FindSubstrSubseq/ShortestSubArrContainAllEntriesInOrder.h"
#include "FindSubstrSubseq/ShortestUniqueSubstr.h"
#include "FindSubstrSubseq/SubstrWConcatAllWords.h"
#include "FindSubstrSubseq/NumOfDistinctSubstr.h"
#include "FindSubstrSubseq/MinLexicographicStrRotation.h"
#include "FindSubstrSubseq/MinLexicographicStrRotationK.h"
#include "FindSubstrSubseq/MaxSubArraySum.h"
#include "FindSubstrSubseq/MaxSubArraySumCircular.h"
#include "FindSubstrSubseq/MaxIncrSubArraySum.h"
#include "FindSubstrSubseq/MaxSubArrayProduct.h"
#include "FindSubstrSubseq/ShortestSubArrWGreaterSum.h"
#include "FindSubstrSubseq/LongestSubArrWLessEqualSum.h"
#include "FindSubstrSubseq/LongestSubArrWEqualSum.h"
#include "FindSubstrSubseq/SubArrayWGivenSum.h"
#include "FindSubstrSubseq/SubArrWLessEqualMinMaxDiff.h"
#include "FindSubstrSubseq/LongestBitonicSubArray.h"
#include "FindSubstrSubseq/LAPSubseq.h"
#include "FindSubstrSubseq/LongestEqualSumSubArrFrom2Arr.h"
#include "FindSubstrSubseq/RepeatedSubseq.h"
#include "FindSubstrSubseq/ClosestSubArraySum.h"
#include "FindSubstrSubseq/KMaxSubArraySum.h"
#include "FindSubstrSubseq/LongestSubArrWEqualElements.h"
#include "FindSubstrSubseq/LongestSubArrPredicate.h"
#include "FindSubstrSubseq/RepeatedDNASubstr.h"
#include "FindSubstrSubseq/SlidingWindowMax.h"
#include "FindSubstrSubseq/MaxDiff2SubArraySum.h"
#include "FindSubstrSubseq/LargestDivisibleSet.h"
#include "FindSubstrSubseq/RangeAddition.h"
#include "FindSubstrSubseq/ThreeIncrElementsInArray.h"
#include "FindSubstrSubseq/DistinctSubsequences.h"
#include "FindSubstrSubseq/DistinctSubsequences2.h"
#include "FindSubstrSubseq/LCS.h"
#include "FindSubstrSubseq/LCSubstr.h"
#include "FindSubstrSubseq/PatternSearching.h"
#include "FindSubstrSubseq/ImplementStrStr2.h"
#include "FindSubstrSubseq/RepeatedStringMatch.h"
#include "FindSubstrSubseq/Kmismatch.h"
#include "FindSubstrSubseq/LongestCommonPrefix.h"
#include "FindSubstrSubseq/ShortestUniquePrefix.h"
#include "FindSubstrSubseq/WildcardMatching.h"
#include "FindSubstrSubseq/RegexMatching.h"
#include "FindSubstrSubseq/ExtendedSimpleRegexMatching.h"
#include "FindSubstrSubseq/LongestPalindromeSubseq.h"
#include "FindSubstrSubseq/LongestPalindromeSubstr.h"
#include "FindSubstrSubseq/ShortestPalindrome.h"
#include "FindSubstrSubseq/PalindromePairs.h"
#include "FindSubstrSubseq/RepeatedSubstringPattern.h"
#include "FindSubstrSubseq/IsSubsequence.h"
#include "FindSubstrSubseq/LongestSubStrWLeastKRepeatChars.h"
#include "FindSubstrSubseq/ArithmeticProgressionSubseq.h"
#include "FindSubstrSubseq/LongestSubArrWSameChars_AtMostKReplace.h"
#include "FindSubstrSubseq/Pattern132.h"
#include "FindSubstrSubseq/UniqueSubstrInWraproundStr.h"
#include "FindSubstrSubseq/LongestUncommonSubseq.h"
#include "FindSubstrSubseq/CountAllPalindromeSubstr.h"
#include "FindSubstrSubseq/CountAllPalindromeSubseq.h"
#include "FindSubstrSubseq/FindAllDistinctPalindromeSubstr.h"
#include "FindSubstrSubseq/CountSubArrWSumEqualK.h"
#include "FindSubstrSubseq/MatchOrderBtwMatrixArray.h"
#include "FindSubstrSubseq/ShortestSubArrContainMaxFreqNums.h"
#include "FindSubstrSubseq/FindFirstDayContainKEmptySlots.h"
#include "FindSubstrSubseq/MaxMSubArrSumWSizeK.h"
#include "FindSubstrSubseq/AllSubstrSizeKContainDistinctChars.h"
#include "FindSubstrSubseq/MaxSubArrSumSizeK.h"
#include "FindSubstrSubseq/SumOfAllSubArrMins.h"
#include "FindSubstrSubseq/CountSubArrWLeftmostNumLessEqualToAll.h"
#include "FindSubstrSubseq/CountSubArrWSumDivisibleByK.h"
#include "FindSubstrSubseq/MaxDistToClosestPerson.h"
#include "FindSubstrSubseq/LBSubArr.h"
#include "FindSubstrSubseq/LongestAlternatingSubArr.h"
#include "FindSubstrSubseq/LongestFibonacciSubseq.h"
#include "FindSubstrSubseq/AllNumsInLeftSubArrLessEqualRight.h"
#include "FindSubstrSubseq/CountSubArrWKDistinctEntries.h"
#include "FindSubstrSubseq/CountSubsetsWMinMaxSumEqualK.h"
#include "FindSubstrSubseq/MaxSum2NonOvlpSubArrays.h"
#include "FindSubstrSubseq/LongestVowelsRemoveAtMost2Substrs.h"
#include "FindSubstrSubseq/ShortestCommonSuperSeq.h"
#include "FindSubstrSubseq/MinSwapToGroup1From01Arr.h"
#include "FindSubstrSubseq/CountSubstrSizeKWDistinctChars.h"
#include "FindSubstrSubseq/CountSubArrWMaxInRange.h"
#include "FindSubstrSubseq/MinConsecuKFlipIn01Arr.h"

/*Compare String*/
#include "CompareString/EditDistance.h"
#include "CompareString/LevenshteinDistance.h"
#include "CompareString/AnonymousLetter.h"
#include "CompareString/CompareVersionNumbers.h"
#include "CompareString/OneEditDistance.h"
#include "CompareString/MasterMindGame.h"
#include "CompareString/IsomorphicStrings.h"
#include "CompareString/UniqueWordAbbreviation.h"
#include "CompareString/MaxProductOfWordLength.h"
#include "CompareString/MinMaxRightLeftHandWord.h"
#include "CompareString/CamelCaseNotationMatching.h"
#include "CompareString/HighestAffinityPair.h"
#include "CompareString/ClosestRepetition.h"
#include "CompareString/MinDistBtw2WordsInFile.h"
#include "CompareString/SentenceSimilarity.h"
#include "CompareString/LongestWordInDictThruDeleting.h"
#include "CompareString/LongestLadderWordInDict.h"
#include "CompareString/CompareStringsWBackspace.h"
#include "CompareString/CountUniqueEmailAddr.h"
#include "CompareString/ConvertSentenceToGoatLatin.h"
#include "CompareString/CompareStretchyWords.h"
#include "CompareString/CountSubdomainVisits.h"
#include "CompareString/VowelSpellChecker.h"
#include "CompareString/FindTgtWordGivenMatchCountComp.h"
#include "CompareString/FindDuplicateFilesInSystem.h"

/*Text Lines*/
#include "TextLines/NeatPrintWordWrap.h"
#include "TextLines/NeatPrintWordWrap2.h"
#include "TextLines/TextJustification.h"
#include "TextLines/UnixTailCommand.h"
#include "TextLines/ReadNCharsGivenRead4.h"
#include "TextLines/SentenceScreenFitting.h"
#include "TextLines/CountTheRepetitions.h"
#include "TextLines/RemoveComments.h"

/*Linked List*/
#include "LinkedList/LinkedListCycle.h"
#include "LinkedList/Merge2SortedLinkedLists.h"
#include "LinkedList/MergeKSortedLinkedLists.h"
#include "LinkedList/SwapNodesInPairsLinkedList.h"
#include "LinkedList/RotateLinkedList.h"
#include "LinkedList/ReverseLinkedList.h"
#include "LinkedList/ReverseNodesInKGroupLinkedList.h"
#include "LinkedList/RemoveKthNodeFromEndLinkedList.h"
#include "LinkedList/PartitionLinkedList.h"
#include "LinkedList/SortLinkedList.h"
#include "LinkedList/RemoveDuplicatesSortedLinkedList.h"
#include "LinkedList/RemoveDupUnsortedLinkedList.h"
#include "LinkedList/CopyRandomLinkedList.h"
#include "LinkedList/Skiplist.h"
#include "LinkedList/List.h"
#include "LinkedList/FoldLinkedList.h"
#include "LinkedList/YIntersectionLinkedList.h"
#include "LinkedList/RemoveGivenNodeInLinkedList.h"
#include "LinkedList/JosephusProblem.h"
#include "LinkedList/CountBlockOfAdjNodesLinkedList.h"
#include "LinkedList/EvenOddMergeLinkedList.h"
#include "LinkedList/MedianOfSortedCircularLinkedList.h"
#include "LinkedList/JumpFirstOrderPostingsLinkedList.h"
#include "LinkedList/RemoveNodesWGivenValLinkedList.h"
#include "LinkedList/PalindromeLinkedList.h"
#include "LinkedList/EliminateLeftRightOddNumsGame.h"
#include "LinkedList/SplitNodesInKGroupLinkedList.h"
#include "LinkedList/FlattenMultilevelLinkedList.h"
#include "LinkedList/TraverseMultilevelLinkedList.h"
#include "LinkedList/InsertNodeCyclicSortedLinkedList.h"
#include "LinkedList/LinkedListComponents.h"
#include "LinkedList/ImplementLinkedList.h"
#include "LinkedList/NextGreaterNodeInLinkedList.h"
#include "LinkedList/PrintLinkedListInReverse.h"

/*2D Grid*/
#include "2DGrid/MinPathSum.h"
#include "2DGrid/MinPathSumInTriangle.h"
#include "2DGrid/UniquePath.h"
#include "2DGrid/WordSearch.h"
#include "2DGrid/WordSearch2.h"
#include "2DGrid/ValidSudoku.h"
#include "2DGrid/SudokuSolver.h"
#include "2DGrid/RotateImage.h"
#include "2DGrid/RotateMatrix180.h"
#include "2DGrid/NQueens.h"
#include "2DGrid/PascalTriangle.h"
#include "2DGrid/FillPyramidGlasses.h"
#include "2DGrid/SetColRowZerosInMatrix.h"
#include "2DGrid/SpiralMatrix.h"
#include "2DGrid/SurroundedRegions.h"
#include "2DGrid/MaxRectangle.h"
#include "2DGrid/IterateMatrixDiagonal.h"
#include "2DGrid/AllDistinctSubAreasInMatrix.h"
#include "2DGrid/ProbToStepInsideMatrix.h"
#include "2DGrid/AllShortestPathsInMatrix.h"
#include "2DGrid/SearchAMaze.h"
#include "2DGrid/TicTacToeGame.h"
#include "2DGrid/MaxSubMatrixSum.h"
#include "2DGrid/MaxSubSquareBorder.h"
#include "2DGrid/PaintFillAllSameColorPixels.h"
#include "2DGrid/LongestIncrAdjConsecuNumSeqInMatrix.h"
#include "2DGrid/KeyPressSeqInMatrix.h"
#include "2DGrid/TileChessboardWDominos.h"
#include "2DGrid/KeyPressCombinationsInMatrix.h"
#include "2DGrid/AllSubSquareSumsInMatrix.h"
#include "2DGrid/IntersectRectangle.h"
#include "2DGrid/DungeonGame.h"
#include "2DGrid/TwoClosestPoints.h"
#include "2DGrid/MaxPointsOnALine.h"
#include "2DGrid/NumberOfIslandsInMatrix.h"
#include "2DGrid/MaxSubMatrixSumNoGreaterThanK.h"
#include "2DGrid/Flatten2DVector.h"
#include "2DGrid/GameOfLife.h"
#include "2DGrid/SmallestRectEnclosingBlackPixels.h"
#include "2DGrid/BestMeetingPoint.h"
#include "2DGrid/SparseMatrixMultiplication.h"
#include "2DGrid/ShortestDistFromAllBuildings.h"
#include "2DGrid/SelfCrossing.h"
#include "2DGrid/DesignSnakeGame.h"
#include "2DGrid/AndroidUnlockPatterns.h"
#include "2DGrid/LineReflection.h"
#include "2DGrid/BombEnemy.h"
#include "2DGrid/NonStoppingMaze.h"
#include "2DGrid/LonelyPixel.h"
#include "2DGrid/BattleshipsInABoard.h"
#include "2DGrid/IslandPerimeter.h"
#include "2DGrid/PerfectRectangle.h"
#include "2DGrid/Minesweeper.h"
#include "2DGrid/PacificAtlanticWaterFlow.h"
#include "2DGrid/WordSquare.h"
#include "2DGrid/MinDistTo0In01Matrix.h"
#include "2DGrid/BrickWall.h"
#include "2DGrid/NumOfBoomerangs.h"
#include "2DGrid/MostSquareDimensionXY.h"
#include "2DGrid/CountSquaresIn2DGrid.h"
#include "2DGrid/ReshapeMatrix.h"
#include "2DGrid/MinStepsInMaze.h"
#include "2DGrid/MinPathCutTreeIncrOrder.h"
#include "2DGrid/LargestPlusSignIn2DGrid.h"
#include "2DGrid/CountCornerRectanglesIn2DGrid.h"
#include "2DGrid/LMoveIdxSeqCombinationInMatrix.h"
#include "2DGrid/FindMinCol1In01Matrix.h"
#include "2DGrid/SquirrelCollectNutsToTree.h"
#include "2DGrid/VerticalPrintWBalancedColumnLen.h"
#include "2DGrid/Find4PointsFormRectangle.h"
#include "2DGrid/MaxIncrKeepSkyline.h"
#include "2DGrid/FindDuplicateRowsInBinaryMatrix.h"
#include "2DGrid/Count1sIn2dMatrixWithHasAPI.h"
#include "2DGrid/UniquePathInTriangle.h"
#include "2DGrid/LargestIslandAtMost1FlipInMatrix.h"
#include "2DGrid/DetermineIfPointLieInsideTriangle.h"
#include "2DGrid/Find3PointsFormLargestTriangle.h"
#include "2DGrid/RobotRoomCleaner.h"
#include "2DGrid/RemoveSurroundedPiecesInMatrix.h"
#include "2DGrid/ReachingPoints2D.h"
#include "2DGrid/OrthogonalLineSegmentIntersection.h"
#include "2DGrid/OrthogonalRectangleIntersection.h"
#include "2DGrid/OrthogonalRectangleIntersection2.h"
#include "2DGrid/MinMovesInSnakeLadderBoard.h"
#include "2DGrid/CandyCrush.h"
#include "2DGrid/CountMagic3x3SquareInGrid.h"
#include "2DGrid/PourWater.h"
#include "2DGrid/ShortestBridgeBtw2Islands.h"
#include "2DGrid/RoundTripMaxPickupIn2DMatrix.h"
#include "2DGrid/MaxStonesRemovedWSameRowOrCol.h"
#include "2DGrid/MinimizeMaxNumInPath2DGrid.h"
#include "2DGrid/StackTrianglesToPyramid.h"
#include "2DGrid/CountRegionsCutBySlashes2DGrid.h"
#include "2DGrid/EscapeInLarge2DMazeWithBlocks.h"
#include "2DGrid/CountSubMatrixWSumEqualK.h"
#include "2DGrid/MaxSumPathInMatrix.h"
#include "2DGrid/MinKnightMoveInfinite2DGrid.h"

/*Binary Tree*/
#include "BinaryTree/BalancedBinaryTree.h"
#include "BinaryTree/CompleteBinaryTree.h"
#include "BinaryTree/ValidBinarySearchTree.h"
#include "BinaryTree/BinaryTreePreOrderTraversal.h"
#include "BinaryTree/BinaryTreeInOrderTraversal.h"
#include "BinaryTree/BinaryTreePostOrderTraversal.h"
#include "BinaryTree/BinaryTreeLevelOrderTraversal.h"
#include "BinaryTree/ConstructBinaryTreeFrom2Traversals.h"
#include "BinaryTree/ConstructBSTFromTraversal.h"
#include "BinaryTree/ConstructBinaryTreeFromTraversal.h"
#include "BinaryTree/BinaryTreeMaxPathSum.h"
#include "BinaryTree/MaxDepthBinaryTree.h"
#include "BinaryTree/MinDepthBinaryTree.h"
#include "BinaryTree/ConvertSortedArrayToBinarySearchTree.h"
#include "BinaryTree/ConvertSortedListToBinarySearchTree.h"
#include "BinaryTree/RecoverAlmostBinarySearchTree.h"
#include "BinaryTree/UniqueBinarySearchTree.h"
#include "BinaryTree/FlattenBinaryTreeToLinkedList.h"
#include "BinaryTree/PopulatingNextRightPtr.h"
#include "BinaryTree/SymmetricBinaryTree.h"
#include "BinaryTree/SumRootToLeafNums.h"
#include "BinaryTree/SameBinaryTree.h"
#include "BinaryTree/BinaryTreePathSum.h"
#include "BinaryTree/BinaryTreePreOrderSucc.h"
#include "BinaryTree/BinaryTreeInorderSucc.h"
#include "BinaryTree/BinaryTreePostOrderSucc.h"
#include "BinaryTree/LowestCommonAncestorBinaryTree.h"
#include "BinaryTree/LowestCommonAncestorBinarySearchTree.h"
#include "BinaryTree/TwoSumBinarySearchTree.h"
#include "BinaryTree/Merge2BalancedBinarySearchTree.h"
#include "BinaryTree/ConvertBSTtoCircularDoublyLinkedList.h"
#include "BinaryTree/AATree.h"
#include "BinaryTree/AVLTree.h"
#include "BinaryTree/BinarySearchTree.h"
#include "BinaryTree/BTree.h"
#include "BinaryTree/DeleteBinaryTree.h"
#include "BinaryTree/KdTree.h"
#include "BinaryTree/RedBlackTree.h"
#include "BinaryTree/SplayTree.h"
#include "BinaryTree/LargestIndependentSetBinaryTree.h"
#include "BinaryTree/OptimalBinarySearchTree.h"
#include "BinaryTree/KBalancedNodesBinaryTree.h"
#include "BinaryTree/SumRootToLeafBinaryNumBinaryTree.h"
#include "BinaryTree/ExteriorNodesBinaryTree.h"
#include "BinaryTree/MinFirstBST.h"
#include "BinaryTree/InBetweenAncestorDescendantBST.h"
#include "BinaryTree/HuffmanCoding.h"
#include "BinaryTree/ConnectBinaryTreeLeaves.h"
#include "BinaryTree/BSTIterator.h"
#include "BinaryTree/BinaryTreeUpsideDown.h"
#include "BinaryTree/BinaryTreeRightSideView.h"
#include "BinaryTree/InvertBinaryTree.h"
#include "BinaryTree/VerifyPreOrderTraversalBinaryTree.h"
#include "BinaryTree/VerifyPostOrderTraversalBinaryTree.h"
#include "BinaryTree/VerifyLevelOrderTraversalBinaryTree.h"
#include "BinaryTree/VerifyPreOrderTraversalBST.h"
#include "BinaryTree/VerifyPostOrderTraversalBST.h"
#include "BinaryTree/LongestConsecutivePathBinaryTree.h"
#include "BinaryTree/ClosestValBST.h"
#include "BinaryTree/BinaryTreeVerticalOrderTraversal.h"
#include "BinaryTree/CountUnivalueSubtrees.h"
#include "BinaryTree/UnivaluedBinaryTree.h"
#include "BinaryTree/LargestBSTSubtree.h"
#include "BinaryTree/LargestInRangeBSTSubtree.h"
#include "BinaryTree/FlattenNestedListIterator.h"
#include "BinaryTree/NestedListWeightSum.h"
#include "BinaryTree/FindLeavesOfBinaryTree.h"
#include "BinaryTree/ConstructBinaryTreeFromNestedTraversal.h"
#include "BinaryTree/DecodeNestedString.h"
#include "BinaryTree/EncodeShortestNestedString.h"
#include "BinaryTree/ParseNestedListString.h"
#include "BinaryTree/ParseNestedTernaryExpression.h"
#include "BinaryTree/FindNearestLeafNodeBinaryTree.h"
#include "BinaryTree/SplitBST.h"
#include "BinaryTree/ListOfNodesFormBinaryTree.h"
#include "BinaryTree/MinDist2NodesBinaryTree.h"
#include "BinaryTree/ConvertBSTtoMinHeap.h"
#include "BinaryTree/PrintBinaryTreeIn2DArray.h"
#include "BinaryTree/SerializeDeserializeNaryTree.h"
#include "BinaryTree/MinDiff2NodesInBST.h"
#include "BinaryTree/RangeSumOfNodesInBST.h"
#include "BinaryTree/FlipEquivalentBinaryTrees.h"
#include "BinaryTree/SameLeafValSeqBinaryTrees.h"
#include "BinaryTree/DistributeNCoinsToNNodesInBinaryTree.h"
#include "BinaryTree/MinCamerasBinaryTree.h"
#include "BinaryTree/FlattenBinaryTreeInInorder.h"
#include "BinaryTree/SubtreeContainingAllDeepestNodes.h"
#include "BinaryTree/BinaryTreeLevelOrderArrToInOrderArr.h"
#include "BinaryTree/MaxDiffBtwNodeAncestorBinaryTree.h"
#include "BinaryTree/BinaryTreeRootToLeafPath.h"
#include "BinaryTree/AllPossibleFullBinaryTree.h"
#include "BinaryTree/RemoveSubtWAll0sBinaryTree.h"
#include "BinaryTree/EncodeDecodeNaryTreeToBinaryTree.h"
#include "BinaryTree/CompleteBinaryTreeInserter.h"
#include "BinaryTree/MinSwapLRChildToTgtPreorderBinaryTree.h"
#include "BinaryTree/ConstructBinaryTreeFromTraversalWDepth.h"
#include "BinaryTree/MaxAvgSubtree.h"
#include "BinaryTree/PathInZigZagLabelledBinaryTree.h"
#include "BinaryTree/CountNumOfAtomsInChemicalFormula.h"
#include "BinaryTree/MinCostBinaryTreeFromLeafValues.h"
#include "BinaryTree/DeleteNodesOnNoRLPathWGreaterEqualSum.h"

/*Quad Tree*/
#include "QuadTree/QuadTree.h"

/*Heap*/
#include "Heap/BinaryMinHeap.h"
#include "Heap/BinomialMinHeap.h"
#include "Heap/FibonacciMinHeap.h"
#include "Heap/LeftistMinHeap.h"
#include "Heap/SkewMinHeap.h"
#include "Heap/PairingMinHeap.h"
#include "Heap/Treap.h"
#include "Heap/Merge2Heaps.h"

/*Graph*/
#include "Graph/CloneGraph.h"
#include "Graph/TrianglesInGraph.h"
#include "Graph/ShortestPathInGraph.h"
#include "Graph/GraphSearch.h"
#include "Graph/StronglyConnectedComponents.h"
#include "Graph/EulerianGraph.h"
#include "Graph/ConnectAllStrInChain.h"
#include "Graph/TopologicalSortDAG.h"
#include "Graph/UniqueSequenceReconstructable.h"
#include "Graph/UnionFindGraphComponent.h"
#include "Graph/MinSpanningTree.h"
#include "Graph/CyclicGraph.h"
#include "Graph/LongestPathInDAG.h"
#include "Graph/AllPairsShortestPaths.h"
#include "Graph/EvaluateDivisions.h"
#include "Graph/VertexColoring.h"
#include "Graph/BipartiteGraph.h"
#include "Graph/BridgesInGraph.h"
#include "Graph/CutVerticesInGraph.h"
#include "Graph/BiconnectedGraph.h"
#include "Graph/MaxFlowInFlowNetwork.h"
#include "Graph/MinSTCutInFlowNetwork.h"
#include "Graph/MaxBipartiteMatching.h"
#include "Graph/MaxNumEdgeDisjointPaths.h"
#include "Graph/AlphabetOrderFromGivenDictionary.h"
#include "Graph/KEdgePathsInDigraph.h"
#include "Graph/TheCelebrityProblem.h"
#include "Graph/DiameterOfTree.h"
#include "Graph/TwoExistConnectedGraph.h"
#include "Graph/TwoForAllConnectedGraph.h"
#include "Graph/HighwayNetworkProposal.h"
#include "Graph/IsArbitrageExist.h"
#include "Graph/MinDelayTaskSchedulingDAG.h"
#include "Graph/TowerOfHanoi.h"
#include "Graph/GeneralTowerOfHanoi.h"
#include "Graph/TreeFromParentChildPairs.h"
#include "Graph/ReconstructItinerary.h"
#include "Graph/KillProcess.h"
#include "Graph/GenericDFSWStack.h"
#include "Graph/WordLadder.h"
#include "Graph/CourseSchedule.h"
#include "Graph/TeamPhoto.h"
#include "Graph/MinCashFlow.h"
#include "Graph/MinHeightTreesInGraph.h"
#include "Graph/RemoveInvalidParentheses.h"
#include "Graph/FreedomTrail.h"
#include "Graph/MergeAccounts.h"
#include "Graph/LCAofDeepestLeavesGraphTree.h"
#include "Graph/FindLoudestRicherPerson.h"
#include "Graph/EventualSafeVerticesDirectedGraph.h"
#include "Graph/BusRoutes.h"
#include "Graph/MinStepsToOpen4DigitLock.h"
#include "Graph/MinStepsSwap0In2DPuzzleBoard.h"
#include "Graph/CheapestFlightsWithinKStops.h"
#include "Graph/OnePathVisitAllRooms.h"
#include "Graph/GraphToTreeRedundantEdge.h"
#include "Graph/CrackSafe.h"
#include "Graph/SumOfDistBtwCurAndAllOtherNodesInTree.h"
#include "Graph/ShortestPathVisitAllNodesInGraph.h"
#include "Graph/Remove1MalNodeMinimizeInfectedNodes.h"
#include "Graph/ConnectedComponentsByStrSwap2Chars.h"
#include "Graph/ConnectedComponentsByIntCommonFactor.h"
#include "Graph/MinCostConnectAllNodesInGraph.h"
#include "Graph/KSwapStrings.h"
#include "Graph/ShortestSuperStringOfAllStrings.h"
#include "Graph/ShortestPathWAltColorsInGraph.h"
#include "Graph/MinLexicographicStrBySwapPairs.h"

/*RMQ LCA*/
#include "RMQLCA/RangeSumQuerySegmentTree.h"
#include "RMQLCA/RangeSumQueryWPrefixSums.h"
#include "RMQLCA/RangeSumQuerySegmentTree2D.h"
#include "RMQLCA/RangeSumQueryBinaryIndexedTree.h"
#include "RMQLCA/RangeSumCount.h"
#include "RMQLCA/RangeMinQuerySegmentTree.h"
#include "RMQLCA/CartesianTree.h"
#include "RMQLCA/RangeMinQueryDP2D.h"
#include "RMQLCA/RangeMinQuerySparseTable.h"
#include "RMQLCA/LowestCommonAncestorEulerTourRMQ.h"
#include "RMQLCA/LowestCommonAncestorUnionFind.h"
#include "RMQLCA/LowestCommonAncestorSectionDad.h"
#include "RMQLCA/LowestCommonAncestorDP2D.h"
#include "RMQLCA/RMQ2DSegmentTree2D.h"

/*Scheduling*/
#include "Scheduling/RoundRobinScheduling.h"

/*Thread Safe*/
#include "ThreadSafe/RealTimeCountHitsInLastSecMinHr.h"
#include "ThreadSafe/Sync2InterleavingThreads.h"
#include "ThreadSafe/ThreadMgr.h"
#include "ThreadSafe/ThreadPool.h"
#include "ThreadSafe/ImplementAsyncCallback.h"
#include "ThreadSafe/ThreadTimer.h"
#include "ThreadSafe/SyncReadersWriters.h"
#include "ThreadSafe/SyncProducersConsumers.h"
#include "ThreadSafe/SyncCigaretteSmokers.h"
#include "ThreadSafe/SyncDiningPhilosophers.h"
#include "ThreadSafe/SyncPrintInOrder123.h"
#include "ThreadSafe/SyncPrintFooBarAlter.h"
#include "ThreadSafe/SyncPrintZeroOddZeroEven.h"
#include "ThreadSafe/SyncBuildH2O.h"
#include "ThreadSafe/SyncPrintFizzBuzz.h"

/*DesignPattern*/
#include "DesignPattern/DesignPattern_AbstractFactory.h"
#include "DesignPattern/DesignPattern_Adapter.h"
#include "DesignPattern/DesignPattern_Bridge.h"
#include "DesignPattern/DesignPattern_Builder.h"
#include "DesignPattern/DesignPattern_ChainOfResponsibility.h"
#include "DesignPattern/DesignPattern_Command.h"
#include "DesignPattern/DesignPattern_Composite.h"
#include "DesignPattern/DesignPattern_Decorator.h"
#include "DesignPattern/DesignPattern_Facade.h"
#include "DesignPattern/DesignPattern_FactoryMethod.h"
#include "DesignPattern/DesignPattern_Flyweight.h"
#include "DesignPattern/DesignPattern_Interpreter.h"
#include "DesignPattern/DesignPattern_Iterator.h"
#include "DesignPattern/DesignPattern_Mediator.h"
#include "DesignPattern/DesignPattern_Memento.h"
#include "DesignPattern/DesignPattern_NullObject.h"
#include "DesignPattern/DesignPattern_ObjectPool.h"
#include "DesignPattern/DesignPattern_Observer.h"
#include "DesignPattern/DesignPattern_PrivateClassData.h"
#include "DesignPattern/DesignPattern_Prototype.h"
#include "DesignPattern/DesignPattern_Proxy.h"
#include "DesignPattern/DesignPattern_Singleton.h"
#include "DesignPattern/DesignPattern_State.h"
#include "DesignPattern/DesignPattern_Strategy.h"
#include "DesignPattern/DesignPattern_TemplateMethod.h"
#include "DesignPattern/DesignPattern_Visitor.h"
#include "DesignPattern/DesignMealCombinationSystem.h"
#include "DesignPattern/DesignLeetcodeOJ.h"

/*CPP*/
#include "CPP/MakeFinal.h"

/*Utility*/
#include "PrintHeader.h"
#include "TestCase.h"
#include "PrintBinaryTree.h"
#include "PrintLinkedList.h"
#include "PrintFileNameByTag.h"
#include "PrintVSSolutionTree.h"
#include "redirect_cout.h"
#include <cstdlib>
#include <iostream>
#include <fstream>

int main()
{
	bool RdCout = true;
	PrintHeader PrintH;
#ifdef _HashMap_
	RdCout ? redirect_cout::to_file("Out_HashMap.txt") : redirect_cout::to_cout();
	PrintH("HashMap");
	{
		ImplementHashMap ihp(3);
		ihp.Put(std::string("a"), 1);
		ihp.Put(std::string("b"), 2);
		ihp.Put(std::string("c"), 3);
		ihp.Put(std::string("d"), 4);
		ihp.Put(std::string("e"), 5);
		ihp.Put(std::string("f"), 6);
		ihp.Print();
		ihp.Put(std::string("a"), 11);
		ihp.Put(std::string("b"), 22);
		ihp.Put(std::string("c"), 33);
		std::cout << ihp.Get("a").first << "," << ihp.Get("b").first << "," << ihp.Get("c").first << std::endl;
		ihp.Print();
		ihp.Remove(std::string("f"));
		ihp.Remove(std::string("a"));
		ihp.Remove(std::string("c"));
		ihp.Print();
	}
    {
        ConsistentHashingTest4();
    }

#endif
#ifdef _Design_
	RdCout ? redirect_cout::to_file("Out_Design.txt") : redirect_cout::to_cout();
	PrintH("Design");
	{
		LRUCache<std::string, int> lrucache(3);
		lrucache.Set("A", 1);
		lrucache.Print();
		lrucache.Set("B", 2);
		lrucache.Print();
		lrucache.Set("C", 3);
		lrucache.Print();
		lrucache.Get("A");
		lrucache.Print();
		lrucache.Set("D", 4);
		lrucache.Print();
		lrucache.Set("C", 5);
		lrucache.Print();
		URLHistory urlHist(3);
		urlHist.Visit(std::string("A"));
		urlHist.Print();
		urlHist.Visit(std::string("B"));
		urlHist.Print();
		urlHist.Visit(std::string("C"));
		urlHist.Print();
		urlHist.Visit(std::string("A"));
		urlHist.Print();
		urlHist.Visit(std::string("D"));
		urlHist.Print();
		urlHist.Visit(std::string("C"));
		urlHist.Print();

		for (int i = 0; i < 2; ++i)
		{
			int timeWindow;
			if (i == 0)
				timeWindow = 3;
			else
				timeWindow = 10;
			URLHistory2 urlHist2(10, timeWindow);
			int idx = 0;
			urlHist2.Visit(std::string("A"), ++idx);
			urlHist2.Visit(std::string("A"), ++idx);
			urlHist2.Visit(std::string("B"), ++idx);
			urlHist2.Visit(std::string("C"), ++idx);
			urlHist2.Print();
			urlHist2.Visit(std::string("D"), ++idx);
			urlHist2.Visit(std::string("B"), ++idx);
			urlHist2.Visit(std::string("D"), ++idx);
			urlHist2.Visit(std::string("D"), ++idx);
			urlHist2.Print();
			urlHist2.Visit(std::string("A"), ++idx);
			urlHist2.Visit(std::string("B"), ++idx);
			urlHist2.Visit(std::string("C"), ++idx);
			urlHist2.Visit(std::string("C"), ++idx);
			urlHist2.Visit(std::string("B"), ++idx);
			urlHist2.Print();
			urlHist2.Visit(std::string("E"), ++idx);
			urlHist2.Visit(std::string("C"), ++idx);
			urlHist2.Visit(std::string("D"), ++idx);
			urlHist2.Visit(std::string("D"), ++idx);
			urlHist2.Visit(std::string("B"), ++idx);
			urlHist2.Print();
			urlHist2.Visit(std::string("H"), ++idx);
			urlHist2.Visit(std::string("G"), ++idx);
			urlHist2.Visit(std::string("F"), ++idx);
			urlHist2.Visit(std::string("F"), ++idx);
			urlHist2.Visit(std::string("H"), ++idx);
			urlHist2.Visit(std::string("G"), ++idx);
			urlHist2.Visit(std::string("F"), ++idx);
			urlHist2.Visit(std::string("F"), ++idx);
			urlHist2.Visit(std::string("H"), ++idx);
			urlHist2.Visit(std::string("G"), ++idx);
			urlHist2.Visit(std::string("I"), ++idx);
			urlHist2.Print();
		}
	}
	{
		{
			LFUCache c(2);
			c.put(1, 1);
			c.put(2, 2);
			c.get(1);
			c.put(3, 3);
			c.get(2);
			c.get(3);
			c.put(4, 4);
			c.get(1);
			c.get(3);
			c.get(4);
		}
		{
			LFUCache2 c(2);
			c.put(1, 1);
			c.put(2, 2);
			c.get(1);
			c.put(3, 3);
			c.get(2);
			c.get(3);
			c.put(4, 4);
			c.get(1);
			c.get(3);
			c.get(4);
		}
	}
	{
		AllOoneIncrDecrGetMaxMin a;
		a.inc("hello");
		a.inc("hello");
		a.inc("world");
		a.inc("world");
		a.inc("hello");
		a.dec("world");
		a.getMaxKey();
		a.getMinKey();
		a.inc("hello");
		a.getMaxKey();
		a.inc("hello");
		a.dec("world");
		a.getMinKey();
		a.dec("hello");
		a.inc("world");
		a.getMaxKey();
		a.getMinKey();
	}
	{
		ClientsCreditsInfo c;
		c.Insert("A", 3);
		c.Insert("B", 5);
		c.Insert("C", 7);
		c.Insert("D", 1);
		c.Insert("E", 6);
		c.Insert("F", 4);
		c.Insert("G", 3);
		c.Insert("H", 4);
		c.Insert("I", 6);
		c.Insert("J", 4);
		c.Insert("K", 7);
		c.Insert("L", 6);
		c.Insert("M", 1);
		c.AddAll(10);
		c.Print();
		c.Lookup("F");
		c.Max();
		c.Remove("A");
		c.Remove("K");
		c.Remove("G");
		c.Remove("L");
		c.Print();
	}
	{
		Twitter twitter;
		twitter.postTweet(1, 5);
		twitter.getNewsFeed(1);
		twitter.follow(1, 2);
		twitter.postTweet(2, 6);
		twitter.getNewsFeed(1);
		twitter.unfollow(1, 2);
		twitter.getNewsFeed(1);
	}
	{
		LoggerRateLimiter logger;
		logger.ShouldPrintMessage(1, "foo");
		logger.ShouldPrintMessage(2, "bar");
		logger.ShouldPrintMessage(3, "foo");
		logger.ShouldPrintMessage(8, "bar");
		logger.ShouldPrintMessage(10, "foo");
		logger.ShouldPrintMessage(11, "foo");
	}
	{
		DesignHitCounter c;
		c.hit(1);
		c.hit(2);
		c.hit(3);
		c.getHits(4);
		c.hit(300);
		c.getHits(300);
		c.getHits(301);

		c.hit2(1);
		c.hit2(2);
		c.hit2(3);
		c.getHits2(4);
		c.hit2(300);
		c.getHits2(300);
		c.getHits2(301);
	}
	{
		DesignPhoneDirectory d(3);
		d.get();
		d.get();
		d.check(2);
		d.get();
		d.check(2);
		d.release(2);
		d.check(2);
	}
	{
		InsertDeleteGetRandom r;
		r.insert(1);
		r.remove(2);
		r.insert(2);
		r.getRandom();
		r.remove(1);
		r.insert(2);
		r.getRandom();

		InsertDeleteGetRandomDupAllowed r2;
		r2.insert(1);
		r2.insert(1);
		r2.insert(2);
		r2.getRandom();
		r2.remove(1);
		r2.getRandom();
	}
    {
        InsertDeleteGetWeightedRandom r;
        r.Insert("A", 1);
        r.GetRandom();
        r.Insert("B", 2);
        r.GetRandom();
        r.Insert("A", 3);
        r.GetRandom();
        r.Insert("C", 1);
        r.GetRandom();
        r.Insert("A", 0);
        r.GetRandom();
        r.Insert("B", 0);
        r.GetRandom();
        r.Insert("C", 0);
        r.Insert("A", 1);
        r.Insert("B", 2);
        r.Insert("C", 3);
        r.GetRandom();
        r.Insert("A", 0);
        r.GetRandom();
        r.Insert("B", 0);
        r.GetRandom();
    }
    {
        ExcelSumFormula e(3, 'C');
        e.set(1, 'A', 2);
        e.sum(3, 'C', std::vector<std::string>({"A1", "A1:B2"}));
        e.set(2, 'B', 2);
    }
    {
        DesignAPIRateLimiter().Test();
    }
    {
        AddGetTopKStockPrice s;
        s.Add("a",1);
        s.Add("b",2);
        s.Add("c",3);
        s.Add("b",4);
        s.Add("a",3);
        s.Add("d",2);
        s.GetTopK(4);
    }
    {
        AddGetFraudulentTransactionsInOrder a;
        a.Add("a", 0, 1, "aa");
        a.Add("b", 0, 2, "bb");
        a.Add("a", 0, 59, "cc");
        a.Add("c", 0, 61, "dd");
        a.Add("b", 0, 61, "ee");
        a.Add("c", 0, 130, "ff");
        a.GetAllTransactionsInOrder();
        a.GetAllFradulentTransactionsInOrder();
    }
    {
        TimeBasedKeyValStore timeMap;
        timeMap.Set("foo", "bar", 1);
        timeMap.Get("foo", 1);
        timeMap.Get("foo", 3);
        timeMap.Set("foo", "bar2", 4);
        timeMap.Get("foo", 4);
        timeMap.Get("foo", 5);
    }
    {
        NumberOfRecentCalls c;
        c.Ping(1); c.Ping(100); c.Ping(3001); c.Ping(3002);
    }

#endif
#ifdef _Math_
	/*Math*/
	RdCout ? redirect_cout::to_file("Out_Math.txt") : redirect_cout::to_cout();
	PrintH("Math");
	{
		EggDrop().MinTrialsWorstCase_Formula_2Eggs(100);
		EggDrop().MinTrialsWorstCase_Recur(2, 10);
		EggDrop().MinTrialsWorstCase_DP2D_Recur(2, 10);
		EggDrop().MinTrialsWorstCase_DP2D_Iterate(2, 10);

        //EggDrop().MinTrialsWorstCase_Recur(12, 1023);
        //EggDrop().MinTrialsWorstCase_DP2D_Recur(12, 1023);
        //EggDrop().MinTrialsWorstCase_DP2D_Iterate(12, 1023);

		EggDrop().MaxFloorsWorstCase_DP2D_Recur(2, 14);
        EggDrop().MaxFloorsWorstCase_DP2D_Iterate(2, 14);
        EggDrop().MaxFloorsWorstCase_DP2D_Recur(12, 25);
        EggDrop().MaxFloorsWorstCase_DP2D_Iterate(12, 25);
	}
	{
		WaterAndJugProblem().canMeasureWater(3, 5, 4);
		WaterAndJugProblem().canMeasureWater(2, 6, 5);
	}
    {
        Custom21Game().DP(21, 17, 10);
    }

#endif
#ifdef _BitNumberOperation_
	/*Bit Number Operation*/
	RdCout ? redirect_cout::to_file("Out_BitNumberOperation.txt") : redirect_cout::to_cout();
	PrintH("Bit Number Operation");
	{
		SwapInPlace().XOR(117, 2437);
		SwapInPlace().ElementaryArithmetic(117, 2437);
	}
	{
		Factorial().Recur(10);
		Factorial().Iterate(10);
	}
	{
		FibonacciNumber().Recur(10);
		FibonacciNumber().DP1D_Recur(10);
		FibonacciNumber().DP1D_Iterate(10);
		FibonacciNumber().Iterate(10);
		FibonacciNumber().Valid_2PerfectSquare(123);
		FibonacciNumber().Valid_2PerfectSquare(55);
		for (int i = 1; i <= 10; ++i)
			FibonacciNumber().NonFibonacci(i);
	}
	{
		ClimbingStairs().DP1DRecur(30);
		ClimbingStairs().DP1DIterate(30);
		ClimbingStairs().Iterate(30);
		ClimbingStairs().Matrix_Pow(30);
		ClimbingStairs().DP1DRecur_3(30);
		ClimbingStairs().DP1DIterate_3(30);
		ClimbingStairs().Iterate_3(30);
	}
	{
		PlusOne().NonNegative(std::vector<int>({ 2, 3, 9, 9, 9 }));
		PlusOne().NonNegative(std::vector<int>({ 9, 9, 9, 9, 9 }));

		PlusOneLinkedList::ListNode * a1 = new PlusOneLinkedList::ListNode(1);
		a1->next = new PlusOneLinkedList::ListNode(2);
		a1->next->next = new PlusOneLinkedList::ListNode(4);
		PlusOneLinkedList::ListNode * a11 = new PlusOneLinkedList::ListNode(1);
		a11->next = new PlusOneLinkedList::ListNode(2);
		a11->next->next = new PlusOneLinkedList::ListNode(4);
		std::ostringstream oss;
		PrintLinkedList<PlusOneLinkedList::ListNode, std::ostringstream>(a1, oss);
		oss << "PlusOneLinkedList ReversePlusOneReverse and Recur:" << std::endl;
		a1 = PlusOneLinkedList().ReversePlusOneReverse(a1);
		a11 = PlusOneLinkedList().ReversePlusOneReverse(a11);
		PrintLinkedList<PlusOneLinkedList::ListNode, std::ostringstream>(a1, oss);
		PrintLinkedList<PlusOneLinkedList::ListNode, std::ostringstream>(a11, oss);
		std::cout << oss.str() << std::endl;
		PlusOneLinkedList::DeleteLinkedList(a1);
		PlusOneLinkedList::DeleteLinkedList(a11);

		PlusOneLinkedList::ListNode * a2 = new PlusOneLinkedList::ListNode(9);
		a2->next = new PlusOneLinkedList::ListNode(9);
		a2->next->next = new PlusOneLinkedList::ListNode(9);
		PlusOneLinkedList::ListNode * a22 = new PlusOneLinkedList::ListNode(9);
		a22->next = new PlusOneLinkedList::ListNode(9);
		a22->next->next = new PlusOneLinkedList::ListNode(9);
		std::ostringstream oss2;
		PrintLinkedList<PlusOneLinkedList::ListNode, std::ostringstream>(a2, oss2);
		oss2 << "PlusOneLinkedList ReversePlusOneReverse and Recur:" << std::endl;
		a2 = PlusOneLinkedList().ReversePlusOneReverse(a2);
		a22 = PlusOneLinkedList().ReversePlusOneReverse(a22);
		PrintLinkedList<PlusOneLinkedList::ListNode, std::ostringstream>(a2, oss2);
		PrintLinkedList<PlusOneLinkedList::ListNode, std::ostringstream>(a22, oss2);
		std::cout << oss2.str() << std::endl;
		PlusOneLinkedList::DeleteLinkedList(a2);
		PlusOneLinkedList::DeleteLinkedList(a22);

		PlusOneLinkedList::ListNode * a3 = new PlusOneLinkedList::ListNode(5);
		a3->next = new PlusOneLinkedList::ListNode(6);
		a3->next->next = new PlusOneLinkedList::ListNode(9);
		PlusOneLinkedList::ListNode * a33 = new PlusOneLinkedList::ListNode(5);
		a33->next = new PlusOneLinkedList::ListNode(6);
		a33->next->next = new PlusOneLinkedList::ListNode(9);
		std::ostringstream oss3;
		PrintLinkedList<PlusOneLinkedList::ListNode, std::ostringstream>(a3, oss3);
		oss3 << "PlusOneLinkedList ReversePlusOneReverse and Recur:" << std::endl;
		a3 = PlusOneLinkedList().ReversePlusOneReverse(a3);
		a33 = PlusOneLinkedList().ReversePlusOneReverse(a33);
		PrintLinkedList<PlusOneLinkedList::ListNode, std::ostringstream>(a3, oss3);
		PrintLinkedList<PlusOneLinkedList::ListNode, std::ostringstream>(a33, oss3);
		std::cout << oss3.str() << std::endl;
		PlusOneLinkedList::DeleteLinkedList(a3);
		PlusOneLinkedList::DeleteLinkedList(a33);
	}
	{
		Add2BinaryStr().GO(std::string("11"), std::string("1111"));
	}
	{
		Add2IntLinkedList::ListNode * atnN1 = Add2IntLinkedList::CreateList(std::vector<int>({ 2, 4, 3 }));
		Add2IntLinkedList::ListNode * atnN2 = Add2IntLinkedList::CreateList(std::vector<int>({ 5, 6, 7 }));
		Add2IntLinkedList::ListNode * atnR = Add2IntLinkedList().Iterate(atnN1, atnN2);
		std::ostringstream atnoss;
		atnoss << "Add2IntLinkedList:" << std::endl;
		PrintLinkedList<Add2IntLinkedList::ListNode, std::ostringstream>(atnN1, atnoss);
		PrintLinkedList<Add2IntLinkedList::ListNode, std::ostringstream>(atnN2, atnoss);
		PrintLinkedList<Add2IntLinkedList::ListNode, std::ostringstream>(atnR, atnoss);
		std::cout << atnoss.str() << std::endl;
		Add2IntLinkedList::DeleteLinkedList(atnN1);
		Add2IntLinkedList::DeleteLinkedList(atnN2);
		Add2IntLinkedList::DeleteLinkedList(atnR);

		Add2IntStr().Solve(std::string("6701"), std::string("4312"));
		Add2IntStr().Solve(std::string("7001"), std::string("23"));
		Add2IntStr().Solve(std::string("1"), std::string("2"));
		Add2IntStr().Solve(std::string("5"), std::string("7"));

		Add2IntWoArithmeticOp().Solve_Recur(759, 674);
		Add2IntWoArithmeticOp().Solve_Iterate(759, 674);
		Add2IntWoArithmeticOp().Subtract(759, 674);
	}
	{
		Multiply2IntStr().GO(std::string("102"), std::string("7811"));
		Multiply2IntStr().GO(std::string("896"), std::string("38"));
	}
	{
		Divide2IntWoMulDivMod().Simplest(56, 7);
		Divide2IntWoMulDivMod().Simplest(77, 8);
		Divide2IntWoMulDivMod().Simplest(-56, 7);
		Divide2IntWoMulDivMod().Simplest(-77, -8);
		Divide2IntWoMulDivMod().MultiplicationBinarySearch(56, 7);
		Divide2IntWoMulDivMod().MultiplicationBinarySearch(77, 8);
		Divide2IntWoMulDivMod().BinarySearch_Unsigned(56, 7);
		Divide2IntWoMulDivMod().BinarySearch_Unsigned(77, 8);
		Divide2IntWoMulDivMod().LinearSearch_Unsigned(56, 7);
		Divide2IntWoMulDivMod().LinearSearch_Unsigned(77, 8);
		Divide2IntWoMulDivMod().LinearSearch(-56, 7);
		Divide2IntWoMulDivMod().LinearSearch(-77, -8);
		//for (int i = 1; i <= 350; ++i)
		//{
		//	unsigned a = Divide2IntWoMulDivMod().BinarySearch_Unsigned(44100, i);
		//	unsigned b = Divide2IntWoMulDivMod().LinearSearch_Unsigned(44100, i);
		//	unsigned c = Divide2IntWoMulDivMod().LinearSearch(44100, i);
		//	if (a != b || a != c || b != c)
		//		std::cout << "Error: Divide2IntWoMulDivMod: " << a << ", " << b << ", " << c << std::endl;
		//}
	}
	{
		SetSubstrBits().Solve(0x8000, 0x0015, 2, 6);
	}
	{
		DecimalToBinStr().Convert(3.72);
	}
	{
		NextPrevNumWSameBits().GetNext(13948);
		NextPrevNumWSameBits().GetPrev(13948);
		NextPrevNumWSameBits().GetNext(10115);
		NextPrevNumWSameBits().GetPrev(10115);

		NextPrevNumWSameBits().GetNext(1);
		NextPrevNumWSameBits().GetNext(~0 << 31);
		NextPrevNumWSameBits().GetNext(~0 << 1);
		NextPrevNumWSameBits().GetNext(INT_MAX);

		NextPrevNumWSameBits().GetPrev(1);
		NextPrevNumWSameBits().GetPrev(~0 << 31);
		NextPrevNumWSameBits().GetPrev(~0 << 1);
		NextPrevNumWSameBits().GetPrev(INT_MAX);

		NextPrevNumWSameBits().GetNext(0);
		NextPrevNumWSameBits().GetNext(~0);
		NextPrevNumWSameBits().GetPrev(0);
		NextPrevNumWSameBits().GetPrev(~0);
		NextPrevNumWSameBits().GetNext(INT_MIN);
		NextPrevNumWSameBits().GetPrev(INT_MIN);
	}
	{
		ClosestNumWSameBits().Solve(13948);
		ClosestNumWSameBits().Solve(10115);
	}
	{
		PowOf2().Valid(32);
		PowOf2().Valid(37);
		PowOf2().TwoToThePowerOfN(0);
		PowOf2().TwoToThePowerOfN(1);
		PowOf2().TwoToThePowerOfN(7);
		PowOf2().TwoToThePowerOfN(10);
	}
	{
		PowOf4().Solve(32);
		PowOf4().Solve(64);
	}
	{
		PowOf3().Solve(36);
		PowOf3().Solve(81);
	}
	{
		DiffBitsBtw2Int().Count_1s_in_XOR(432, 123);
		DiffBitsBtw2Int().Count_1s_in_XOR2(432, 123);

		DiffBitsBtw2Int().TotalHammingDist(std::vector<int>({ 4,14,2 }));
	}
	{
		SwapOddEvenBits().Solve(38721);
	}
	{
		AggregatedNumber().Solve(std::string("992101103204"));//true
		AggregatedNumber().Solve(std::string("1034"));//false
		AggregatedNumber().Solve(std::string("10313"));//true
		AggregatedNumber().Solve(std::string("112035"));//false
	}
	{
		TrailingZerosInFactorial().BruteForce(27);
		TrailingZerosInFactorial().Logarithmic(27);
		TrailingZerosInFactorial().BruteForce(100);
		TrailingZerosInFactorial().Logarithmic(100);

		TrailingZerosInFactorial().TestForFactorK(1000, 2);
		TrailingZerosInFactorial().TestForFactorK(1000, 3);
		TrailingZerosInFactorial().TestForFactorK(1000, 7);
		TrailingZerosInFactorial().TestForFactorK(1000, 9);
	}
	{
		std::cout << "Signed (" << 0 << " >> 63) = " << (0LL >> 63) << std::endl;
		std::cout << "Signed (" << (1LL << 63) << " >> 63) = " << ((1LL << 63) >> 63) << ". Signed ~0LL = " << ~0LL << std::endl;
		std::cout << "Signed (" << -65535LL << " >> 1) = " << (-65535LL >> 1) << std::endl;//-65535: 11111111111111110000000000000001. -65535 >> 1: 11111111111111111000000000000000.
		std::cout << "Unsigned (" << 0 << " >> 63) = " << (0ULL >> 63) << std::endl;
		std::cout << "Unsigned (" << (1ULL << 63) << " >> 63) = " << ((1ULL << 63) >> 63) << std::endl;

		MaxOf2NumWoComp().Solve(INT_MAX, INT_MIN);
		MaxOf2NumWoComp().Solve_Min(INT_MIN, INT_MAX);
		MaxOf2NumWoComp().WMultiplication(INT_MIN, INT_MAX);
		MaxOf2NumWoComp().WMultiplication(INT_MAX, INT_MIN);
	}
	{
		LongestContinuousBinary0s().Solve_Log32Time(1862343874);
		LongestContinuousBinary0s().Solve_Linear32Time(1862343874);
	}
	{
		NextPrevNumWSameDigits().NextHigher(324987531);
		NextPermutation().Next(std::vector<int>({ 3, 2, 4, 9, 8, 7, 5, 3, 1 }));
		NextPrevNumWSameDigits().NextHigher(987654321);
		NextPermutation().Next(std::vector<int>({ 9, 8, 7, 6, 5, 4, 3, 2, 1 }));
		NextPrevNumWSameDigits().NextHigher(324988765);
		NextPermutation().Next(std::vector<int>({ 3, 2, 4, 9, 8, 8, 7, 6, 5 }));
		NextPrevNumWSameDigits().NextHigher(324987654);
		NextPermutation().Next(std::vector<int>({ 3, 2, 4, 9, 8, 7, 6, 5, 4 }));
	}
	{
		IsPrime().CheckOddNums(48271);
		IsPrime().CheckOddNums(217);
		IsPrime().Check6PlusMinus1(48271);
		IsPrime().Check6PlusMinus1(217);
		//for (int i = 1; i < 10; ++i)
		//{
		//	IsPrime().CheckOddNums(i);
		//	IsPrime().Check6PlusMinus1(i);
		//}
		//for (int i = 1; i < 10000000; ++i)
		//{
		//	if (IsPrime().checkOddNums(i) != IsPrime().check6PlusMinus1(i))
		//		std::cout << "Found Error: " << i << std::endl;
		//}
	}
	{
		NextPrime().CheckOddNums(48271);
		NextPrime().CheckOddNums(217);
		NextPrime().CheckOddNums(4347);
		NextPrime().Check6PlusMinus1(48271);
		NextPrime().Check6PlusMinus1(217);
		NextPrime().Check6PlusMinus1(4347);
		for (int i = 0; i < 10; ++i)
		{
			NextPrime().CheckOddNums(i);
			NextPrime().Check6PlusMinus1(i);
		}
		int prime = 1000000000;
		for (int i = 0; i < 5; ++i)
		{
			prime = NextPrime().CheckOddNums(prime);
			++prime;
		}
		prime = 1000000000;
		for (int i = 0; i < 5; ++i)
		{
			prime = NextPrime().Check6PlusMinus1(prime);
			++prime;
		}
	}
	{
		AllPrimeFactors().Solve(345235);
		AllPrimeFactors().Solve(315);
	}
	{
		AllNonGreaterPrimes().TrialDivision(70);
		AllNonGreaterPrimes().Sieve(70);
		AllNonGreaterPrimes().Sieve_LessThan(70);
	}
	{
		NumOf2s().BruteForce_0toN(25);
		NumOf2s().DigitByDigit_0toN(25);
		NumOf2s().BruteForce_0toN(61523);
		NumOf2s().DigitByDigit_0toN(61523);
		NumOf2s().BruteForce_0toN(63523);
		NumOf2s().DigitByDigit_0toN(63523);
		NumOf2s().BruteForce_0toN(62523);
		NumOf2s().DigitByDigit_0toN(62523);
	}
	{
		IntegerToEnglish().Convert(123);
		IntegerToEnglish().Convert(19323984);
		IntegerToEnglish().Convert(1200000);
		IntegerToEnglish().Convert(-231200453);
		IntegerToEnglish().Convert(1234567891);
		IntegerToEnglish().Convert(INT_MAX);
		IntegerToEnglish().Convert(INT_MIN);
	}
	{
		ReverseInteger().GO(INT_MAX);
		ReverseInteger().GO(INT_MIN);
		ReverseInteger().GO(2147483630);
		ReverseInteger().GO(2147483640);
		ReverseInteger().GO(2147483641);
		ReverseInteger().GO(2147483612);
		ReverseInteger().GO(-2147483630);
		ReverseInteger().GO(-2147483640);
		ReverseInteger().GO(-2147483612);
	}
	{
		Modulus().Solve_Recur(78, 34);
		Modulus().Solve_Recur(-78, 34);
		Modulus().Solve_Recur(-78, -34);
		Modulus().Solve_Recur(78, -34);
		Modulus().Solve_Iterate(78, 34);
		Modulus().Solve_Iterate(-78, 34);
		Modulus().Solve_Iterate(-78, -34);
		Modulus().Solve_Iterate(78, -34);
	}
	{
		Sqrtx().Int_BinarySearch(0);
		Sqrtx().Int_BinarySearch(1);
		Sqrtx().Int_BinarySearch(2);
		Sqrtx().Int_BinarySearch(3);
		Sqrtx().Int_BinarySearch(4);
		Sqrtx().Int_BinarySearch(5);
		Sqrtx().Int_BinarySearch(144);
		Sqrtx().Int_BinarySearch(147);
		Sqrtx().Int_BinarySearch(140);
		//for (int i = 6; i < 40; ++i)
		//	Sqrtx().Int_BinarySearch(i);
		Sqrtx().Real_BinarySearch(0.0);
		Sqrtx().Real_BinarySearch(1.0);
		Sqrtx().Real_BinarySearch(2.0);
		Sqrtx().Real_BinarySearch(3.0);
		Sqrtx().Real_BinarySearch(4.0);
		Sqrtx().Real_BinarySearch(5.0);
		Sqrtx().Real_BinarySearch(144.0);
		Sqrtx().Real_BinarySearch(147.0);
		Sqrtx().Real_BinarySearch(140.0);
		Sqrtx().Real_BinarySearch(0.1);
		Sqrtx().Real_BinarySearch(0.3);
		Sqrtx().Real_BinarySearch(0.5);
		Sqrtx().Real_Babylonian_BinarySearch(0);
		Sqrtx().Real_Babylonian_BinarySearch(1);
		Sqrtx().Real_Babylonian_BinarySearch(2);
		Sqrtx().Real_Babylonian_BinarySearch(3);
		Sqrtx().Real_Babylonian_BinarySearch(4);
		Sqrtx().Real_Babylonian_BinarySearch(5);
		Sqrtx().Real_Babylonian_BinarySearch(144);
		Sqrtx().Real_Babylonian_BinarySearch(147);
		Sqrtx().Real_Babylonian_BinarySearch(140);

		ValidPerfectSquare().BinarySearch(60652962);
		ValidPerfectSquare().BinarySearch(60652944);
	}
	{
		MinNumByAllSingleDigitFactors().Solve(7);
		MinNumByAllSingleDigitFactors().Solve(100);
		MinNumByAllSingleDigitFactors().Solve(27);
		MinNumByAllSingleDigitFactors().Solve(31);
	}
	{
		int i = 5; int j = 3;
		GreatestCommonDivisor().WoMulDivMod_Recur(i, j);
		GreatestCommonDivisor().Mod_Iterate(i, j);
		GreatestCommonDivisor().Subtract_Iterate(i, j);
		GreatestCommonDivisor().Mod_Recur(i, j);
		i = 3; j = 5;
		GreatestCommonDivisor().WoMulDivMod_Recur(i, j);
		GreatestCommonDivisor().Mod_Iterate(i, j);
		GreatestCommonDivisor().Subtract_Iterate(i, j);
		GreatestCommonDivisor().Mod_Recur(i, j);
		i = 2; j = 3;
		GreatestCommonDivisor().WoMulDivMod_Recur(i, j);
		GreatestCommonDivisor().Mod_Iterate(i, j);
		GreatestCommonDivisor().Subtract_Iterate(i, j);
		GreatestCommonDivisor().Mod_Recur(i, j);
		i = 3; j = 2;
		GreatestCommonDivisor().WoMulDivMod_Recur(i, j);
		GreatestCommonDivisor().Mod_Iterate(i, j);
		GreatestCommonDivisor().Subtract_Iterate(i, j);
		GreatestCommonDivisor().Mod_Recur(i, j);
		i = 42; j = 35;
		GreatestCommonDivisor().WoMulDivMod_Recur(i, j);
		GreatestCommonDivisor().Mod_Iterate(i, j);
		GreatestCommonDivisor().Subtract_Iterate(i, j);
		GreatestCommonDivisor().Mod_Recur(i, j);

		LeastCommonMultiple().FromGCD(15, 9);
		LeastCommonMultiple().Iterate(15, 9);
		LeastCommonMultiple().Recur(15, 9);
	}
	{
		StrCompOrderNumSeq().Gen_DFS_Recur(1000);
		StrCompOrderNumSeq().Gen_Iterate(1000);
		StrCompOrderNumSeq().Gen_Iterate2(1000);

		StrCompOrderNumSeq().Gen_DFS_Recur(275);
		StrCompOrderNumSeq().Gen_Iterate(275);
		StrCompOrderNumSeq().Gen_Iterate2(275);

		StrCompOrderNumSeq().FindKthNum_Recur(1000, 24);
		StrCompOrderNumSeq().FindKthNum_Iterate(1000, 24);
		StrCompOrderNumSeq().FindKthNum_Recur(1000, 824);
		StrCompOrderNumSeq().FindKthNum_Iterate(1000, 824);
	}
	{
		Pow().BinaryRecur(2.0, 7);
		Pow().BinaryRecur(-2.0, -7);
		Pow().BinaryIterate(2.0, 7);
		Pow().BinaryIterate(-2.0, -7);
		Pow().Naive(2.0, 7);
		Pow().Naive(-2.0, -7);
	}
	{
		for (int i = 10; i <= 10; ++i)
		{
			CatalanNumber().Recur(i);
			CatalanNumber().Recur2(i);
			CatalanNumber().DP1D(i);
			CatalanNumber().UseBinomialCoefficient(i);
		}
	}
	{
		BinomialCoefficient().Recur(5, 2);
		BinomialCoefficient().DP2D_Recur(5, 2);
		BinomialCoefficient().DP2D(5, 2);
		BinomialCoefficient().DP1D(5, 2);
		BinomialCoefficient().Formula(5, 2);
	}
	{
		MultipleOf3().OddEvenBitCountDiff_Recur(23);
		MultipleOf9().Bitwise_Recur(37);
		MultiplyBy7().Bitwise(4);
	}
	{
		IntToBinStr().Solve(INT_MAX);
		IntToBinStr().Solve(INT_MAX - 1);
		IntToBinStr().Solve(INT_MIN);
		IntToBinStr().Solve(INT_MIN + 1);
		IntToBinStr().Solve(-0);
		IntToBinStr().Solve(-3);
		IntToBinStr().Solve(3);
		IntToBinStr().Solve(-255);
		IntToBinStr().Solve(255);
		IntToBinStr().Solve(-4);
		IntToBinStr().Solve(4);
		IntToBinStr().Solve(-5);
		IntToBinStr().Solve(5);
	}
	{
		GetSetToggleBit().GetBit(764234981, 10);
		GetSetToggleBit().SetBit(764234981, 10, 0);
		GetSetToggleBit().ToggleBit(764234981, 10);
	}
	{
		Mul2IntWoArithmeticOp().Solve(-7, 50);
		Mul2IntWoArithmeticOp().Solve2(-7, 50);
	}
	{
		TwosComplement().Solve(27);
		TwosComplement().Solve(-27);
		TwosComplement().Solve(0);
		TwosComplement().Solve(0 + 1);
		TwosComplement().Solve(0 - 1);
		TwosComplement().Solve(~0);
		TwosComplement().Solve(~0 + 1);
		TwosComplement().Solve(~0 - 1);
		TwosComplement().Solve(INT_MAX);
		//TwosComplement().Solve(INT_MAX + 1);
		TwosComplement().Solve(INT_MAX - 1);
		TwosComplement().Solve(~INT_MAX);
		TwosComplement().Solve(~INT_MAX + 1);
		//TwosComplement().Solve(~INT_MAX - 1);
		TwosComplement().Solve(INT_MIN);
		TwosComplement().Solve(INT_MIN + 1);
		//TwosComplement().Solve(INT_MIN - 1);
		TwosComplement().Solve(~INT_MIN);
		//TwosComplement().Solve(~INT_MIN + 1);
		TwosComplement().Solve(~INT_MIN - 1);
		TwosComplement().Solve(~-1);
		TwosComplement().Solve(~-2);
		TwosComplement().Solve(~-3);
		TwosComplement().Solve(~1);
	}
	{
		IsolateRightmostSetBit().Solve(56);//111000
		IsolateRightmostSetBit().Solve2(56);//111000
		IsolateRightmostSetBit().Solve3(56);//111000
		IsolateRightmostSetBit().Solve4(56);//111000
	}
	{
		MaskOfTrailingZeros().Solve(56);//111000
	}
	{
		SwapTwoBits().Solve(56, 4, 1);//111000->101010
		SwapTwoBits().Solve2(56, 4, 1);//111000->101010
	}
	{
		ReverseBits().BruteForce(56);
		ReverseBits().SwapTwoBits(56);
		ReverseBits().LookupTable(56);
		ReverseBits().Mirror(56);
		IntToBinStr().Solve(469762048);
	}
	{
		CountSetBits().Solve(56);
		CountSetBits().Sparse(56);
		CountSetBits().Dense(56);
		CountSetBits::FillBitsInChar();
		CountSetBits().ConstTime(56);
		CountSetBits().Tricky(56);
	}
	{
		CountSetBitsFrom1toN().DP(56);
	}
	{
		IndexOfOnlyOneSetBit().Iterate(1024);
		IndexOfOnlyOneSetBit().Log(1024);
		for (int i = 0; i < 32; ++i)
			IndexOfOnlyOneSetBit().BinarySearch(1U << i);
		//IndexOfOnlyOneSetBit().BinarySearch(2);
	}
	{
		ParityOfNum().FourBitParityLookup(56);
		ParityOfNum().Solve(56);
		ParityOfNum().BruteForce(56);
	}
	{
		IntToDecimalStr().Solve(12345);
		IntToDecimalStr().Solve(-12345);
		DecimalStrToInt().Solve(std::string("12345"));
		DecimalStrToInt().Solve(std::string("-12345"));
	}
	{
		StringToInteger().atoi(std::string("-1"));
		StringToInteger().atoi(std::string("   -13453456"));
	}
	{
		Base1ToBase2().Solve(std::string("56"), 10, 2);
		Base1ToBase2().Solve(std::string("1010"), 2, 16);
	}
	{
		for (int y = 1; y < 6; ++y)
		{
			XpowYmodZ().BinaryIterate(7, y, 5);
			XpowYmodZ().Iterate(7, y, 5);
			XpowYmodZ().Recur(7, y, 5);
		}

		SuperPow().BinaryRecur(2, std::vector<int>({ 3 }));
		SuperPow().BinaryRecur(2, std::vector<int>({ 1,0 }));
	}
	{
		Count1toNWoDigit4().Recur(100);
		Count1toNWoDigit4().Recur(400);
		Count1toNWoDigit4().Recur(10000);
		Count1toNWoDigit4().Recur(72481643);
	}
	{
		DivisionToDecimalStrWRepeat().Divide(2, 2);
		DivisionToDecimalStrWRepeat().Divide(5, 2);
		DivisionToDecimalStrWRepeat().Divide(1, 2);
		DivisionToDecimalStrWRepeat().Divide(1, 3);
		DivisionToDecimalStrWRepeat().Divide(1, 29);
		DivisionToDecimalStrWRepeat().Divide(22, 7);
		DivisionToDecimalStrWRepeat().Divide(58, 2828);
		DivisionToDecimalStrWRepeat().Divide(-50, 8);
		DivisionToDecimalStrWRepeat().Divide(7, -12);
	}
	{
		IncrementDigitStream ids;
		ids.Solve(std::vector<int>({ 7, 8, 9, 9, 9, 9, 9, 9, 9 }));
		ids.Solve(std::vector<int>({ 9, 8, 9, 9, 9 }));
		ids.Solve(std::vector<int>({ 9, 9, 9, 9, 9 }));
		ids.Solve(std::vector<int>({ 1, 1, 9, 9, 1, 1, 1 }));
		ids.Solve(std::vector<int>({ 9, 0, 0, 9, 0, 1, 0 }));
		ids.Solve(std::vector<int>({ 0, 0, 9, 0, 9, 9, 0, 5, 9, 0, 9, 0 }));
	}
	{
		TheOpenDoorsProblem().AllOpenDoors(100);
		TheOpenDoorsProblem().IsOpenFinally(36);
	}
	{
        ValidNumber().Better(std::string("+7.e-9"));
        ValidNumber().Better(std::string("+.7e-9"));
        ValidNumber().Better(std::string("+9e-3"));
        ValidNumber().Better(std::string("+9.e-3"));
        ValidNumber().Better(std::string("+9.e3"));
        ValidNumber().Better(std::string("9."));
        ValidNumber().Better(std::string(".9"));
        ValidNumber().Better(std::string(".9e-3"));
        ValidNumber().Better(std::string("+.9"));
        ValidNumber().Better(std::string("+.e9"));
        ValidNumber().Better(std::string(".e9"));
        ValidNumber().Better(std::string("e9"));
        ValidNumber().Better(std::string("  -.18e77  "));
		ValidNumber().BruteForce(std::string("+7.e-9"));
		ValidNumber().BruteForce(std::string("+.7e-9"));
		ValidNumber().BruteForce(std::string("+9e-3"));
		ValidNumber().BruteForce(std::string("+9.e-3"));
		ValidNumber().BruteForce(std::string("+9.e3"));
		ValidNumber().BruteForce(std::string("9."));
		ValidNumber().BruteForce(std::string(".9"));
		ValidNumber().BruteForce(std::string(".9e-3"));
		ValidNumber().BruteForce(std::string("+.9"));
		ValidNumber().BruteForce(std::string("+.e9"));
		ValidNumber().BruteForce(std::string(".e9"));
		ValidNumber().BruteForce(std::string("e9"));
        ValidNumber().BruteForce(std::string("  -.18e77  "));
		ValidNumber().Regex(std::string("  -.18e77  "));
		ValidNumber().FiniteAutomata(std::string("  -.18e77  "));
	}
	{
		RomanToInteger().RtoI(std::string("MMXIV"));
		RomanToInteger().ItoR(2014);
		//RomanToInteger().RtoI(std::string("I"));
		//RomanToInteger().RtoI(std::string("II"));
		//RomanToInteger().RtoI(std::string("III"));
		//RomanToInteger().RtoI(std::string("IV"));
		//RomanToInteger().RtoI(std::string("V"));
		//RomanToInteger().RtoI(std::string("VI"));
		//RomanToInteger().RtoI(std::string("VII"));
		//RomanToInteger().RtoI(std::string("VIII"));
		//RomanToInteger().RtoI(std::string("IX"));
		//RomanToInteger().RtoI(std::string("X"));
		//RomanToInteger().RtoI(std::string("XI"));
		//RomanToInteger().RtoI(std::string("XII"));
		//RomanToInteger().RtoI(std::string("XIII"));
		//RomanToInteger().RtoI(std::string("XIV"));
		//RomanToInteger().RtoI(std::string("XV"));
		//RomanToInteger().RtoI(std::string("XVI"));
		//RomanToInteger().RtoI(std::string("XVII"));
		//RomanToInteger().RtoI(std::string("XVIII"));
		//RomanToInteger().RtoI(std::string("XIX"));
		//RomanToInteger().RtoI(std::string("XX"));
		//RomanToInteger().RtoI(std::string("XXI"));
	}
	{
		CountAndSay().GO(7);
	}
	{
		FirstKAPlusBSqrt2().BFS_MinHeap(20);
		FirstKAPlusBSqrt2().Greedy(20);
	}
	{
		CollatzConjecture().FindSequenceRecur(17);
		CollatzConjecture().TestFirstNNums_BruteForce(17);
		CollatzConjecture().TestFirstNNums_HashTable(17);

		CollatzConjecture().IntegerReplacement(8);
		CollatzConjecture().IntegerReplacement(7);
	}
	{
		ConvertExcelColumnId().Decode(std::string("ABC"));
	}
	{
		ShortestStraightLineProgramXPowN().BruteForce_BFS_Queue(15);
	}
	{
		NthUglyNum().DP1D_3Primes(20);
		NthUglyNum().DP1D_4Primes(20);
		NthUglyNum().BruteForce_3Primes(20);
		NthUglyNum().MinHeap_MultiPrimes(12, std::vector<unsigned int>({ 2,7,13,19 }));
		NthUglyNum().MultiPrimes(12, std::vector<unsigned int>({ 2,7,13,19 }));
	}
	{
		MissingIPaddress().Test();
	}
	{
		std::string encode = RunLengthEncodedString().Encode3(std::string("aabcccccaadddddddddddddddddxxxxyyyyZz"));
		RunLengthEncodedString().Decode(encode);
	}
	{
		std::string encoded = EliasGammaEncodedString().Encode(std::vector<int>({ 9, 4, 37, 17, 3, 1 }));
		EliasGammaEncodedString().Decode(encoded);
	}
	{
		GrayCode().ReflectedList(3);
		GrayCode().ReflectedListRecur(3);
		GrayCode().Formula(3);
		GrayCode().GetTournamentPlacement(8);
		GrayCode().ReflectedList(4);
		GrayCode().ReflectedListRecur(4);
		GrayCode().Formula(4);
		GrayCode().GetTournamentPlacement(16);

		GrayCodeDecimal().Generate(1);
		GrayCodeDecimal().Generate(2);
		GrayCodeDecimal().Generate(3);
	}
	{
		HappyNumber().Recur(4);
		HappyNumber().Recur(7);
		HappyNumber().Recur(12);
	}
	{
		ClockAngle().Solve(7, 59);
		ClockAngle().Solve(5, 50);
		ClockAngle().Solve(2, 50);
		ClockAngle().Solve(10, 2);
		ClockAngle().Solve(12, 2);
	}
	{
		AddDigits().Naive(19810516);
		AddDigits().Math(19810516);
	}
	{
		IntegerBreak().Recur(10);
		IntegerBreak().DP(10);
		IntegerBreak().FromObservation(10);

		IntegerBreak().Recur(40);
		IntegerBreak().DP(40);
		IntegerBreak().FromObservation(40);
	}
	{
		BitwiseANDofNumRange().Solve(26, 30);
		BitwiseANDofNumRange().Solve2(26, 30);
		BitwiseANDofNumRange().Solve_Linear(26, 30);
	}
	{
		for (int i = 1; i <= 20; ++i)
		{
			int res1 = PerfectSquares().FourSquareTheorem(i);
			int res2 = PerfectSquares().DP(i);
			if (res1 != res2)
				std::cout << "!!!!! PerfectSquares are diff for \"" << i << "\": " << res1 << ", " << res2 << std::endl;
		}
	}
	{
		StrobogrammaticNumber().Valid(std::string("1"));
		StrobogrammaticNumber().Valid(std::string("7"));
		StrobogrammaticNumber().Valid(std::string("1680891"));

		StrobogrammaticNumber().GenerateRecur(1);
		StrobogrammaticNumber().GenerateRecur(2);
		StrobogrammaticNumber().GenerateRecur(3);
		StrobogrammaticNumber().GenerateRecur(4);

		StrobogrammaticNumber().CountInRange(std::string("50"), std::string("100"));
		StrobogrammaticNumber().CountInRange(std::string("181"), std::string("808"));
	}
	{
		std::string encode = EncodeDecodeStrings().Encode(std::vector<std::string>({ "42#asdf", "7659564235232", "yt641", "", "", "@#(*&1213", "abc", "3242342523452339#sdgf", "4", "1a" }));
		EncodeDecodeStrings().Decode(encode);
	}
	{
		NimGame().CanWin(345345);
	}
	{
		NextPrePalindromeNum().Next(99999);//all 9s
		NextPrePalindromeNum().Next(12921);//already a palindrome
		NextPrePalindromeNum().Next(89999);
		NextPrePalindromeNum().Next(948797859);

        ClosestPalindromeNum().Check7Candidates("99999");//all 9s
        ClosestPalindromeNum().Check7Candidates("12921");//already a palindrome
        ClosestPalindromeNum().Check7Candidates("89999");
        ClosestPalindromeNum().Check7Candidates("948797859");
	}
	{
		PalindromeNumber().Valid(123454321);
	}
	{
		IntToHexStr().Convert(26);
		IntToHexStr().Convert(-1);
		IntToHexStr().Convert(INT_MAX);
		IntToHexStr().Convert(INT_MAX - 1);
		IntToHexStr().Convert(INT_MIN);
		IntToHexStr().Convert(INT_MIN + 1);
		IntToHexStr().Convert(-0);
		IntToHexStr().Convert(-3);
		IntToHexStr().Convert(3);
		IntToHexStr().Convert(-255);
		IntToHexStr().Convert(255);
		IntToHexStr().Convert(-4);
		IntToHexStr().Convert(4);
		IntToHexStr().Convert(-5);
		IntToHexStr().Convert(5);
	}
	{
		NumberComplement().Solve(1);
		NumberComplement().Solve(INT_MAX);
		NumberComplement().Solve(INT_MAX - 1);
		NumberComplement().Solve(INT_MIN);
		NumberComplement().Solve(INT_MIN + 1);
		NumberComplement().Solve(-0);
		NumberComplement().Solve(-3);
		NumberComplement().Solve(3);
		NumberComplement().Solve(-255);
		NumberComplement().Solve(255);
		NumberComplement().Solve(-4);
		NumberComplement().Solve(4);
		NumberComplement().Solve(-5);
		NumberComplement().Solve(5);
	}
	{
		ValidUTF8OctetSequence().Validate(std::vector<int>({ 197, 130, 1 }));
		ValidUTF8OctetSequence().Validate(std::vector<int>({ 235, 140, 4 }));
	}
	{
		BinaryWatch().EnumerateAllTimes(1);
	}
	{
		MinNumByEliminateKDigits().SortedStack(std::string("1432219"), 3);
		MinNumByEliminateKDigits().SortedStack(std::string("10200"), 1);
		MinNumByEliminateKDigits().SortedStack(std::string("10200"), 2);
		MinNumByEliminateKDigits().SortedStack(std::string("10"), 2);
	}
	{
		MaxSumRotateFunction().LinearTime(std::vector<int>({ 4,3,2,6 }));
	}
	{
		FindNthDigitFrom1toInfinity().Solve(3);
		FindNthDigitFrom1toInfinity().Solve(11);
		FindNthDigitFrom1toInfinity().Solve(1000);
	}
	{
		MagicalString().Solve(6);
		MagicalString().Solve(19);
	}
	{
		EncodeDecodeTinyURL edt;
		std::string url = edt.encode(std::string("https://leetcode.com/problems/design-tinyurl"));
		edt.decode(url);
	}
	{
		ComplexNumberMultiplication().UseFormula(std::string("1+1i"), std::string("1+1i"));
		ComplexNumberMultiplication().UseFormula(std::string("1+-1i"), std::string("1+-1i"));
	}
	{
		LargestPalindromeProduct().ConstructCandidatePalindrome(2);
		LargestPalindromeProduct().ConstructCandidatePalindrome(3);
		//LargestPalindromeProduct().ConstructCandidatePalindrome(4);
		//LargestPalindromeProduct().ConstructCandidatePalindrome(5);
		//LargestPalindromeProduct().ConstructCandidatePalindrome(6);
		//LargestPalindromeProduct().ConstructCandidatePalindrome(7);
		//LargestPalindromeProduct().ConstructCandidatePalindrome(8);

		LargestPalindromeProduct().EnumerateAllNumsInRange(2);
		//LargestPalindromeProduct().EnumerateAllNumsInRange(3);
		//LargestPalindromeProduct().EnumerateAllNumsInRange(4);
		//LargestPalindromeProduct().EnumerateAllNumsInRange(5);
	}
	{
		PoorPigs().MinNumPigs(4, 15, 15);
		PoorPigs().MinNumPigs(8, 15, 40);
		PoorPigs().MinNumPigs(1000, 15, 60);
	}
    {
        StringCompression().InPlace_Better(std::vector<char>({'a','b','b','b','b','b','b','b','b','b','b','b','b'}));
        StringCompression().InPlace(std::vector<char>({'a','b','b','b','b','b','b','b','b','b','b','b','b'}));
    }
    {
        SelfDividingNumbers().BruteForce(1, 22);
    }
    {
        LargestMonotoneIncrNum().Linear(332);
    }
    {
        DotProductOfArrays().TwoSparseArrays(std::vector<int>({1,0,0,0,3,2,0,5}), std::vector<int>({0,0,2,1,0,4,5,0,1,0}));
        DotProductOfArrays().TwoCompressedArrays(std::vector<std::vector<int>>({{3,2},{4,1},{2,3}}), std::vector<std::vector<int>>({{6,2},{8,1}}));
        DotProductOfArrays().MaxWInsert0s_DP2D(std::vector<int>({3,6,7}), std::vector<int>({2,3,1,7,8}));
    }
    {
        ValidateIPAddress().Solve("172.16.254.1");
        ValidateIPAddress().Solve("2001:0db8:85a3:0:0:8A2E:0370:7334");
        ValidateIPAddress().Solve("256.256.256.256");
    }
    {
        MaxNumBySwap2Digits().Linear(2736);
        MaxNumBySwap2Digits().Linear(9973);
        MaxNumBySwap2Digits().Linear(98368);
        MaxNumBySwap2Digits().OnePass(2736);
        MaxNumBySwap2Digits().OnePass(9973);
        MaxNumBySwap2Digits().OnePass(98368);
    }
    {
        CountPrimeSetBitsOfNums().Solve(10, 15);
    }
    {
        CountBinaryNumsConvertableToEitherOf3().Solve(1073741727, 1073741631, 1073741535);
        CountBinaryNumsConvertableToEitherOf3().Solve(1073741809, 1073741808, 1073741809);
    }
    {
        CountConsecuNumsWTgtSum().BruteForce(15);
        CountConsecuNumsWTgtSum().UseFormula(15);
    }
    {
        RunLenEncodedIterator i(std::vector<int>({3,8,0,9,2,5}));
        i.Next(2);
        i.Next(1);
        i.Next(1);
        i.Next(2);

        RunLenEncodedIterator2 i2(std::string("L1e2t1C1o1d1e1"));
        i2.Next();i2.Next();i2.Next();i2.Next();i2.Next();i2.Next();i2.Next();i2.HasNext();i2.Next();i2.HasNext();i2.Next();
    }
    {
        CountNumsWSameDigitDiff().BFS(2, 1);
    }
    {
        IsLittleEndian().Check();
        IsLittleEndian().ReverseBytesToConvert(255);
        IsLittleEndian().ReverseBytesToConvert2(255);
        IsLittleEndian().ReverseBytesToConvert3(255);
    }
    {
        KthSymbolInGrammar().Recur(4, 5);
    }
    {
        DecodeNestedRepeatedStrAtIndex().Recur(std::string("leet2code3"), 10);
    }
    {
        NextGreaterPrimePalindromeNum().Solve(123321);
        NextGreaterPrimePalindromeNum().Solve(12321);
        NextGreaterPrimePalindromeNum().Solve(99);
        std::cout << "NextGreaterPalindromeNum for 129921: " << NextGreaterPrimePalindromeNum().NextPalindrome(129921) << std::endl;
        std::cout << "NextGreaterPalindromeNum for 12921: " << NextGreaterPrimePalindromeNum().NextPalindrome(12921) << std::endl;
    }
    {
        NumOfDaysInGivenMonth().Solve(2000, 2);
    }
    {
        IsArmstrongNumber().Solve(153);
    }

#endif
#ifdef _Random_
	/*Random*/
	RdCout ? redirect_cout::to_file("Out_Random.txt") : redirect_cout::to_cout();
	PrintH("Random");
	{
		ShuffleArray().OnlineIterate(std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }));
		ShuffleArray().OnlineRecur(std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }));
		ShuffleArray().OfflineIterate(std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }));
	}
	{
		ReservoirSampling().SolveIterate(std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }), 8);
		ReservoirSampling().SolveRecur(std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }), 8);

		std::istringstream iss("0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15");
		ReservoirSampling().Online(iss, 8);

		ReservoirSampling::ListNode * head = new ReservoirSampling::ListNode(0);
		head->next = new ReservoirSampling::ListNode(1);
		head->next->next = new ReservoirSampling::ListNode(2);
		head->next->next->next = new ReservoirSampling::ListNode(3);
		head->next->next->next->next = new ReservoirSampling::ListNode(4);
		head->next->next->next->next->next = new ReservoirSampling::ListNode(5);
		head->next->next->next->next->next->next = new ReservoirSampling::ListNode(6);
		head->next->next->next->next->next->next->next = new ReservoirSampling::ListNode(7);
		std::ostringstream oss;
		PrintLinkedList<ReservoirSampling::ListNode, std::ostringstream>(head, oss);
		std::cout << oss.str() << std::endl;
		ReservoirSampling().GetRandomNodeVal(head);
		ReservoirSampling::DeleteLinkedList(head);
	}
	{
		RandomFromStream().Generate(std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }));
	}
	{
		RandomFromProbDist dice(std::vector<int>({ 1, 1, 2, 2, 3, 3, 4, 6, 6, 7, 9,  11, 13, 15, 17 }));
		dice.Roll(std::vector<int>(				 { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 }), 1000);
	}
	{
		AliasMethod dice(std::vector<double>(
		{
			0.01, 0.01, 0.02, 0.02, 0.03,//9
			0.03, 0.04, 0.06, 0.06, 0.07,//26
			0.09, 0.11, 0.13, 0.15, 0.17,//65
		}));
		dice.Roll(std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 }), 1000);
	}
	{
		Rand7FromRand5().Roll(1000);
        Rand10FromRand7().Roll(1000);
        Rand11FromRand3().Roll(1000);
	}
	{
		for (int i = 0; i < 10; ++i)
			//Rand1toNExcludeKSortedNum().BinarySearch(10, std::vector<int>({ 2, 4, 7, 9 }));
			//Rand1toNExcludeKSortedNum().BinarySearch(20, std::vector<int>({ 4, 5, 7, 10, 11, 12, 16, 17, 18 }));
			Rand1toNExcludeKSortedNum().BinarySearch(100, std::vector<int>({ 4, 13, 19, 25, 27, 31, 39, 43, 52, 58, 64, 67, 73, 81, 88, 94 }));

		RandNonRepeat1toN(100).Roll();
		RandNonRepeat1toN_HashMap(100).Roll();
	}
    {
        for (int i = 0; i < 1; ++i)
        {
            RandomPickNumsInRangeWoRepeat r(15, 20);
            r.Test();
        }
        for (int i = 0; i < 1; ++i)
        {
            RandomPickNumsInRangeWoRepeat r(-5, 5);
            r.Test();
        }
    }
	{
		UniformRandFromRand2().Roll(0, 31, 30);
	}
	{
		OfflineSampling().Iterate(std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }), 8);
	}
	{
		RandWoModuloBias().BruteForce(101);
		RandWoModuloBias().Faster(101);
	}
	{
		RandomPermutation().OfflineIterate(30);
		RandomPermutation().OnlineIterate(30);
	}
	{
		RandomSubset().UseOfflineSampling(16, 8);
		RandomSubset().UseOfflineSampling2(16, 8);
        for (int i = 0; i < 2; ++i)
            RandomSubset().UseOfflineSampling(10, 10);
	}
	{
		RandomFromExponentialDist().Roll(1.5, 30);
	}
	{
		RandomPickIndicesOfTarget r(std::vector<int>({ 1,2,3,3,3 }));
		r.Pick(3);
		r.Pick(1);
	}
    {
        Rand2DPointInNonOvlpRects r(std::vector<std::vector<int>>({{-2,-2,-1,-1},{1,0,3,0}}));
        r.Pick();
        r.Pick();
        r.Pick();
        r.Pick();
        r.Pick();
    }

#endif
#ifdef _StackQueue_
	/*Stack Queue*/
	RdCout ? redirect_cout::to_file("Out_StackQueue.txt") : redirect_cout::to_cout();
	PrintH("Stack Queue");
	{
		SortStack().Iterate(std::stack<int>({ 3, 2, 8, 6, 5, 4, 1, 7 }));
		SortStack().InPlace_Recur(std::stack<int>({ 3, 2, 8, 6, 5, 4, 1, 7 }));
	}
	{
		std::ostringstream oss;
		oss << "QueueBy2Stacks_A: ";
		QueueBy2Stacks_A<int> q;
		q.Push(8);
		q.Push(7);
		q.Push(6);
		q.Pop();
		q.Push(5);
		q.Pop();
		q.Push(4);
		while (q.Size() > 0)
		{
			oss << q.Pop();
			if (q.Size() != 0)
				oss << ",";
		}
		oss << std::endl << "QueueBy2Stacks_B: ";
		QueueBy2Stacks_A<int> qB;
		qB.Push(8);
		qB.Push(7);
		qB.Push(6);
		qB.Pop();
		qB.Push(5);
		qB.Pop();
		qB.Push(4);
		while (qB.Size() > 0)
		{
			oss << qB.Pop();
			if (qB.Size() != 0)
				oss << ",";
		}
		std::cout << oss.str() << std::endl;
	}
	{
		SetOfStacks sos(3);
		sos.Pop();
		for (int i = 0; i < 9; ++i)
			sos.Push(i);
		sos.Print();
		sos.Pop();
		sos.Print();
		sos.Pop();
		sos.Print();
		sos.Pop();
		sos.Print();
		sos.Pop();
		sos.Print();
	}
	{
		StackWithMin1 swm1;
		for (int i = 10; i > 0; --i)
			swm1.Push(i);
		swm1.Print();
		swm1.Pop();
		swm1.Print();
		swm1.Pop();
		swm1.Print();
		swm1.Pop();
		swm1.Print();

		StackWithMin2 swm2;
		for (int i = 10; i > 0; --i)
			swm2.Push(i);
		swm2.Print();
		swm2.Pop();
		swm2.Print();
		swm2.Pop();
		swm2.Print();
		swm2.Pop();
		swm2.Print();

		StackWithMin3 swm3;
		for (int i = 10; i > 0; --i)
			swm3.Push(i);
		swm3.Print();
		swm3.Pop();
		swm3.Print();
		swm3.Pop();
		swm3.Print();
		swm3.Pop();
		swm3.Print();
	}
	{
		MultiStacksByAnArray stks(3, 5);
		stks.Push(0, 1);
		stks.Push(0, 2);
		stks.Push(0, 3);
		stks.Push(1, 11);
		stks.Push(1, 12);
		stks.Push(1, 13);
		stks.Push(2, 101);
		stks.Push(2, 102);
		stks.Push(2, 103);
		stks.Print();
		stks.Pop(2);
		stks.Print();
		stks.Pop(1);
		stks.Print();
		stks.Pop(0);
		stks.Print();
		stks.Push(2, 104);
		stks.Print();
		stks.Push(1, 14);
		stks.Print();
		stks.Push(0, 4);
		stks.Print();
	}
	{
		std::ostringstream oss;
		oss << "StackBy2Queues_A: ";
		StackBy2Queues_A<int> sbqA;
		sbqA.Push(0);
		sbqA.Push(1);
		sbqA.Push(2);
		sbqA.Pop();
		sbqA.Push(3);
		sbqA.Pop();
		sbqA.Push(4);
		while (sbqA.Size() > 0)
		{
			oss << sbqA.Pop();
			if (sbqA.Size() != 0)
				oss << ",";
		}
		oss << std::endl << "StackBy2Queues_B: ";
		StackBy2Queues_B<int> sbqB;
		sbqB.Push(5);
		sbqB.Push(6);
		sbqB.Push(7);
		sbqB.Pop();
		sbqB.Push(8);
		sbqB.Pop();
		sbqB.Push(9);
		while (sbqB.Size() > 0)
		{
			oss << sbqB.Pop();
			if (sbqB.Size() != 0)
				oss << ",";
		}
		std::cout << oss.str() << std::endl;
	}
	{
		QueueWithMin q;
		q.Push(10);
		q.Push(14);
		q.Push(9);
		q.Push(11);
		q.Push(9);
		q.Push(13);
		q.Print();
		q.Pop();
		q.Pop();
		q.Pop();
		q.Print();
		q.Push(5);
		q.Push(7);
		q.Push(8);
		q.Print();
	}
	{
		EvalReversePolishNotation().Evaluate(std::vector<std::string>({ "2", "1", "+", "3", "*" }));
		EvalReversePolishNotation().Evaluate(std::vector<std::string>({ "4", "13", "5", "/", "+" }));
		EvalReversePolishNotation().Evaluate(std::vector<std::string>({ "3", "4", "+", "2", "1", "*", "+" }));
		EvalReversePolishNotation().Evaluate(std::vector<std::string>({ "1", "1", "+", "-2", "*" }));
		EvalReversePolishNotation().Evaluate(std::vector<std::string>({ "4", "6", "/", "2", "/" }));

		EvalPolishNotation().Evaluate(std::vector<std::string>({ "/", "-", "*", "2", "5", "*", "1", "2", "-", "11", "9" }));
		EvalPolishNotation().Evaluate(std::vector<std::string>({ "-", "*", "/", "15", "-", "7", "+", "1", "1", "3", "+", "2", "+", "1", "1" }));
	}
	{
		ValidParentheses().Test(std::string("({[)(}{])}"));
		ValidParentheses().Test(std::string("[{()}]"));
		ValidParentheses().Test(std::string("({[)(}{])}"));
		ValidParentheses().Test(std::string("[{{(())}}]{[[[]]]}"));

		ValidParenthesesMinAdd().OnePass(std::string(")(()("));
        ValidParenthesesMinAdd().OnePass(std::string("())"));
        ValidParenthesesMinAdd().OnePass(std::string("((("));
        ValidParenthesesMinAdd().OnePass(std::string("()"));
        ValidParenthesesMinAdd().OnePass(std::string("()))(("));
        ValidParenthesesMinAdd().OnePass(std::string(")))()))"));
	}
	{
		SimplifyPath().Stack(std::string("/a/./b/../../c/"));
		NormalizePath().Stack(std::string("/a/./b/../../c/"));

		SimplifyPath().Stack(std::string("/a/./b/./c//../../d/"));
		NormalizePath().Stack(std::string("/a/./b/./c//../../d/"));

		SimplifyPath().Stack(std::string("usr/lib/../bin/gcc"));
		NormalizePath().Stack(std::string("usr/lib/../bin/gcc"));

		SimplifyPath().Stack(std::string("/usr/lib/../bin/gcc"));
		NormalizePath().Stack(std::string("/usr/lib/../bin/gcc"));

		SimplifyPath().Stack(std::string("xyz/abc//./../scripts/awkscripts/././"));
		NormalizePath().Stack(std::string("xyz/abc//./../scripts/awkscripts/././"));

		SimplifyPath().Stack(std::string("../../local"));
		NormalizePath().Stack(std::string("../../local"));

		SimplifyPath().Stack(std::string("./../"));
		NormalizePath().Stack(std::string("./../"));

		SimplifyPath().Stack(std::string("/../"));
		NormalizePath().Stack(std::string("/../"));
	}
	{
		LongestAbsFilePath().UseStack(std::string("dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"));
		LongestAbsFilePath().UseStack(std::string("dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"));
		LongestAbsFilePath().UseStack(std::string("dir\n\t\tfile.ext"));
		LongestAbsFilePath().UseStack(std::string("dir\n\t file.ext"));
	}
	{
		std::cout << "CircularQueueByArray:" << std::endl;
		CircularQueueByArray q(2);
		q.Print();
		for (int i = 1; i < 15; ++i)
			q.Enqueue(i);
		q.Print();
		for (int i = 1; i < 5; ++i)
		{
			q.Dequeue();
			q.Print();
		}
		for (int i = 1; i < 9; ++i)
		{
			q.Enqueue(i + 100);
			q.Print();
		}
	}
	{
		std::cout << "DequeByCircularArray:" << std::endl;
		DequeByCircularArray d(2);
		d.Print();
		for (int i = 1; i < 15; ++i)
			d.PushFront(i);
		d.Print();
		for (int i = 1; i < 5; ++i)
		{
			d.PopBack();
			d.Print();
		}
		for (int i = 1; i < 9; ++i)
		{
			d.PushFront(i + 100);
			d.Print();
		}
		for (int i = 0; i < d.Size(); ++i)
			std::cout << d.Get(i).first << std::endl;
	}
	{
		BasicCalculator().UseRPN(std::string("((2 + 1) * 3)"));
		BasicCalculator().UseRPN(std::string("(4 + (13 / 5))"));
		BasicCalculator().UseRPN(std::string("(7)-(0)+(4)"));
		BasicCalculator().UseRPN(std::string("3+2*2"));
		BasicCalculator().UseRPN(std::string("3/2 "));
		BasicCalculator().UseRPN(std::string("3+5 / 2 "));
		BasicCalculator().BruteForce_OnlyPlusMinus(std::string("1 + 1"));
		BasicCalculator().BruteForce_OnlyPlusMinus(std::string(" 2-1 + 2 "));
		BasicCalculator().BruteForce_OnlyPlusMinus(std::string("(1+(4+5+2)-3)+(6+8)"));

        BasicCalculator2().Recur(std::string("((2 + 1) * 3)"));
        BasicCalculator2().Recur(std::string("(4 + (13 / 5))"));
        BasicCalculator2().Recur(std::string("(7)-(0)+(4)"));
        BasicCalculator2().Recur(std::string("3+2*2"));
        BasicCalculator2().Recur(std::string("3/2 "));
        BasicCalculator2().Recur(std::string("3+5 / 2 "));
	}
	{
		StackByHeap s;
		s.Push(11);
		s.Push(12);
		s.Push(13);
		s.Push(14);
		s.Push(15);
		s.Print();
		s.Pop();
		s.Pop();
		s.Print();
		s.Push(16);
		s.Push(17);
		s.Print();
	}
	{
		QueueByHeap q;
		q.Enqueue(11);
		q.Enqueue(12);
		q.Enqueue(13);
		q.Enqueue(14);
		q.Enqueue(15);
		q.Print();
		q.Dequeue();
		q.Dequeue();
		q.Print();
		q.Enqueue(16);
		q.Enqueue(17);
		q.Print();
	}
	{
		MovingAvgFromDataStream a(3);
		a.next(1);
		a.next(10);
		a.next(3);
		a.next(5);
	}
	{
		for (int i = 0; i < 10; ++i)
			StackReproduceDiffOrderArray().UseStack(TestCase::RandUniqueVec<int>(7, 0, 6), TestCase::RandUniqueVec<int>(7, 0, 6));
	}
    {
        StackWithMax s;
        s.push(5);
        s.push(1);
        s.push(5);
        s.top();
        s.popMax();
        s.top();
        s.peekMax();
        s.pop();
        s.top();
    }
    {
        StackPermutation().Validate1(std::vector<int>({1,2,3,4,5}), std::vector<int>({4,5,3,2,1}));
        StackPermutation().Validate(std::vector<int>({1,2,3,4,5}), std::vector<int>({4,5,3,2,1}));
    }
    {
        MaxFreqStack s;
        s.Push(5);
        s.Push(7);
        s.Push(5);
        s.Push(7);
        s.Push(4);
        s.Push(5);
        s.Pop();
        s.Pop();
        s.Pop();
        s.Pop();
    }
    {
        ScoreOfParentheses().UseStack(std::string("(()(()))"));
        ScoreOfParentheses().ConstSpace(std::string("(()(()))"));
    }
    {
        RemoveOutermostParenOfEachPrimitive().OneScan(std::string("(()())(())(()(()))"));
    }

#endif
#ifdef _1DArray_
	/*1D Array*/
	RdCout ? redirect_cout::to_file("Out_1DArray.txt") : redirect_cout::to_cout();
	PrintH("1D Array");
	{
		AllUniqueElements().CharArray(std::string("afcdefg"));
		AllUniqueElements().CharArray2(std::string("abcdefg"));
	}
	{
		RemoveSomeElementFromArray().InPlace(&std::vector<int>({ 6, 8, 7, 4, 2, 1, 7, 8, 9, 5 })[0], 10, 7);
		char A[] = "xbyzacdafcbmacnij";
		RemoveSomeElementFromArray().InPlace_b_and_ac(A, 17);

		RemoveReplaceElementFromArr().InPlace_Remove_b_Replace_a_dd(std::string("xayzbbabbijakaaba"));
	}
	{
		RemoveDupsFromUnsortedArray().InPlace_QuadraticTime(std::string("abcd"));
		RemoveDupsFromUnsortedArray().InPlace_QuadraticTime(std::string("aaaa"));
		RemoveDupsFromUnsortedArray().InPlace_QuadraticTime(std::string("aaabbb"));
		RemoveDupsFromUnsortedArray().InPlace_QuadraticTime(std::string("abababa"));
		RemoveDupsFromUnsortedArray().CharVec_LinearTime(std::string("abcd"));
		RemoveDupsFromUnsortedArray().CharVec_LinearTime(std::string("aaaa"));
		RemoveDupsFromUnsortedArray().CharVec_LinearTime(std::string("aaabbb"));
		RemoveDupsFromUnsortedArray().CharVec_LinearTime(std::string("abababa"));

		RemoveDupsFromUnsortedArrayMinLexicographical().SortedStack(std::string("bcabc"));
		RemoveDupsFromUnsortedArrayMinLexicographical().SortedStack(std::string("cbacdcbc"));
	}
	{
		ReverseWords().ReverseChars(&std::string("abcdefg")[0]);
		ReverseWords().ReverseWordsInPlace_RemoveExtraSpace(std::string(" the  sky is   blue  "));
		ReverseWords().ReverseWordsInPlace_KeepExtraSpace(std::string(" the  sky is   blue  "));
		ReverseWords().ReverseCharsInWordsInPlace_KeepExtraSpace(std::string(" the  sky is   blue  "));
	}
	{
		GasStation().FindStart_Greedy(
			std::vector<int>({ 7, 2, 7, 1, 4, 6, 5 }), //gas
			std::vector<int>({ 5, 3, 1, 4, 7, 2, 6 }));//cost
		GasStation().FindStart_Greedy2(
			std::vector<int>({ 7, 2, 7, 1, 4, 6, 5 }), //gas
			std::vector<int>({ 5, 3, 1, 4, 7, 2, 6 }));//cost
		GasStation().FindStart_BruteForce(
			std::vector<int>({ 7, 2, 7, 1, 4, 6, 5 }), //gas
			std::vector<int>({ 5, 3, 1, 4, 7, 2, 6 }));//cost

		GasStation().FindStart_Greedy(
			std::vector<int>({ 7, 2, 7, 1, 4, 6, 5 }), //gas
			std::vector<int>({ 5, 5, 1, 3, 7, 2, 6 }));//cost
		GasStation().FindStart_Greedy2(
			std::vector<int>({ 7, 2, 7, 1, 4, 6, 5 }), //gas
			std::vector<int>({ 5, 5, 1, 3, 7, 2, 6 }));//cost
		GasStation().FindStart_BruteForce(
			std::vector<int>({ 7, 2, 7, 1, 4, 6, 5 }), //gas
			std::vector<int>({ 5, 5, 1, 3, 7, 2, 6 }));//cost

		GasStation().FindStart_Greedy(
			std::vector<int>({ 7, 2, 7, 1, 4, 6, 5 }), //gas
			std::vector<int>({ 5, 5, 1, 3, 9, 2, 6 }));//cost
		GasStation().FindStart_Greedy2(
			std::vector<int>({ 7, 2, 7, 1, 4, 6, 5 }), //gas
			std::vector<int>({ 5, 5, 1, 3, 9, 2, 6 }));//cost
		GasStation().FindStart_BruteForce(
			std::vector<int>({ 7, 2, 7, 1, 4, 6, 5 }), //gas
			std::vector<int>({ 5, 5, 1, 3, 9, 2, 6 }));//cost

		GasStation().FindStart_Greedy(
			std::vector<int>({ 7, 2, 7, 1, 4, 6, 5 }), //gas
			std::vector<int>({ 5, 5, 1, 3, 9, 7, 6 }));//cost
		GasStation().FindStart_Greedy2(
			std::vector<int>({ 7, 2, 7, 1, 4, 6, 5 }), //gas
			std::vector<int>({ 5, 5, 1, 3, 9, 7, 6 }));//cost
		GasStation().FindStart_BruteForce(
			std::vector<int>({ 7, 2, 7, 1, 4, 6, 5 }), //gas
			std::vector<int>({ 5, 5, 1, 3, 9, 7, 6 }));//cost

		GasStation2().FindStart_Greedy(std::vector<int>({ 20, 15, 15, 15, 35, 25, 30, 15, 65, 45, 10, 45, 25 }), std::vector<int>({ 300, 400, 1000, 300, 300, 600, 400, 1100, 400, 1000, 200, 300, 300 }), 20);
		GasStation2().FindStart_BruteForce(std::vector<int>({ 20, 15, 15, 15, 35, 25, 30, 15, 65, 45, 10, 45, 25 }), std::vector<int>({ 300, 400, 1000, 300, 300, 600, 400, 1100, 400, 1000, 200, 300, 300 }), 20);
	}
	{
		JumpGame().CanJump_Greedy(&std::vector<int>({ 1, 2, 3, 0, 3 })[0], 5);
		JumpGame().CanJump_DP(&std::vector<int>({ 1, 2, 3, 0, 3 })[0], 5);
		JumpGame().MinJumps_Greedy(&std::vector<int>({ 3, 2, 3, 0, 1, 3, 0, 1 })[0], 8);
		JumpGame().MinJumps_DP(&std::vector<int>({ 3, 2, 3, 0, 1, 3, 0, 1 })[0], 8);
	}
	{
		Candy().Iterate_2Pass(std::vector<int>({ 3, 8, 9, 1, 2, 4, 5, 7, 6, 5, 4, 3 }));
		Candy().Iterate_2Pass_DP1D(std::vector<int>({ 3, 8, 9, 1, 2, 4, 5, 7, 6, 5, 4, 3 }));
		Candy().BruteForce_MinHeap(std::vector<int>({ 3, 8, 9, 1, 2, 4, 5, 7, 6, 5, 4, 3 }));
	}
	{
		LenOfLastWord().Count(&std::string(" hello world   ")[0]);
	}
	{
		RotatedStr().Solve_WConcat(std::string("aaabab"), std::string("abaaab"));
		RotatedStr().Solve_WoConcat(std::string("aaabab"), std::string("abaaab"));
		RotatedStr().Solve_WoConcat(std::string("abcaabbbbca"), std::string("bcaabcaabbb"));
		RotatedStr().Solve_WoConcat(std::string("aabbccaabca"), std::string("caabcaaabbc"));
		RotatedStr().Solve_WoConcat(std::string("aabbccaabca"), std::string("caabdaaabbc"));
		RotatedStr().Solve_WoConcat(std::string("aaba"), std::string("baaa"));
		RotatedStr().Solve_WoConcat(std::string("aaaaa"), std::string("aaaaa"));
		RotatedStr().Solve_WoConcat(std::string("aacaabaa"), std::string("caabaaaa"));
	}
	{
		RotateArray().ToLeft_OneByOne(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7 }), 5);
		RotateArray().ToLeft_OneByOne(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7 }), 6);
		RotateArray().ToLeft_MoveSets(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7 }), 5);
		RotateArray().ToLeft_MoveSets(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7 }), 6);
		RotateArray().ToLeft_MoveSets(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7, 8 }), 5);
		RotateArray().ToLeft_MoveSets(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7, 8 }), 2);
		RotateArray().ToLeft_SwapReverse2Subarr(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7 }), 5);
		RotateArray().ToLeft_SwapReverse2Subarr(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7 }), 6);
		RotateArray().ToLeft_SwapReverse2Subarr(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7, 8 }), 5);
		RotateArray().ToLeft_SwapReverse2Subarr(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7, 8 }), 2);

		RotateArray().ToRight_MoveSets(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7 }), 5);
		RotateArray().ToRight_MoveSets(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7 }), 6);
		RotateArray().ToRight_MoveSets(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7, 8 }), 5);
		RotateArray().ToRight_MoveSets(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7, 8 }), 2);
		RotateArray().ToRight_SwapReverse2Subarr(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7 }), 5);
		RotateArray().ToRight_SwapReverse2Subarr(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7 }), 6);
		RotateArray().ToRight_SwapReverse2Subarr(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7, 8 }), 5);
		RotateArray().ToRight_SwapReverse2Subarr(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7, 8 }), 2);
	}
	{
		CoinsInLine().MaxVal_Recur(std::vector<int>({ 3, 2, 2, 3, 1, 2 }));
		CoinsInLine().MaxVal_DP2D_Recur(std::vector<int>({ 3, 2, 2, 3, 1, 2 }));
		CoinsInLine().MaxVal_DP2D_Iterate(std::vector<int>({ 3, 2, 2, 3, 1, 2 }));

		MinRemovalOfEndInArrayUntil().Count_Recur(std::vector<int>({ 4, 5, 100, 9, 10, 11, 12, 15, 200 }));
		MinRemovalOfEndInArrayUntil().Count_DP2D(std::vector<int>({ 4, 5, 100, 9, 10, 11, 12, 15, 200 }));
		MinRemovalOfEndInArrayUntil().Count_Reversely(std::vector<int>({ 4, 5, 100, 9, 10, 11, 12, 15, 200 }));
		MinRemovalOfEndInArrayUntil().Count_Recur(std::vector<int>({ 9, 10, 11, 12, 15 }));
		MinRemovalOfEndInArrayUntil().Count_DP2D(std::vector<int>({ 9, 10, 11, 12, 15 }));
		MinRemovalOfEndInArrayUntil().Count_Reversely(std::vector<int>({ 9, 10, 11, 12, 15 }));
	}
	{
		MultiplicationOfNums().Solve(std::vector<int>({ 4, 3, 2, 1, 2 }));
		MultiplicationOfNums().Solve_2Scans(std::vector<int>({ 4, 3, 2, 1, 2 }));
		MultiplicationOfNums().DP1D(std::vector<int>({ 4, 3, 2, 1, 2 }));
		MultiplicationOfNums().FindMaxProduct(std::vector<int>({ 4, 3, 2, 1, 2 }));
	}
	{
		OddOccurNum().FindOneOddOccur_FromEvenOccurArray(std::vector<int>({ 2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2 }));
		OddOccurNum().FindTwoOddOccur_FromEvenOccurArray(std::vector<int>({ 2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 2 }));
		OddOccurNum().FindOneOccur_FromThreeOccurArray(std::vector<int>({ 2, 1, 4, 5, 1, 4, 2, 2, 4, 1 }));
		OddOccurNum().FindOneOccur_FromThreeOccurArray2(std::vector<int>({ 2, 1, 4, 5, 1, 4, 2, 2, 4, 1 }));
		OddOccurNum().FindOneOccur_FromThreeOccurArray3(std::vector<int>({ 2, 1, 4, 5, 1, 4, 2, 2, 4, 1 }));
		OddOccurNum().FindOneOccur_FromThreeOccurArray(std::vector<int>({ 3, 3, 2, 3 }));
		OddOccurNum().FindOneOccur_FromThreeOccurArray2(std::vector<int>({ 3, 3, 2, 3 }));
		OddOccurNum().FindOneOccur_FromThreeOccurArray3(std::vector<int>({ 3, 3, 2, 3 }));

        /*
		std::cout << KeyGenAux().UIntToBinStrTrunc(0) << std::endl;
		std::cout << KeyGenAux().UIntToBinStr(0) << std::endl;
		std::cout << KeyGenAux().UIntToBinStrTrunc(1) << std::endl;
		std::cout << KeyGenAux().UIntToBinStr(1) << std::endl;
		std::cout << KeyGenAux().UIntToBinStrTrunc(UINT32_MAX) << std::endl;
		std::cout << KeyGenAux().UIntToBinStr(UINT32_MAX) << std::endl;
		std::cout << KeyGenAux().UIntToBinStrTrunc(INT_MAX) << std::endl;
		std::cout << KeyGenAux().UIntToBinStr(INT_MAX) << std::endl;
		*/
	}
	{
		MajorityElement().MooresVotingAlgo(std::vector<int>({ 1, 1, 2, 3, 4, 1, 6, 1, 7, 1, 1 }));
		MajorityElement().MooresVotingAlgo2(std::vector<int>({ 1, 1, 2, 3, 4, 1, 6, 1, 7, 1, 1 }));
		MajorityElement().RepeatExclude2DiffElements(std::vector<int>({ 1, 1, 2, 3, 4, 1, 6, 1, 7, 1, 1 }));
		MajorityElement().MooresVotingAlgo(std::vector<int>({ 3, 2, 4, 4, 4, 2, 1, 1, 3, 6, 1, 1, 1, 1, 6, 1, 1, 2, 7, 1, 1, 6, 1, 1, 1, 1, 7, 1 }));
		MajorityElement().MooresVotingAlgo2(std::vector<int>({ 3, 2, 4, 4, 4, 2, 1, 1, 3, 6, 1, 1, 1, 1, 6, 1, 1, 2, 7, 1, 1, 6, 1, 1, 1, 1, 7, 1 }));
		MajorityElement().RepeatExclude2DiffElements(std::vector<int>({ 3, 2, 4, 4, 4, 2, 1, 1, 3, 6, 1, 1, 1, 1, 6, 1, 1, 2, 7, 1, 1, 6, 1, 1, 1, 1, 7, 1 }));
		MajorityElement().MooresVotingAlgo_FromInputStream(std::istringstream("a b d f a f e f c f f e f f a f b f d f"));

		MajorityElement2().MoreThanNDividedBy3(std::vector<int>({ 1, 1, 4, 5, 2, 3, 3, 3, 3, 2, 2, 4, 1, 3, 2, 2, 1, 2, 3, 2, 3, 2, 3 }));
	}
	{
		GeneralizedMajorityElements().FromInputStream(std::istringstream("a b d d a d e f c f a e d f a a b f d f"), 4);
	}
	{
		AllStockSpans().SortedStack(std::vector<int>({ 9, 7, 4, 5, 4, 5, 8 }));
	}
	{
		MaxBandwidthOverWindowTimeInterval().ByQueueWithMax(std::vector<std::pair<int, int>>({ { 0, 1 }, { 2, 2 }, { 3, 3 }, { 5, 1 }, { 6, 2 }, { 8, 2 }, { 9, 1 } }), 3);
	}
	{
		SingleDupInIdxSeqArray().Find_CycleBegin(std::vector<int>({ 9, 5, 2, 7, 3, 11, 1, 13, 14, 10, 7, 12, 4, 8, 6 }));//value range: 1-14, size: 15
		SingleDupInIdxSeqArray().Find_XOR(std::vector<int>({ 9, 5, 2, 7, 3, 11, 1, 13, 14, 10, 7, 12, 4, 8, 6 }));//value range: 1-14, size: 15
		SingleDupInIdxSeqArray().Find_CycleBegin(std::vector<int>({ 9, 5, 2, 14, 3, 11, 1, 13, 14, 10, 7, 12, 4, 8, 6 }));//value range: 1-14, size: 15
		SingleDupInIdxSeqArray().Find_XOR(std::vector<int>({ 9, 5, 2, 14, 3, 11, 1, 13, 14, 10, 7, 12, 4, 8, 6 }));//value range: 1-14, size: 15
		MissingDupPairInIdxSeqArray().BySumNSquareSum(std::vector<int>({ 9, 5, 2, 7, 3, 11, 1, 13, 14, 10, 7, 12, 4, 0, 6 }));//value range: 0-14, size: 15
		MissingDupPairInIdxSeqArray().ByXOR(std::vector<int>({ 9, 5, 2, 7, 3, 11, 1, 13, 14, 10, 7, 12, 4, 0, 6 }));//value range: 0-14, size: 15
		MissingDupPairInIdxSeqArray().BySumNSquareSum(std::vector<int>({ 9, 5, 2, 8, 3, 11, 1, 13, 14, 10, 0, 12, 4, 0, 6 }));//value range: 0-14, size: 15
		MissingDupPairInIdxSeqArray().ByXOR(std::vector<int>({ 9, 5, 2, 8, 3, 11, 1, 13, 14, 10, 0, 12, 4, 0, 6 }));//value range: 0-14, size: 15
		MissingDupPairInIdxSeqArray().BySumNSquareSum(std::vector<int>({ 9, 5, 2, 7, 3, 11, 1, 13, 14, 10, 8, 12, 4, 7, 6 }));//value range: 0-14, size: 15
		MissingDupPairInIdxSeqArray().ByXOR(std::vector<int>({ 9, 5, 2, 7, 3, 11, 1, 13, 14, 10, 8, 12, 4, 7, 6 }));//value range: 0-14, size: 15
		TwoDiffDupInIdxSeqArray().Find_XOR(std::vector<int>({ 4, 2, 4, 5, 2, 3, 1 }));//value range: 1-5, size: 7
		MultiDupInIdxSeqArray().FindAllDup_MarkNegative(std::vector<int>({ 1, 2, 3, 1, 3, 6, 6 }));
		MultiDupInIdxSeqArray().FindAllMissing_MarkNegative(std::vector<int>({ 4, 3, 2, 7, 8, 2, 3, 1 }));
	}
	{
		ReplaceAllSpacesWPercent20().InPlace(std::string(" the sky is blue! hello world "));
	}
	{
		RearrangeToWaveArray().WiggleSort(std::vector<int>({ 8, 17, 3, 7, 14, 13, 5, 9, 12, 15, 2 }));
		RearrangeToWaveArray().WiggleSort(std::vector<int>({ 3, 5, 2, 1, 6, 4 }));
		RearrangeToWaveArray().WiggleSort(std::vector<int>({ 1, 5, 1, 1, 6, 4 }));
		RearrangeToWaveArray().WiggleSort(std::vector<int>({ 1, 3, 2, 2, 3, 1 }));

		RearrangeToWaveArray().WiggleSortII(std::vector<int>({ 8, 17, 3, 7, 14, 13, 5, 9, 12, 15, 2 }));
		RearrangeToWaveArray().WiggleSortII(std::vector<int>({ 3, 5, 2, 1, 6, 4 }));
		RearrangeToWaveArray().WiggleSortII(std::vector<int>({ 1, 5, 1, 1, 6, 4 }));
		RearrangeToWaveArray().WiggleSortII(std::vector<int>({ 1, 3, 2, 2, 3, 1 }));
	}
	{
		FirstDupInUnsortedArray().HashTable(std::vector<int>({ 9, 5, 3, 4, 3, 5, 6 }));
	}
	{
		//TwoIncrElementsWMaxDistInArr().Greedy(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2, 17 }));
		//TwoIncrElementsWMaxDistInArr().Greedy(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 4, 3, 2, 7 }));
		//TwoIncrElementsWMaxDistInArr().Greedy(std::vector<int>({ 5, 1, 1, 8, 2, 6 }));

		TwoIncrElementsWMaxDistInArr().BruteForce(std::vector<int>({ 21, 20, 19, 18, 17, 16, 15, 13, 17, 18, 1, 2, 3, 14, 4, 5, 15, 6, 7, -1, 0, -1, -2, -3, -4 }));
		TwoIncrElementsWMaxDistInArr().Greedy(std::vector<int>({ 21, 20, 19, 18, 17, 16, 15, 13, 17, 18, 1, 2, 3, 14, 4, 5, 15, 6, 7, -1, 0, -1, -2, -3, -4 }));
		TwoIncrElementsWMaxDistInArr().Recur(std::vector<int>({ 21, 20, 19, 18, 17, 16, 15, 13, 17, 18, 1, 2, 3, 14, 4, 5, 15, 6, 7, -1, 0, -1, -2, -3, -4 }));
		TwoIncrElementsWMaxDistInArr().DP2D(std::vector<int>({ 21, 20, 19, 18, 17, 16, 15, 13, 17, 18, 1, 2, 3, 14, 4, 5, 15, 6, 7, -1, 0, -1, -2, -3, -4 }));
		//for (int i = 0; i < 10; ++i)
		//{
		//	std::vector<int> v = TestCase::RandVec(17, 1, 40);
		//	TwoIncrElementsWMaxDistInArr().BruteForce(v);
		//	TwoIncrElementsWMaxDistInArr().Greedy(v);
		//	TwoIncrElementsWMaxDistInArr().Recur(v);
		//	TwoIncrElementsWMaxDistInArr().DP2D(v);
		//}
	}
	{
		int buySellStockVec[] = { 15, 30, 24, 33, 11, 13, 17, 16, 21, 12, 24, 18 };
		BestTimeBuySellStock().MaxProfit_OneTransaction(std::vector<int>(buySellStockVec, buySellStockVec + sizeof(buySellStockVec) / sizeof(int)));
		BestTimeBuySellStock().MaxProfit_UnlimitedTransactions(std::vector<int>(buySellStockVec, buySellStockVec + sizeof(buySellStockVec) / sizeof(int)));
		BestTimeBuySellStock().MaxProfit_AtMost2Transactions(std::vector<int>(buySellStockVec, buySellStockVec + sizeof(buySellStockVec) / sizeof(int)));
		BestTimeBuySellStock().MaxProfit_AtMostKTransactions_DP1D(std::vector<int>(buySellStockVec, buySellStockVec + sizeof(buySellStockVec) / sizeof(int)), 5);
		BestTimeBuySellStock().MaxProfit_AtMostKTransactions_DP2D(std::vector<int>(buySellStockVec, buySellStockVec + sizeof(buySellStockVec) / sizeof(int)), 5);
		BestTimeBuySellStock().MaxProfit_AtMostKTransactions_DP1D_2(std::vector<int>(buySellStockVec, buySellStockVec + sizeof(buySellStockVec) / sizeof(int)), 5);
		BestTimeBuySellStock().MaxProfit_Cooldown1DayAfterSell(std::vector<int>(buySellStockVec, buySellStockVec + sizeof(buySellStockVec) / sizeof(int)));

		BestTimeBuySellStock().MaxProfit_AtMostKTransactions_DP1D(std::vector<int>({ 15, 30, 24, 33, 11, 13, 17, 16, 21, 12, 30, 18 }), 5);
		BestTimeBuySellStock().MaxProfit_AtMostKTransactions_DP1D(std::vector<int>({ 2, 0, 2, 3 }), 1);
		BestTimeBuySellStock().MaxProfit_AtMostKTransactions_DP1D(std::vector<int>({ 1, 2, 3, 1 }), 1);
		BestTimeBuySellStock().MaxProfit_AtMostKTransactions_DP1D(std::vector<int>({ 1, 2, 4, 2, 5, 7, 2, 4, 9, 0 }), 4);

		BestTimeBuySellStock().MaxProfit_AtMostKTransactions_DP2D(std::vector<int>({ 15, 30, 24, 33, 11, 13, 17, 16, 21, 12, 30, 18 }), 5);
		BestTimeBuySellStock().MaxProfit_AtMostKTransactions_DP2D(std::vector<int>({ 2, 0, 2, 3 }), 1);
		BestTimeBuySellStock().MaxProfit_AtMostKTransactions_DP2D(std::vector<int>({ 1, 2, 3, 1 }), 1);
		BestTimeBuySellStock().MaxProfit_AtMostKTransactions_DP2D(std::vector<int>({ 1, 2, 4, 2, 5, 7, 2, 4, 9, 0 }), 4);

		BestTimeBuySellStock().MaxProfit_AtMostKTransactions_DP1D_2(std::vector<int>({ 15, 30, 24, 33, 11, 13, 17, 16, 21, 12, 30, 18 }), 5);
		BestTimeBuySellStock().MaxProfit_AtMostKTransactions_DP1D_2(std::vector<int>({ 2, 0, 2, 3 }), 1);
		BestTimeBuySellStock().MaxProfit_AtMostKTransactions_DP1D_2(std::vector<int>({ 1, 2, 3, 1 }), 1);
		BestTimeBuySellStock().MaxProfit_AtMostKTransactions_DP1D_2(std::vector<int>({ 1, 2, 4, 2, 5, 7, 2, 4, 9, 0 }), 4);

		BestTimeBuySellStock().MaxProfit_Cooldown1DayAfterSell(std::vector<int>({ 1,2,3,0,2 }));

        BestTimeBuySellStock2().MaxProfit_OneTransaction(std::vector<int>({ 15, 30, 24, 33, 11, 13, 17, 16, 21, 12, 24, 18 }));
        BestTimeBuySellStock2().MaxProfit_UnlimitedTransactions(std::vector<int>({ 15, 30, 24, 33, 11, 13, 17, 16, 21, 12, 24, 18 }));
        BestTimeBuySellStock2().MaxProfit_AtMost2Transactions(std::vector<int>({ 15, 30, 24, 33, 11, 13, 17, 16, 21, 12, 24, 18 }));
        BestTimeBuySellStock2().MaxProfit_AtMostKTransactions(std::vector<int>({ 15, 30, 24, 33, 11, 13, 17, 16, 21, 12, 24, 18 }), 5);
        BestTimeBuySellStock2().MaxProfit_Cooldown1DayAfterSell(std::vector<int>({ 15, 30, 24, 33, 11, 13, 17, 16, 21, 12, 24, 18 }));
        BestTimeBuySellStock2().MaxProfit_UnlimitedTransactionsWithTransactionFee(std::vector<int>({ 15, 30, 24, 33, 11, 13, 17, 16, 21, 12, 24, 18 }), 10);
	}
	{
		FrequencyOfIdxSeqArray().Transform(std::vector<int>({ 1, 3, 5, 7, 9, 1, 3, 5, 7, 9, 1 }));
		FrequencyOfIdxSeqArray().Transform(std::vector<int>({ 11, 11, 9, 10, 7, 10, 3, 5, 7, 9, 1 }));
	}
	{
		SnakestringStr().Convert(std::string("Hello World!"));
	}
	{
		MinAndMaxInArrayWMinComp().Iterate(std::vector<int>({ 41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 }));
	}
	{
		SalaryThresholdForSmallerBudget().Solve(std::vector<double>({ 90.0, 30.0, 100.0, 40.0, 20.0 }), 210.0);
	}
	{
		for (int i = 0; i < 2; ++i)
		{
			std::vector<double> v = TestCase::RandVec<double>(20, 0.0, 0.99);
			HouseMajority().ProbOfRepublicanMajority_Recur(v);
			HouseMajority().Simplified_Recur(v);
		}
	}
	{
		MinWaitingTime().Schedule(TestCase::RandVec<int>(20, 0, 99));
	}
	{
		for (int i = 0; i < 3; ++i)
        {
            MissingRangesInSortedArray().Solve(TestCase::RandSortedVec(10, 1, 99), TestCase::RandNum(-50, 50), TestCase::RandNum(50, 150));
            MissingRangesInSortedArray().Simplified(TestCase::RandSortedVec(10, 1, 99), TestCase::RandNum(-50, 50), TestCase::RandNum(50, 150));
        }
		SummaryRangesInSortedArray().Solve(TestCase::RandSortedVec(10, 1, 13));
        SummaryRangesInSortedArray().Better(TestCase::RandSortedVec(10, 1, 13));
	}
	{
		FirstMissingPositive().Find(&std::vector<int>({ 17, 16, -2, 5, 1, 4, 2, -1, 18, 0 })[0], 10);
	}
	{
		LargestRectHistogram().BruteForce(std::vector<int>({ 1, 3, 4, 7, 6, 9, 5, 2 }));
		LargestRectHistogram().SortedStack(std::vector<int>({ 1, 3, 4, 7, 6, 9, 5, 2 }));
		LargestRectHistogram().SortedStack2(std::vector<int>({ 1, 3, 4, 7, 6, 9, 5, 2 }));
	}
	{
		ContainerWMostWater().BruteForce(std::vector<int>({ 1, 3, 4, 7, 6, 9, 5, 2 }));
		ContainerWMostWater().Greedy(std::vector<int>({ 1, 3, 4, 7, 6, 9, 5, 2 }));
		ContainerWMostWater().Greedy2(std::vector<int>({ 1, 3, 4, 7, 6, 9, 5, 2 }));

		ContainerWMostWater().BruteForce(std::vector<int>({ 1, 2, 1, 3, 4, 4, 5, 6, 2, 1, 3, 1, 3, 2, 1, 2, 4, 1 }));
		ContainerWMostWater().Greedy(std::vector<int>({ 1, 2, 1, 3, 4, 4, 5, 6, 2, 1, 3, 1, 3, 2, 1, 2, 4, 1 }));
		ContainerWMostWater().Greedy2(std::vector<int>({ 1, 2, 1, 3, 4, 4, 5, 6, 2, 1, 3, 1, 3, 2, 1, 2, 4, 1 }));
	}
	{
		TrappingRainWater().LinearSpace(&std::vector<int>({ 6, 1, 7, 3, 4, 9, 2, 5 })[0], 8);
		TrappingRainWater().ConstSpace(&std::vector<int>({ 6, 1, 7, 3, 4, 9, 2, 5 })[0], 8);
		TrappingRainWater().StackLinearSpace(std::vector<int>({ 6, 1, 7, 3, 4, 9, 2, 5 }));
		TrappingRainWater().StartFrom2EndsConstSpace(std::vector<int>({ 6, 1, 7, 3, 4, 9, 2, 5 }));
		TrappingRainWater().FindMaxVolPair_BruteForce(std::vector<int>({ 6, 1, 7, 3, 4, 9, 2, 5 }));

		TrappingRainWater().ConstSpace(&std::vector<int>({ 1, 2, 1, 3, 4, 4, 5, 1, 2, 0, 3 })[0], 11);
		TrappingRainWater().FindMaxVolPair_BruteForce(std::vector<int>({ 1, 2, 1, 3, 4, 4, 5, 1, 2, 0, 3 }));

		TrappingRainWater().ConstSpace(&std::vector<int>({ 1, 2, 1, 3, 4, 4, 5, 6, 2, 1, 3, 1, 3, 2, 1, 2, 4, 1 })[0], 18);
		TrappingRainWater().FindMaxVolPair_BruteForce(std::vector<int>({ 1, 2, 1, 3, 4, 4, 5, 6, 2, 1, 3, 1, 3, 2, 1, 2, 4, 1 }));

		TrappingRainWater().TwoD_BFS_MinHeap(std::vector<std::vector<int>>(
		{
			{ 1,4,3,1,3,2 },
			{ 3,2,1,3,2,4 },
			{ 2,3,3,2,3,1 }
		}));
	}
	{
		DrawSkylineOfBuildings().UseBST(std::vector<std::vector<int>>(
		{
			{ 2, 9, 10 },
			{ 3, 7, 15 },
			{ 5, 12, 12 },
			{ 15, 20, 10 },
			{ 19, 24, 8 },
		}));
		//DrawSkylineOfBuildings().Recur(std::vector<std::pair<std::pair<int, int>, int>>(
		//{
		//	{ { 2, 9 }, 10 },{ { 3, 7 }, 15 },{ { 5, 12 }, 12 },{ { 15, 20 }, 10 },{ { 19, 24 }, 8 }
		//}));

		DrawSkylineOfBuildings().UseBST(std::vector<std::vector<int>>(
		{
			{ 0, 5, 2 },
			{ 3, 7, 1 },
			{ 10, 14, 3 },
			{ 12, 16, 2 },
		}));
		//DrawSkylineOfBuildings().Recur(std::vector<std::pair<std::pair<int, int>, int>>(
		//{
		//	{ { 0, 5 }, 2 },{ { 3, 7 }, 1 },{ { 10, 14 }, 3 },{ { 12, 16 }, 2 }
		//}));

		DrawSkylineOfBuildings().UseBST(std::vector<std::vector<int>>(
		{
			{ 11, 17, 1 },
			{ 13, 16, 2 },
			{ 10, 12, 5 },
			{ 5, 9, 2 },
			{ 0, 3, 1 },
			{ 4, 8, 4 },
			{ 7, 14, 3 },
			{ 1, 6, 3 },
		}));
		DrawSkylineOfBuildings().Recur(std::vector<std::pair<std::pair<int, int>, int>>(
		{
			{ { 11, 17 }, 1 }, { { 13, 16 }, 2 }, { { 10, 12 }, 5 }, { { 5, 9 }, 2 }, { { 0, 3 }, 1 }, { { 4, 8 }, 4 }, { { 7, 14 }, 3 }, { { 1, 6 }, 3 }
		}));
	}
	{
		BuildingsViewSunset().BruteForce(std::vector<int>({ 8, 17, 3, 7, 14, 13, 15, 9, 12, 5, 2 }));
		BuildingsViewSunset().SortedStack(std::vector<int>({ 8, 17, 3, 7, 14, 13, 15, 9, 12, 5, 2 }));
	}
	{
		ThreeSum().FindAll_SortGreedy(std::vector<int>({ -1,0,1,2,-1,-4 }), 0);
        ThreeSum().FindAll_WithoutSort(std::vector<int>({ -1,0,1,2,-1,-4 }), 0);
        ThreeSum().FindAllAllowRepeatOnce(std::vector<int>({ -1,0,1,2,-1,-4 }), 0);
        ThreeSum().FindAllAllowRepeatTwice(std::vector<int>({ -1,0,1,2,-1,-4 }), 0);

        ThreeSum().FindAllAllowRepeatOnce(std::vector<int>({1}), 3);
        ThreeSum().FindAllAllowRepeatTwice(std::vector<int>({1}), 3);
        ThreeSum().FindAllAllowRepeatOnce(std::vector<int>({1,1}), 3);
        ThreeSum().FindAllAllowRepeatTwice(std::vector<int>({1,1}), 3);
        ThreeSum().FindAllAllowRepeatOnce(std::vector<int>({1,1,1}), 3);
        ThreeSum().FindAllAllowRepeatTwice(std::vector<int>({1,1,1}), 3);
        ThreeSum().FindAllAllowRepeatOnce(std::vector<int>({1,1,1,1}), 3);
        ThreeSum().FindAllAllowRepeatTwice(std::vector<int>({1,1,1,1}), 3);


        for (int i = 0; i < 10; ++i)
        {
            std::vector<int> v = TestCase::RandVec(7, 0, 8);
            int n = TestCase::RandNum(0,20);
            ThreeSum().FindAllAllowRepeatOnce(std::vector<int>(v), n);
            ThreeSum().FindAllAllowRepeatTwice(std::vector<int>(v), n);
        }

	}
	{
		int threeSumClosest[] = { -3, -2, -5, 3, -4 };
		ThreeSumClosest().Sort_Greedy(std::vector<int>(threeSumClosest, threeSumClosest + sizeof(threeSumClosest) / sizeof(int)), -1);

		ThreeSumSmaller().Sort_Greedy(std::vector<int>({ -2,0,1,3 }), 2);
	}
    {
        ThreeSumWithMultiplicity().UseSort(std::vector<int>({1,1,2,2,3,3,4,4,5,5}),8);
        ThreeSumWithMultiplicity().DP(std::vector<int>({1,1,2,2,3,3,4,4,5,5}),8);
        ThreeSumWithMultiplicity().UseHashMap(std::vector<int>({1,1,2,2,3,3,4,4,5,5}),8);
    }
	{
		int fourSum[] = { 1, 0, -1, 0, -2, 2 };
		FourSum().FindAll_Sort_Greedy(std::vector<int>(fourSum, fourSum + sizeof(fourSum) / sizeof(int)), 0);

		FourSum().CountSumTo0_HashMap(std::vector<int>({ 1,2 }), std::vector<int>({ -2,-1 }), std::vector<int>({ -1,2 }), std::vector<int>({ 0,2 }));
		FourSum().CountSumTo0_2SortedArraysGreedy(std::vector<int>({ 1,2 }), std::vector<int>({ -2,-1 }), std::vector<int>({ -1,2 }), std::vector<int>({ 0,2 }));
	}
	{
		int twoSumVec[] = { 3, -6, -4, 2, -7, 9, 4, 1, 2 };
		TwoSum().ExistPairSumTo0_Sort_Greedy(std::vector<int>(twoSumVec, twoSumVec + sizeof(twoSumVec) / sizeof(int)));
		TwoSum().FindPairIndex_BruteForce(std::vector<int>({ 6, 4, -3, 0, 3, 7 }), 7);
		TwoSum().FindPairIndex_HashTable(std::vector<int>({ 6, 4, -3, 0, 3, 7 }), 7);
		TwoSum().FindPairIndex_HashTable2(std::vector<int>({ 6, 4, -3, 0, 3, 7 }), 7);
		TwoSum().FindPairIndex_Sort_Greedy(std::vector<int>({ 6, 4, -3, 0, 3, 7 }), 7);

		TwoSumIII tsiii;
		tsiii.Add(TestCase::RandVec(10, 1, 10));
		tsiii.Print();
		tsiii.Find(TestCase::RandNum(1, 20));
		tsiii.Find(TestCase::RandNum(1, 20));

        CountPairWSumEqualK().HashMap(std::vector<int>({1,1,1}), 2);

        CountPairWSumDivisibleByK().HashMap(std::vector<int>({30,20,150,100,40}));

        TwoSum_().FindAllUniquePairs(std::vector<int>({0,0,1,1,1,2,2,3}), 2);
        TwoSum_().FindAllUniquePairs_NoSort(std::vector<int>({0,0,1,1,1,2,2,3}), 2);
        TwoSum_().FindAllIndexPairs(std::vector<int>({0,0,1,1,1,2,2,3}), 2);

        TwoPairsSum().BruteForce(std::vector<int>({1,1,1,1,1}));
        TwoPairsSum().FindAllIndexTwoPairs(std::vector<int>({1,1,1,1,1}));
	}
	{
		TwoSumAbsSortedArray().FindPairIndex_Greedy(std::vector<int>({ -49, 75, 103, -147, 164, -197, -238, 314, 348, -422 }), 167);
	}
	{
		MaxProductOf3().OneScan(&std::vector<int>({ -6, -1, 2, -5, -4, -3, 7, 3, 1, 2 })[0], 10);
		MaxProductOf3().OneScan(&std::vector<int>({ -6, -1, -2, -5, -4, -3, -7, -10, -8, -9 })[0], 10);
		MaxProductOf3().Sort(&std::vector<int>({ -6, -1, 2, -5, -4, -3, 7, 3, 1, 2 })[0], 10);
		MaxProductOf3().Sort(&std::vector<int>({ -6, -1, -2, -5, -4, -3, -7, -10, -8, -9 })[0], 10);

        //for (int i = 0; i < 30; ++i)
        MaxProductOfK().SortGreedy(TestCase::RandVec(8, -9, 9), TestCase::RandNum(1, 7));
	}
	{
		for (int i = 0; i < 4; ++i)
		{
			std::vector<int> v = TestCase::RandUniqueVec(35, 1, 60);
			int k = TestCase::RandNum(7, 23);
			TwoDifference().Sort_Greedy(v, k);
			TwoDifference().Sort_BinarySearch(v, k);
			TwoDifference().HashTable(v, k);
		}
	}
	{
		ZigZagConversion().Convert(std::string("abcdefghijklmnopqrstu"), 5);
	}
	{
		std::vector<int> v1({ 1,2 });
		std::vector<int> v2({ 3,4,5,6 });
		ZigzagIterator itr(v1, v2);
		while(itr.hasNext())
			itr.next();
	}
	{
		AltPosNegNumArray().Stable(std::vector<int>({ -1, 2, -3, 4, 5, 6, -7, -8, 9, 10, 11, 12 }));
		AltPosNegNumArray().StablePartition_ModifiedMergeSort(std::vector<int>({ -1, 2, -3, 4, 5, 6, -7, -8, 9, 10, 11, 12 }));
		AltPosNegNumArray().UnStablePartition(std::vector<int>({ -1, 2, -3, 4, 5, 6, -7, -8, 9, 10, 11, 12 }));

		AltPosNegNumArray().Stable(std::vector<int>({ -1, 2, -3, 4, -5, -6, -7, -8, -9, -10, 11, -12 }));
		AltPosNegNumArray().StablePartition_ModifiedMergeSort(std::vector<int>({ -1, 2, -3, 4, -5, -6, -7, -8, -9, -10, 11, -12 }));
		AltPosNegNumArray().UnStablePartition(std::vector<int>({ -1, 2, -3, 4, -5, -6, -7, -8, -9, -10, 11, -12 }));

		AltPosNegNumArray().Stable(std::vector<int>({ 1, 7, -5, 9, -12, 15, 16, 17, 18, 19, 20, -8 }));
		AltPosNegNumArray().StablePartition_ModifiedMergeSort(std::vector<int>({ 1, 7, -5, 9, -12, 15, 16, 17, 18, 19, 20, -8 }));
		AltPosNegNumArray().UnStablePartition(std::vector<int>({ 1, 7, -5, 9, -12, 15, 16, 17, 18, 19, 20, -8 }));

		AltPosNegNumArray().Stable(std::vector<int>({ -1, 2, -3, 4, 5, 6, -7, 8, 9 }));
		AltPosNegNumArray().StablePartition_ModifiedMergeSort(std::vector<int>({ -1, 2, -3, 4, 5, 6, -7, 8, 9 }));
		AltPosNegNumArray().UnStablePartition(std::vector<int>({ -1, 2, -3, 4, 5, 6, -7, 8, 9 }));
	}
	{
		MissingBitIntegerInIdxSeqArray().FindIterate(std::vector<int>({ 0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 }));
		MissingBitIntegerInIdxSeqArray().FindIterate(std::vector<int>({ 4, 3, 6, 9, 1, 8, 10, 2, 5, 0 }));
		MissingBitIntegerInIdxSeqArray().FindIterate(std::vector<int>({ 1, 2, 3, 4, 5, 6, 8, 9, 10, 0 }));
		MissingBitIntegerInIdxSeqArray().FindRecur(std::vector<int>({ 0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 }));
		MissingBitIntegerInIdxSeqArray().FindRecur(std::vector<int>({ 4, 3, 6, 9, 1, 8, 10, 2, 5, 0 }));
		MissingBitIntegerInIdxSeqArray().FindRecur(std::vector<int>({ 1, 2, 3, 4, 5, 6, 8, 9, 10, 0 }));
		MissingBitIntegerInIdxSeqArray().UseXOR(std::vector<int>({ 0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 }));
		MissingBitIntegerInIdxSeqArray().UseXOR(std::vector<int>({ 4, 3, 6, 9, 1, 8, 10, 2, 5, 0 }));
		MissingBitIntegerInIdxSeqArray().UseXOR(std::vector<int>({ 1, 2, 3, 4, 5, 6, 8, 9, 10, 0 }));

		for (int i = 0; i < 10; ++i)
		{
			std::vector<int> v = TestCase::RandUniqueVec(20, 0, 20);
			MissingBitIntegerInIdxSeqArray().FindIterate(v);
			MissingBitIntegerInIdxSeqArray().FindRecur(v);
			MissingBitIntegerInIdxSeqArray().UseXOR(v);
		}

        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({0}));//missing num in [0:1]
        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({1}));//missing num in [0:1]
        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({0,1}));//missing num in [0:2]
        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({1,2}));//missing num in [0:2]
        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({0,2}));//missing num in [0:2]
        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({0,1,2}));//missing num in [0:3]
        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({0,1,3}));//missing num in [0:3]
        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({0,2,3}));//missing num in [0:3]
        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({1,2,3}));//missing num in [0:3]

        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({0}));//missing num in [0:1]
        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({1}));//missing num in [0:1]
        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({0,1}));//missing num in [0:2]
        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({1,2}));//missing num in [0:2]
        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({0,2}));//missing num in [0:2]
        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({0,1,2}));//missing num in [0:3]
        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({0,1,3}));//missing num in [0:3]
        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({0,2,3}));//missing num in [0:3]
        MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(std::vector<int>({1,2,3}));//missing num in [0:3]

        for (int i = 0; i < 10; ++i)
        {
            std::vector<int> v= TestCase::RandUniqueSortedVec(20, 0, 20);
            MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchRecur(v);
            MissingBitIntegerInIdxSeqArray().SortedArrayBinarySearchIterate(v);
        }
	}
	{
		ContainsDuplicate().Solve(TestCase::RandVec<int>(25, 0, 99), TestCase::RandNum<int>(5, 15), TestCase::RandNum<int>(10, 80));
	}
	{
		FlipGame().NextState(std::string("+++"));
		FlipGame().NextState(std::string("++++"));
		FlipGame().NextState(std::string("+++++"));
		FlipGame().NextState(std::string("+++--++++"));
		FlipGame().NextState(std::string("+++++++++"));

		FlipGame().CanWin(std::string("+++"));
		FlipGame().CanWin(std::string("++++"));
		FlipGame().CanWin(std::string("+++++"));
		FlipGame().CanWin(std::string("+++--++++"));
		FlipGame().CanWin(std::string("+++++++++"));

		FlipGame().CanWinHashTable(std::string("+++"));
		FlipGame().CanWinHashTable(std::string("++++"));
		FlipGame().CanWinHashTable(std::string("+++++"));
		FlipGame().CanWinHashTable(std::string("+++--++++"));
		FlipGame().CanWinHashTable(std::string("+++++++++"));
	}
	{
		ReverseVowelsOfString().reverseVowels(std::string("hello"));
		ReverseVowelsOfString().reverseVowels(std::string("leetcode"));
	}
	{
		ValidateCapitalString().Iterate(std::string("FACEBOOk"));
		ValidateCapitalString().Iterate(std::string("FaceBook"));
		ValidateCapitalString().Iterate(std::string("fAcebook"));
		ValidateCapitalString().Iterate(std::string("faceBook"));
	}
	{
		FrogJump().DP(std::vector<int>({ 0,1,3,5,6,8,12,17 }));
		FrogJump().Recur(std::vector<int>({ 0,1,3,5,6,8,12,17 }));
		FrogJump().DP(std::vector<int>({ 0,1,2,3,4,8,9,11 }));
		FrogJump().Recur(std::vector<int>({ 0,1,2,3,4,8,9,11 }));
	}
	{
		PickNumberAddToSumGame().Recur(10, 11);
		PickNumberAddToSumGame().RecurDP(10, 11);
	}
	{
		SuperWashingMachines().FindMinMoves(std::vector<int>({ 1,1,6,6,1 }));
		SuperWashingMachines().FindMinMoves(std::vector<int>({ 1,1,4,8,1 }));
	}
	{
		MinMovesToEqualArrayElements().MinMovesI_IncrNminus1Nums(std::vector<int>({ 1,2,3 }));
		MinMovesToEqualArrayElements().MinMovesII_IncrDecr1Num_UseMedian(std::vector<int>({ 1,2,3 }));
		MinMovesToEqualArrayElements().MinMovesII_IncrDecr1Num_UseSort(std::vector<int>({ 1,2,3 }));
	}
	{
		CircularArrayLoop().HasLoop(std::vector<int>({ 2, -1, 1, 2, 2 }));
		CircularArrayLoop().HasLoop(std::vector<int>({ -1, 2 }));
	}
	{
		ReconstructOriginalDigitsFromEnglish().HashMap(std::string("owoztneoer"));
		ReconstructOriginalDigitsFromEnglish().HashMap(std::string("fviefuro"));
	}
	{
		MoveZerosToEndOfArray().InPlace(std::vector<int>({ 1, 2, 0, 4, 3, 0, 5, 0 }));
		MoveZerosToEndOfArray().InPlace(std::vector<int>({ 1, 2, 0, 0, 0, 3, 6 }));
		MoveZerosToEndOfArray().InPlace(std::vector<int>({ 0, 9, 0, 4, 0, 0, 2, 7, 0, 6, 0 }));
		MoveZerosToEndOfArray().InPlace(std::vector<int>({ 0, 9, 0, 0, 0, 0, 0, 7, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1 }));

		RemoveSomeElementFromArray().InPlace(std::vector<int>({ 1, 2, 0, 4, 3, 0, 5, 0 }), 0);
		RemoveSomeElementFromArray().InPlace(std::vector<int>({ 1, 2, 0, 0, 0, 3, 6 }), 0);
		RemoveSomeElementFromArray().InPlace(std::vector<int>({ 0, 9, 0, 4, 0, 0, 2, 7, 0, 6, 0 }), 0);
		RemoveSomeElementFromArray().InPlace(std::vector<int>({ 0, 9, 0, 0, 0, 0, 0, 7, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1 }), 0);
	}
    {
        SwapAdjacentInLRString().CanTransform(std::string("RXXLRXRXL"), std::string("XRLXXRRLX"));
    }
    {
        AsteroidCollision().UseStack(std::vector<int>({1,2,8,-8,-2,-6}));
    }
    {
        MoveEvenNumsToFrontInArray().UnStable(std::vector<int>({3,1,2,4}));
    }
    {
        NumOfFriendRequests().Test(std::vector<int>({20,30,100,110,120}));
    }
    {
        AltEvenOddNumArray().TwoPointers(std::vector<int>({4,2,5,7}));
    }
    {
        FindNRepeatedNumInSize2NArray().Test(std::vector<int>({5,1,5,2,5,3,5,4}));
    }
    {
        PushDomino1DArray().Solve(std::string(".L.R...LR..L.."));
    }
    {
        PrisonCell1DArrayAfterNDays().Solve(std::vector<int>({0,1,0,1,1,0,0,1}), 7);
    }
    {
        MinSwapToPairCouplesInArray().UnionFind(std::vector<int>({0, 2, 1, 3}));
    }
    {
        MinRoundTripTicketFrom2Arr().ThreeScans(std::vector<int>({5,3,2,4,6,7,1}), std::vector<int>({4,3,5,7,6,2,6}));
    }
    {
        FindPairWithMaxAppeal().TwoPtrs(std::vector<int>({1, 3, -1}));
        FindPairWithMaxAppeal().TwoPtrs(std::vector<int>({1, 6, 1, 1, 1, 1, 7}));
        FindPairWithMaxAppeal().TwoPtrs(std::vector<int>({6, 2, 7, 4, 4, 1, 6}));
        FindPairWithMaxAppeal().TwoPtrs(std::vector<int>({3,3,1,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2}));
        FindPairWithMaxAppeal().TwoPtrs(std::vector<int>({3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 1}));

        FindPairWithMaxAbsDiffFrom2Arr().Solve(std::vector<int>({1,-2,-5,0,10}), std::vector<int>({0,-2,-1,-7,-4}));
    }
    {
        TwoSumLessEqualClosestK().Sort(std::vector<int>({34,23,1,24,75,33,54,8}), 60);

        TwoSumLessEqualClosestKFrom2Arr().FindAll(10000, {{1,3000},{2,5000},{3,7000},{4,10000}}, {{1,2000},{2,3000},{3,4000},{4,5000}});
        TwoSumLessEqualClosestKFrom2Arr().FindAll(7000, {{1,2000},{2,4000},{3,6000}}, {{1,2000}});
    }
    {
        MinDiceFlipToAllSameFaces().Naive(std::vector<int>({1, 1, 6}));
        MinDiceFlipToAllSameFaces().Better(std::vector<int>({1, 1, 6}));
        MinDiceFlipToAllSameFaces().Naive(std::vector<int>({1, 6, 2, 3}));
        MinDiceFlipToAllSameFaces().Better(std::vector<int>({1, 6, 2, 3}));
    }
    {
        MinNumRefuelingStops().MaxHeap(100, 10, std::vector<std::vector<int>>({{10,60},{20,30},{30,30},{60,40}}));
        MinNumRefuelingStops().DP(100, 10, std::vector<std::vector<int>>({{10,60},{20,30},{30,30},{60,40}}));
    }
    {
        RepeatRemoveAdjDuplicatesInString().UseStack("abbaca");
        RepeatRemoveAdjDuplicatesInString().UseStack("deeedbbcccbdaa", 3);

        ValidateRepeatRemoveSubstrABC().UseStack("abcabcababcc");
    }
    {
        RepeatReverseSubstrsInParentheses().UseStack("(u(love)i)");
    }
    {
        NumOfEquivalentDominoPairs().Solve(std::vector<std::vector<int>>({{1,2},{1,2},{1,2}}));
    }

#endif
#ifdef _SortSearchSelect_
	/*Sort Search Select*/
	RdCout ? redirect_cout::to_file("Out_SortSearchSelect.txt") : redirect_cout::to_cout();
	PrintH("Sort Search Select");
	{
		std::vector<int> v1({ 41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 });
		std::string v1Before = Debug::ToStr1D<int>()(v1);
		int pivot1 = Partition().SmallerThanPivot(&v1[0], 0, v1.size() - 1, 1);//pivotVal = 67
		std::string v1After = Debug::ToStr1D<int>()(v1);
		std::cout << "Partition Pivot: " << 1 << ", \"" << v1Before << "\" => \"" << v1After << "\". pivot: " << pivot1 << std::endl;

		std::vector<int> v2({ 41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 });
		std::string v2Before = Debug::ToStr1D<int>()(v2);
		int pivot2 = Partition().SmallerThanPivot2(&v2[0], 0, v2.size() - 1, 1);//pivotVal = 67
		std::string v2After = Debug::ToStr1D<int>()(v2);
		std::cout << "Partition Pivot2: " << 1 << ", \"" << v2Before << "\" => \"" << v2After << "\". pivot: " << pivot2 << std::endl;

		std::vector<int> v3({ 41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 });
		std::string v3Before = Debug::ToStr1D<int>()(v3);
		int pivot3 = Partition().SmallerThanPivotVal(&v3[0], 0, v3.size() - 1, 68);//pivotVal = 68
		std::string v3After = Debug::ToStr1D<int>()(v3);
		std::cout << "Partition PivotVal: " << 68 << ", \"" << v3Before << "\" => \"" << v3After << "\". pivot: " << pivot3 << std::endl;

		std::vector<int> v4({ 41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 });
		std::string v4Before = Debug::ToStr1D<int>()(v4);
		int pivot4 = Partition().SmallerThanPivotVal2(&v4[0], 0, v4.size() - 1, 68);//pivotVal = 68
		std::string v4After = Debug::ToStr1D<int>()(v4);
		std::cout << "Partition PivotVal2: " << 68 << ", \"" << v4Before << "\" => \"" << v4After << "\". pivot: " << pivot4 << std::endl;

		std::vector<int> v5({ 41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 });
		std::string v5Before = Debug::ToStr1D<int>()(v5);
		std::pair<int, int> p5 = Partition().ThreeWay_SmallerThan2PivotVals(&v5[0], 0, v5.size() - 1, 35, 68);//pivotVal = 35, 68
		std::string v5After = Debug::ToStr1D<int>()(v5);
		std::cout << "ThreeWayPartition 2PivotVals: " << 35 << ", " << 68 << ", \"" << v5Before << "\" => \"" << v5After << "\". pivots: " << p5.first << ", " << p5.second << std::endl;

		std::vector<int> v6({ 41, 67, 34, 67, 69, 24, 78, 58, 73, 67, 5, 45, 81, 27, 67 });
		std::string v6Before = Debug::ToStr1D<int>()(v6);
		std::pair<int, int> p6 = Partition().ThreeWay_SmallerEqualGreaterThanPivot(&v6[0], 0, v6.size() - 1, 1);//pivotVal = 67
		std::string v6After = Debug::ToStr1D<int>()(v6);
		std::cout << "ThreeWayPartition Pivot: " << 67 << ", \"" << v6Before << "\" => \"" << v6After << "\". pivots: " << p6.first << ", " << p6.second << std::endl;

		std::vector<int> v7 = TestCase::RandVec<int>(15, 1, 99);
		std::string v7Before = Debug::ToStr1D<int>()(v7);
		std::vector<int> p7 = Partition().FourWay_SmallerThan3PivotVals(&v7[0], 0, v7.size() - 1, 25, 50, 75);//pivotVal = 25, 50, 75
		std::string v7After = Debug::ToStr1D<int>()(v7);
		std::cout << "FourWayPartition 3PivotVals: " << 25 << ", " << 50 << ", " << 75 << ", \"" << v7Before << "\" => \"" << v7After << "\". pivots: " << Debug::ToStr1D<int>()(p7) << std::endl;
	}
	{
		//												   0  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16
		BinarySearch().Index_UpperBound(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 78);
		BinarySearch().Index_UpperBound2(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 78);
		BinarySearch().Index_UpperBound3(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 78);
		BinarySearch().Index_LowerBound(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 78);
		BinarySearch().Index_LowerBound2(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 78);
		BinarySearch().Index_LowerBound3(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 78);
		BinarySearch().Index_UpperBound(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 81);
		BinarySearch().Index_UpperBound2(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 81);
		BinarySearch().Index_UpperBound3(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 81);
		BinarySearch().Index_LowerBound(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 81);
		BinarySearch().Index_LowerBound2(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 81);
		BinarySearch().Index_LowerBound3(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 81);
		BinarySearch().Index_UpperBound(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 3);
		BinarySearch().Index_UpperBound2(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 3);
		BinarySearch().Index_UpperBound3(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 3);
		BinarySearch().Index_LowerBound(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 3);
		BinarySearch().Index_LowerBound2(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 3);
		BinarySearch().Index_LowerBound3(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 3);
		BinarySearch().Index_UpperBound(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 80);
		BinarySearch().Index_UpperBound2(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 80);
		BinarySearch().Index_UpperBound3(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 80);
		BinarySearch().Index_LowerBound(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 80);
		BinarySearch().Index_LowerBound2(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 80);
		BinarySearch().Index_LowerBound3(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 80);
		BinarySearch().Index_UpperBound(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 4);
		BinarySearch().Index_UpperBound2(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 4);
		BinarySearch().Index_UpperBound3(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 4);
		BinarySearch().Index_LowerBound(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 4);
		BinarySearch().Index_LowerBound2(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 4);
		BinarySearch().Index_LowerBound3(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 4);
		BinarySearch().Index_UpperBound(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 37);
		BinarySearch().Index_UpperBound2(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 37);
		BinarySearch().Index_UpperBound3(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 37);
		BinarySearch().Index_LowerBound(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 37);
		BinarySearch().Index_LowerBound2(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 37);
		BinarySearch().Index_LowerBound3(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 37);

		BinarySearch().Index_UpperBound(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 1);
		BinarySearch().Index_UpperBound2(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 1);
		BinarySearch().Index_UpperBound3(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 1);
		BinarySearch().Index_LowerBound(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 1);
		BinarySearch().Index_LowerBound2(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 1);
		BinarySearch().Index_LowerBound3(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 1);
		BinarySearch().Index_UpperBound(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 88);
		BinarySearch().Index_UpperBound2(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 88);
		BinarySearch().Index_UpperBound3(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 88);
		BinarySearch().Index_LowerBound(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 88);
		BinarySearch().Index_LowerBound2(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 88);
		BinarySearch().Index_LowerBound3(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 88);

		BinarySearch().Index_UpperBound(std::vector<int>({ 3, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 78, 78, 78, 81 }), 67);
		BinarySearch().Index_UpperBound2(std::vector<int>({ 3, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 78, 78, 78, 81 }), 67);
		BinarySearch().Index_UpperBound3(std::vector<int>({ 3, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 78, 78, 78, 81 }), 67);
		BinarySearch().Index_LowerBound(std::vector<int>({ 3, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 78, 78, 78, 81 }), 67);
		BinarySearch().Index_LowerBound2(std::vector<int>({ 3, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 78, 78, 78, 81 }), 67);
		BinarySearch().Index_LowerBound3(std::vector<int>({ 3, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 78, 78, 78, 81 }), 67);
		BinarySearch().Index_UpperBound(std::vector<int>({ 3, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 78, 78, 78, 81 }), 78);
		BinarySearch().Index_UpperBound2(std::vector<int>({ 3, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 78, 78, 78, 81 }), 78);
		BinarySearch().Index_UpperBound3(std::vector<int>({ 3, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 78, 78, 78, 81 }), 78);
		BinarySearch().Index_LowerBound(std::vector<int>({ 3, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 78, 78, 78, 81 }), 78);
		BinarySearch().Index_LowerBound2(std::vector<int>({ 3, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 78, 78, 78, 81 }), 78);
		BinarySearch().Index_LowerBound3(std::vector<int>({ 3, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 78, 78, 78, 81 }), 78);

		BinarySearch().Index_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 78);
		BinarySearch().Index_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 81);
		BinarySearch().Index_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 3);
		BinarySearch().Index_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 80);
		BinarySearch().Index_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 4);
		BinarySearch().Index_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 37);

		BinarySearch().Index_UpperBound_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 78);
		BinarySearch().Index_UpperBound_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 81);
		BinarySearch().Index_UpperBound_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 3);
		BinarySearch().Index_UpperBound_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 80);
		BinarySearch().Index_UpperBound_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 4);
		BinarySearch().Index_UpperBound_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 37);
		BinarySearch().Index_LowerBound_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 78);
		BinarySearch().Index_LowerBound_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 81);
		BinarySearch().Index_LowerBound_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 3);
		BinarySearch().Index_LowerBound_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 80);
		BinarySearch().Index_LowerBound_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 4);
		BinarySearch().Index_LowerBound_Recur(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 37);
	}
	{
		BinarySearchFixedPoint().Solve_NoDup_Iterate(std::vector<int>({ -40, -20, -1, 1, 2, 3, 5, 7, 9, 12, 13 }));
		BinarySearchFixedPoint().Solve_NoDup_Iterate(std::vector<int>({ -10, -5, 2, 2, 2, 3, 4, 8, 9, 12, 13 }));
		BinarySearchFixedPoint().Solve_NoDup_Iterate(std::vector<int>({ -10, -5, 1, 2, 5, 6, 7, 8, 8, 8, 12 }));
		BinarySearchFixedPoint().Solve_AllowDup_Recur(std::vector<int>({ -40, -20, -1, 1, 2, 3, 5, 7, 9, 12, 13 }));
		BinarySearchFixedPoint().Solve_AllowDup_Recur(std::vector<int>({ -10, -5, 2, 2, 2, 3, 4, 8, 9, 12, 13 }));
		BinarySearchFixedPoint().Solve_AllowDup_Recur(std::vector<int>({ -10, -5, 1, 2, 5, 6, 7, 8, 8, 8, 12 }));

		for (int i = 0; i < 100; ++i)
			BinarySearchFixedPoint().Solve_NoDup_Iterate(TestCase::RandUniqueSortedVec(7, -3, 10));

		for (int i = 0; i < 100; ++i)
			BinarySearchFixedPoint().Solve_AllowDup_Recur(TestCase::RandSortedVec(7, 0, 7));
	}
	{
		QuickSort().GO_STL(std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 }));
		QuickSort().GO(&std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 })[0], 13);
		QuickSort().GO2(&std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 })[0], 13);
		QuickSort().GO_Iterate(&std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 })[0], 13);
		MergeSort().GO(&std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 })[0], 13);
		MergeSort().GO_STL(std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 }));
		BubbleSort().GO(&std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 })[0], 13);
		InsertionSort().GO(&std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 })[0], 13);
		InsertionSort().GO(std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 }));
		SelectionSort().GO(&std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 })[0], 13);
		SelectionSort().GO(std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 }));
		HeapSort().GO(std::vector<int>({ 41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 }));
		HeapSort().GO2(std::vector<int>({ 41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 }));
		HeapSort().GO3(std::vector<int>({ 41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 }));
		ShellSort().GO(&std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 })[0], 13);
		CountingSort().GO(&std::vector<int>({ 41, 67, 34, 3, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 })[0], 15, 3, 81);
		BucketSort().GO(&std::vector<int>({ 41, 67, 34, 3, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 })[0], 15, 3, 81);
		BucketSort().GO(&std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 })[0], 13, 1, 9);

		for (int i = 0; i < 10; ++i)
		{
			std::vector<int> v = TestCase::RandVec<int>(15, 0, 99);
			HeapSort().GO(std::vector<int>(v));
			HeapSort().GO2(std::vector<int>(v));
			HeapSort().GO3(std::vector<int>(v));
		}
	}
	{
		MaxGapOfSortedSuccessiveNum().UseBucketSort(std::vector<int>({ 41, 67, 34, 3, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 }));
		MaxGapOfSortedSuccessiveNum().UseBucketSort(std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 }));
		MaxGapOfSortedSuccessiveNum().UseBucketSort(std::vector<int>({ 15, 1, 9, 3, 19, 7, 0, 18, 4, 10, 8, 2, 6, 17, 16 }));
	}
	{
		MedianOfMedians().GetIndex_InPlaceRecur(&std::vector<int>(
		{
			40, 39, 38, 37, 36, 35, 34, 33, 32, 31,
			30, 29, 28, 27, 26, 25, 24, 23, 22, 21,
			20, 19, 18, 17, 16, 15, 14, 13, 12, 11,
			10, 9, 8, 7, 6, 5, 4, 3, 2, 1
		}
		)[0], 40);
		MedianOfMedians().GetValue_Recur(&std::vector<int>(
		{
			40, 39, 38, 37, 36, 35, 34, 33, 32, 31,
			30, 29, 28, 27, 26, 25, 24, 23, 22, 21,
			20, 19, 18, 17, 16, 15, 14, 13, 12, 11,
			10, 9, 8, 7, 6, 5, 4, 3, 2, 1
		}
		)[0], 40);
	}
	{
		MedianOfIntegerStream().MinMaxHeap(&std::vector<int>({ 10, 9, 8, 7, 6, 5, 4, 3, 2, 2, 1, -1, -2, -2 })[0], 14);
		std::istringstream iss("10 9 8 7 6 5 4 3 2 2 1 -1 -2 -2");
		MedianOfIntegerStream().MinMaxHeap_FromISS(iss);
	}
	{
		QuickSort().GO(&std::vector<int>(
		{ 3, 9, 8, 7, 6, -5, -5, 13, -2, -1, -7, -9, 5, 4, 4, 11, 2, 12, 1, 14, 20, 19, 17, 16, 18, -3, -4, -6, 21, 11, 13, 15, 16, 24 })[0], 34);
		KthSmallestElement().QuickSelectRecur(&std::vector<int>(
		{ 3, 9, 8, 7, 6, -5, -5, 13, -2, -1, -7, -9, 5, 4, 4, 11, 2, 12, 1, 14, 20, 19, 17, 16, 18, -3, -4, -6, 21, 11, 13, 15, 16, 24 })[0], 34, 18);
		KthSmallestElement().QuickSelectRecur(&std::vector<int>({ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 })[0], 11, 11);
		KthSmallestElement().QuickSelectRecur(&std::vector<int>({ 7 })[0], 1, 1);

		KthSmallestElement().QuickSelectIterate(&std::vector<int>(
		{ 3, 9, 8, 7, 6, -5, -5, 13, -2, -1, -7, -9, 5, 4, 4, 11, 2, 12, 1, 14, 20, 19, 17, 16, 18, -3, -4, -6, 21, 11, 13, 15, 16, 24 })[0], 34, 18);
		KthSmallestElement().QuickSelectIterate(&std::vector<int>({ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 })[0], 11, 11);
		KthSmallestElement().QuickSelectIterate(&std::vector<int>({ 7 })[0], 1, 1);

		KthSmallestElement().STL_Nth_Element(std::vector<int>(
		{ 3, 9, 8, 7, 6, -5, -5, 13, -2, -1, -7, -9, 5, 4, 4, 11, 2, 12, 1, 14, 20, 19, 17, 16, 18, -3, -4, -6, 21, 11, 13, 15, 16, 24 }), 18);
		KthSmallestElement().STL_Nth_Element(std::vector<int>({ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }), 11);
		KthSmallestElement().STL_Nth_Element(std::vector<int>({ 7 }), 1);

		KthSmallestElement().MedianOfMediansSelectRecur(&std::vector<int>(
		{ 3, 9, 8, 7, 6, -5, -5, 13, -2, -1, -7, -9, 5, 4, 4, 11, 2, 12, 1, 14, 20, 19, 17, 16, 18, -3, -4, -6, 21, 11, 13, 15, 16, 24 })[0], 34, 18);

		KthSmallestElement().MedianOfMediansSelectIterate(&std::vector<int>(
		{ 3, 9, 8, 7, 6, -5, -5, 13, -2, -1, -7, -9, 5, 4, 4, 11, 2, 12, 1, 14, 20, 19, 17, 16, 18, -3, -4, -6, 21, 11, 13, 15, 16, 24 })[0], 34, 18);

		KthSmallestElement2().GO_MedianOfMedians(&std::vector<int>(
		{ 3, 9, 8, 7, 6, -5, -5, 13, -2, -1, -7, -9, 5, 4, 4, 11, 2, 12, 1, 14, 20, 19, 17, 16, 18, -3, -4, -6, 21, 11, 13, 15, 16, 24 })[0], 34, 18);

		KthSmallestElement().QuickSelectRecur(&std::vector<int>(
		{
			40, 39, 38, 37, 36, 35, 34, 33, 32, 31,
			30, 29, 28, 27, 26, 25, 24, 23, 22, 21,
			20, 19, 18, 17, 16, 15, 14, 13, 12, 11,
			10, 9, 8, 7, 6, 5, 4, 3, 2, 1
		}
		)[0], 40, 37);
		KthSmallestElement().QuickSelectIterate(&std::vector<int>(
		{
			40, 39, 38, 37, 36, 35, 34, 33, 32, 31,
			30, 29, 28, 27, 26, 25, 24, 23, 22, 21,
			20, 19, 18, 17, 16, 15, 14, 13, 12, 11,
			10, 9, 8, 7, 6, 5, 4, 3, 2, 1
		}
		)[0], 40, 37);
		KthSmallestElement().MedianOfMediansSelectRecur(&std::vector<int>(
		{
			40, 39, 38, 37, 36, 35, 34, 33, 32, 31,
			30, 29, 28, 27, 26, 25, 24, 23, 22, 21,
			20, 19, 18, 17, 16, 15, 14, 13, 12, 11,
			10, 9, 8, 7, 6, 5, 4, 3, 2, 1
		}
		)[0], 40, 37);
		KthSmallestElement().MedianOfMediansSelectIterate(&std::vector<int>(
		{
			40, 39, 38, 37, 36, 35, 34, 33, 32, 31,
			30, 29, 28, 27, 26, 25, 24, 23, 22, 21,
			20, 19, 18, 17, 16, 15, 14, 13, 12, 11,
			10, 9, 8, 7, 6, 5, 4, 3, 2, 1
		}
		)[0], 40, 37);
		KthSmallestElement2().GO_MedianOfMedians(&std::vector<int>(
		{
			40, 39, 38, 37, 36, 35, 34, 33, 32, 31,
			30, 29, 28, 27, 26, 25, 24, 23, 22, 21,
			20, 19, 18, 17, 16, 15, 14, 13, 12, 11,
			10, 9, 8, 7, 6, 5, 4, 3, 2, 1
		}
		)[0], 40, 37);
	}
	{
		for (int i = 0; i < 5; ++i)
		{
			std::vector<int> v = TestCase::RandVec<int>(15, 1, 99);
			MedianElement().Iterate_NthElement(v);
			MedianElement().Iterate_QuickSelect(v);
			std::vector<int> v2 = TestCase::RandVec<int>(16, 1, 99);
			MedianElement().Iterate_NthElement(v2);
			MedianElement().Iterate_QuickSelect(v2);
		}
	}
	{
		Median2SortedArrays().Linear(std::vector<int>({ 1, 3, 5, 7, 9, 11 }), std::vector<int>({ 2, 4, 6, 8, 10, 12, 14, 16 }));
		Median2SortedArrays().Logarithmic(std::vector<int>({ 1, 3, 5, 7, 9, 11 }), std::vector<int>({ 2, 4, 6, 8, 10, 12, 14, 16 }));
		Median2SortedArrays().Linear(std::vector<int>({ -1 }), std::vector<int>({ -3, -2, 1, 3, 5, 6, 8, 8, 8, 10, 12 }));
		Median2SortedArrays().Logarithmic(std::vector<int>({ -1 }), std::vector<int>({ -3, -2, 1, 3, 5, 6, 8, 8, 8, 10, 12 }));
	}
	{
		KthSmallestElement2SortedArrays().Find_Recur(std::vector<int>({ 1, 3, 5, 7, 9, 11 }), std::vector<int>({ 2, 4, 6, 8, 10, 12, 14, 16 }), 12);
		KthSmallestElement2SortedArrays().Find_Iterate(std::vector<int>({ 1, 3, 5, 7, 9, 11 }), std::vector<int>({ 2, 4, 6, 8, 10, 12, 14, 16 }), 13);
		for (int i = 1; i <= 14; ++i)
		{
			//KthSmallestElement2SortedArrays().Find_Recur(std::vector<int>({ 1, 3, 5, 7, 9, 11 }), std::vector<int>({ 2, 4, 6, 8, 10, 12, 14, 16 }), i - 1);
			KthSmallestElement2SortedArrays().Find_Iterate(std::vector<int>({ 1, 3, 5, 7, 9, 11 }), std::vector<int>({ 2, 4, 6, 8, 10, 12, 14, 16 }), i);
		}
	}
	{
		Merge2SortedArrays().Solve_InPlace(std::vector<int>({ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23 }), std::vector<int>({ 2, 4, 6, 8, 10, 12, 14, 16 }));
		Merge2SortedArrays().Solve_InPlace2(std::vector<int>({ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23 }), std::vector<int>({ 2, 4, 6, 8, 10, 12, 14, 16 }));
		Merge2SortedArrays().Solve(std::vector<int>({ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23 }), std::vector<int>({ 2, 4, 6, 8, 10, 12, 14, 16 }));
		Merge2SortedArrays().Solve2(std::vector<int>({ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23 }), std::vector<int>({ 2, 4, 6, 8, 10, 12, 14, 16 }));
	}
	{
		for (int i = 0; i <= 7; ++i)
			SearchInRotatedSortedArray().Index_NoDup_Iterate(std::vector<int>({ 4, 5, 6, 7, 0, 1, 2 }), i);

		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 4, 5, 6, 7, 0, 1, 2 }), 1);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 1, 1, 5, 0, 0, 1, 1 }), 5);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 1, 1, 5, 0, 0, 1, 1 }), 1);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 1, 1, 5, 0, 0, 1, 1 }), 0);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 1, 1, 5, 1, 1, 1, 1 }), 1);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 1, 1, 5, 1, 1, 1, 1 }), 5);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 1, 1, 1, 1, 1, 1, 1 }), 1);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 78, 78, 78, 81, 3, 67 }), 3);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 78, 78, 78, 81, 3, 67 }), 67);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 78, 78, 78, 81, 3, 67 }), 78);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 78, 78, 78, 81, 3, 67 }), 79);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 67, 69, 78, 78, 78, 81, 3, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67 }), 3);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 67, 69, 78, 78, 78, 81, 3, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67 }), 67);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 67, 69, 78, 78, 78, 81, 3, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67 }), 78);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 67, 69, 78, 78, 78, 81, 3, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67 }), 79);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 62, 64, 67, 69, 78, 78, 78, 81, 3, 5, 24, 27, 34, 41, 45, 58, 61 }), 62);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 62, 64, 67, 69, 78, 78, 78, 81, 3, 5, 24, 27, 34, 41, 45, 58, 61 }), 61);
		SearchInRotatedSortedArray().Index_AllowDup_Iterate(std::vector<int>({ 62, 64, 67, 69, 78, 78, 78, 81, 3, 5, 24, 27, 34, 41, 45, 58, 61 }), 78);

		for (int i = 0; i < 10; ++i)
			SearchInRotatedSortedArray().Index_AllowDup_Iterate(TestCase::RandRotatedSortedVec<int>(15, 0, 2), TestCase::RandNum<int>(0, 3));

		SearchInRotatedSortedArray().Min_NoDup_Iterate(std::vector<int>({ 4, 5, 6, 7, 0, 1, 2 }));
		SearchInRotatedSortedArray().Min_AllowDup_Iterate(std::vector<int>({ 1, 1, 5, 0, 0, 0, 1 }));
		SearchInRotatedSortedArray().Min_AllowDup_Iterate(std::vector<int>({ 1, 1, 5, 1, 1, 1, 1 }));
		SearchInRotatedSortedArray().Min_AllowDup_Iterate(std::vector<int>({ 1, 1, 1, 1, 1, 1, 1 }));

		for (int i = 0; i < 10; ++i)
			SearchInRotatedSortedArray().Min_AllowDup_Iterate(TestCase::RandRotatedSortedVec<int>(15, 0, 2));
	}
	{
		RemoveDuplicatesFromSortedArray().AtMostOnce(std::vector<int>({ 1, 1, 1, 2, 3, 4, 4, 5, 5, 5, 6, 7, 7, 8, 9, 10, 10, 10, 11, 12, 12 }));
		RemoveDuplicatesFromSortedArray().AtMostTwice(std::vector<int>({ 1, 1, 1, 2, 3, 4, 4, 5, 5, 5, 6, 7, 7, 8, 9, 10, 10, 10, 11, 12, 12 }));
		RemoveDuplicatesFromSortedArray().EraseUnique(std::vector<int>({ 1, 1, 1, 2, 3, 4, 4, 5, 5, 5, 6, 7, 7, 8, 9, 10, 10, 10, 11, 12, 12 }));
	}
	{
		SortColors().ThreeWayPartition(&std::vector<int>({ 0, 2, 0, 1, 2, 1, 1, 2, 2, 0, 1, 0, 2 })[0], 13);
		SortColors().CountingSort1(&std::vector<int>({ 0, 2, 0, 1, 2, 1, 1, 2, 2, 0, 1, 0, 2 })[0], 13);
		SortColors().CountingSort2(&std::vector<int>({ 0, 2, 0, 1, 2, 1, 1, 2, 2, 0, 1, 0, 2 })[0], 13);
		SortColors().InsertionSort(&std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 })[0], 13);
		SortColors().QuickSort(&std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 })[0], 13);
		SortColors().MergeSort(&std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 })[0], 13);
		SortColors().HeapSort(&std::vector<int>({ 7, 4, 3, 8, 2, 7, 1, 9, 6, 7, 5, 4, 8 })[0], 13);
	}
	{
		Anagrams().FindAll(std::vector<std::string>({ "tea", "and", "ace", "ad", "eat", "dan", "cae", "ate", "eleven plus two", "twelve plus one" }));
		Anagrams().Sort(std::vector<std::string>({ "tea", "and", "ace", "ad", "eat", "dan", "cae", "ate", "eleven plus two", "twelve plus one" }));
		Anagrams().FindAllAnagramSubstr(std::string("afdzyxyzcejyzxknyzxypq"), std::string("xyz"));
		Anagrams().FindAllAnagramSubstr(std::string("afdzyxycejyzxkxyyxyxyq"), std::string("yxy"));
	}
	{
		GroupShiftedStrings().UseHashMap(std::vector<std::string> ({ "abc", "bcd", "acef", "xyz", "az", "ba", "", "a", "z" }));
	}
	{
		SearchInterspersedSortedStrArray().FindIndex(std::vector<std::string>({ "at", "", "", "", "ball", "", "", "car", "", "", "dad", "", "" }), std::string("ball"));
	}
	{
		SearchForRange().LowerBoundUpperBound_STL(std::vector<int>({ 3, 4, 5, 5, 5, 6, 7, 7, 7, 8, 8 }), 7);
	}
	{
		SearchInsertionPos().LowerBound(std::vector<int>({ 3, 4, 5, 5, 5, 6, 7, 7, 7, 8, 8 }), 7);
	}
	{
		MinRangeOverKSortedLists().Solve_MinHeap(std::vector < std::vector<int>>(
		{
			{ 4, 10, 15, 24, 26 },
			{ 0, 9, 12, 20 },
			{ 5, 18, 22, 30 }
		}));
		MinRangeOverKSortedLists().Solve_SortedSet(std::vector < std::vector<int>>(
		{
			{ 4, 10, 15, 24, 26 },
			{ 0, 9, 12, 20 },
			{ 5, 18, 22, 30 }
		}));
		MinRangeOverKSortedLists().Solve_MinHeap(std::vector < std::vector<int>>(
		{
			{ 3, 5, 7, 8, 12, 26, 27, 31 },
			{ 9, 10, 15, 22, 24, 28 },
			{ 16, 17, 18, 21, 23 }
		}));
		MinRangeOverKSortedLists().Solve_SortedSet(std::vector < std::vector<int>>(
		{
			{ 3, 5, 7, 8, 12, 26, 27, 31 },
			{ 9, 10, 15, 22, 24, 28 },
			{ 16, 17, 18, 21, 23 }
		}));
		MinRangeOverKSortedLists().Solve_MinHeap(std::vector < std::vector<int>>(
		{
			{ 1, 2, 3, 80 },
			{ 1, 2, 3, 90, 200 },
			{ 1, 2, 3, 99, 300 }
		}));
		MinRangeOverKSortedLists().Solve_SortedSet(std::vector < std::vector<int>>(
		{
			{ 1, 2, 3, 80 },
			{ 1, 2, 3, 90, 200 },
			{ 1, 2, 3, 99, 300 }
		}));
		MinRangeOverKSortedLists().Solve_MinHeap(std::vector < std::vector<int>>(
		{
			{ 1, 10, 15, 24, 26 },
			{ 0, 9, 12, 18 },
			{ 2, 18, 22, 30 }
		}));
		MinRangeOverKSortedLists().Solve_SortedSet(std::vector < std::vector<int>>(
		{
			{ 1, 10, 15, 24, 26 },
			{ 0, 9, 12, 18 },
			{ 2, 18, 22, 30 }
		}));
	}
	{
		KwayMergeSort().Solve_MinHeap(std::vector < std::vector<int>>(
		{
			{ 4, 10, 15, 24, 26 },
			{ 0, 9, 12, 20, 32 },
			{ 5, 18, 22, 30, 42 }
		}));
		KwayMergeSort().Solve_MinHeap(std::vector < std::vector<int>>(
		{
			{ 3, 5, 7, 8, 12, 26, 27, 31 },
			{ 9, 10, 15, 22, 24, 28, 34, 43 },
			{ 16, 17, 18, 21, 23, 32, 38, 47 }
		}));
		KwayMergeSort().Solve_MinHeap(std::vector < std::vector<int>>(
		{
			{ 1, 2, 3, 80, 88 },
			{ 1, 2, 3, 90, 200 },
			{ 1, 2, 3, 99, 300 }
		}));
		KwayMergeSort().Solve_MinHeap(std::vector < std::vector<int>>(
		{
			{ 1, 10, 15, 24, 26 },
			{ 0, 9, 12, 18, 31 },
			{ 2, 18, 22, 30, 41 }
		}));
	}
	{
		StablePartition().ModifyMergeSort(std::vector<int>({ 1, -1, 2, 3, -5, -2, 9, 3, -4 }));
		StablePartition().ModifyMergeSort(std::vector<int>({ -1, 1, 3, -2, 2 }));
		StablePartition().QuadraticTime(std::vector<int>({ 1, -1, 2, 3, -5, -2, 9, 3, -4 }));
		StablePartition().LinearTimeLinearSpace(std::vector<int>({ 1, -1, 2, 3, -5, -2, 9, 3, -4 }));
		StablePartition().STL(std::vector<int>({ 1, -1, 2, 3, -5, -2, 9, 3, -4 }));

		for (int i = 0; i < 10; ++i)
		{
			std::vector<int> v = TestCase::RandVec<int>(15, -10, 10);
			StablePartition().ModifyMergeSort(std::vector<int>(v));
			StablePartition().QuadraticTime(std::vector<int>(v));
			StablePartition().LinearTimeLinearSpace(std::vector<int>(v));
			StablePartition().STL(std::vector<int>(v));
		}
	}
	{
		SortHeightsWFrontTallers().Sort_RopeInsertion_Inorder(std::vector<std::pair<int, int>>({ { 7,0 },{ 4,4 },{ 7,1 },{ 5,0 },{ 6,1 },{ 5,2 } }));
		SortHeightsWFrontTallers().Sort_Insert(std::vector<std::pair<int, int>>({ { 7,0 },{ 4,4 },{ 7,1 },{ 5,0 },{ 6,1 },{ 5,2 } }));
		SortHeightsWFrontTallers().Sort_RopeInsertion_Inorder(std::vector<std::pair<int, int>>({ { 4,0 },{ 3,0 },{ 2,1 },{ 1,1 } }));
		SortHeightsWFrontTallers().Sort_Insert(std::vector<std::pair<int, int>>({ { 4,0 },{ 3,0 },{ 2,1 },{ 1,1 } }));
	}
	{
		ShortestUnsortedSubarr().Find(std::vector<int>({ 0, 1, 15, 25, 6, 7, 30, 40, 50 }));
		ShortestUnsortedSubarr().Find(std::vector<int>({ 1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19 }));
		ShortestUnsortedSubarr().Find(std::vector<int>({ 15, 17, 19, 8, 2, 30, 4, 24, 26, 29 }));
	}
	{
		KthSmallestPairSum2SortedArrays().MinHeap(std::vector<int>({ 2, 3, 5, 8, 13 }), std::vector<int>({ 4, 8, 12, 16 }), 20);
		KthSmallestPairSum2SortedArrays().MinHeap(std::vector<int>({ 1,7,11 }), std::vector<int>({ 2,4,6 }), 3);
		KthSmallestPairSum2SortedArrays().MinHeap(std::vector<int>({ 1,1,2 }), std::vector<int>({ 1,2,3 }), 2);
		KthSmallestPairSum2SortedArrays().MinHeap(std::vector<int>({ 1,2 }), std::vector<int>({ 3 }), 3);
	}
	{
		MinPairDiff2SortedArrays().ModifiedMerge2SortedArrays(std::vector<int>({ -5, 7, 14, 23, 29, 38, 45, 54, 67, 78, 117 }), std::vector<int>({ 3, 18, 32, 40, 50, 62, 88, 97 }));
		MinPairDiff2SortedArrays().ModifiedMerge2SortedArrays2(std::vector<int>({ -5, 7, 14, 23, 29, 38, 45, 54, 67, 78, 117 }), std::vector<int>({ 3, 18, 32, 40, 50, 62, 88, 97 }));
		MinPairDiff2SortedArrays().ModifiedBinarySearch(std::vector<int>({ -5, 7, 14, 23, 29, 38, 45, 54, 67, 78, 117 }), std::vector<int>({ 3, 18, 32, 40, 50, 62, 88, 97 }));
	}
	{
		SortNearlySortedArray().Solve_MinHeap(std::vector<int>({ 2, 6, 3, 12, 56, 8 }), 3);
		SortNearlySortedArray().Solve_InsertionSort(std::vector<int>({ 2, 6, 3, 12, 56, 8 }));
	}
	{
		MinCostConnectRopes().MinHeap(std::vector<int>({ 4,3,2,6 }));
		MinCostConnectRopes().MinHeap(std::vector<int>({ 4,3,2,6,5,9,7,8,1 }));
	}
	{
		SortByPermutationOrder().InPlace_2Pass(std::vector<int>({ 17, 5, 1, 9 }), std::vector<int>({ 3, 2, 4, 1 }));
		SortByPermutationOrder().InPlace_Swap(std::vector<int>({ 17, 5, 1, 9 }), std::vector<int>({ 3, 2, 4, 1 }));
		SortByPermutationOrder().InPlace_2Pass(std::vector<int>({ 5, 12, 14, 27, 3, 2, 13, 17, 7, 21 }), std::vector<int>({ 3, 6, 2, 9, 7, 1, 4, 8, 5, 10 }));
		SortByPermutationOrder().InPlace_Swap(std::vector<int>({ 5, 12, 14, 27, 3, 2, 13, 17, 7, 21 }), std::vector<int>({ 3, 6, 2, 9, 7, 1, 4, 8, 5, 10 }));
		SortByPermutationOrder().InPlace_2Pass(std::vector<int>({ 10, 20, 30, 40 }), std::vector<int>({ 3, 1, 2, 4 }));
		SortByPermutationOrder().InPlace_Swap(std::vector<int>({ 10, 20, 30, 40 }), std::vector<int>({ 3, 1, 2, 4 }));

		std::vector<int> p = TestCase::RandUniqueVec<int>(10, 1, 10);
		SortByPermutationOrder().InPlace_Swap(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }), p);
		SortByPermutationOrder().InPlace_2Pass(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }), p);
		ApplyPermutationOrder().InPlace(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }), p);
		ApplyPermutationOrder().MarkVisit(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }), p);
	}
	{
		ApplyPermutationOrder().MarkVisit(std::vector<int>({ 10, 20, 30, 40 }), std::vector<int>({ 3, 1, 2, 4 }));
		ApplyPermutationOrder().InPlace(std::vector<int>({ 10, 20, 30, 40 }), std::vector<int>({ 3, 1, 2, 4 }));
		ApplyPermutationOrder().MarkVisit(std::vector<int>({ 17, 5, 1, 9 }), std::vector<int>({ 3, 2, 4, 1 }));
		ApplyPermutationOrder().InPlace(std::vector<int>({ 17, 5, 1, 9 }), std::vector<int>({ 3, 2, 4, 1 }));
		ApplyPermutationOrder().MarkVisit(std::vector<int>({ 5, 12, 14, 27, 3, 2, 13, 17, 7, 21 }), std::vector<int>({ 3, 6, 2, 9, 7, 1, 4, 8, 5, 10 }));
		ApplyPermutationOrder().InPlace(std::vector<int>({ 5, 12, 14, 27, 3, 2, 13, 17, 7, 21 }), std::vector<int>({ 3, 6, 2, 9, 7, 1, 4, 8, 5, 10 }));
	}
	{
		InversePermutationArray().InPlace(std::vector<int>({ 3, 8, 5, 10, 9, 4, 6, 1, 7, 2 }));
		InversePermutationArray().InPlace(std::vector<int>({ 1, 2, 3, 4 }));
		InversePermutationArray().InPlace(std::vector<int>({ 4, 3, 2, 1 }));
		InversePermutationArray().InPlace(std::vector<int>({ 3, 4, 1, 2 }));
		InversePermutationArray().InPlace(std::vector<int>({ 3, 4, 2, 1 }));
		for (int i = 0; i < 5; ++i)
		{
			InversePermutationArray().InPlace(TestCase::RandUniqueVec<int>(10, 1, 10));
		}
	}
	{
		MaxNumWLeastGreaterEqualCount().QuickSelect(std::vector<int>({ 1, 2, 3, 4 }));
		MaxNumWLeastGreaterEqualCount().QuickSelect(std::vector<int>({ 900, 2, 901, 3, 1000 }));
		MaxNumWLeastGreaterEqualCount().QuickSelect(std::vector<int>({ 900, 902, 901, 903, 1000 }));
		MaxNumWLeastGreaterEqualCount().Sort(std::vector<int>({ 1, 2, 3, 4 }));
		MaxNumWLeastGreaterEqualCount().Sort(std::vector<int>({ 900, 2, 901, 3, 1000 }));
		MaxNumWLeastGreaterEqualCount().Sort(std::vector<int>({ 900, 902, 901, 903, 1000 }));

		MaxNumWLeastGreaterEqualCount().QuickSelect(std::vector<int>({ 9, 5, 8, 1, 18, 15, 2, 4, 12, 9 }));
		MaxNumWLeastGreaterEqualCount().Sort(std::vector<int>({ 9, 5, 8, 1, 18, 15, 2, 4, 12, 9 }));

		for (int i = 0; i < 10; ++i)
		{
			std::vector<int> v = TestCase::RandVec<int>(10, -1, 16);
			MaxNumWLeastGreaterEqualCount().QuickSelect(v);
			MaxNumWLeastGreaterEqualCount().Sort(v);
		}
	}
	{
		AllPairsWSmallerEqualSum().FindAll(std::vector<int>({ 17, 3, 16, 2, 4, 6, 9, 12, 15, 1, 13, 11, 5, 8, 7, 14, 10, 12 }), 13);
		AllPairsWSmallerEqualSum().FindAll(std::vector<int>({ 17, 3, 16, 2, 4, 6, 9, 12, 15, 1, 13, 11, 5, 8, 7, 14, 10, 12 }), 7);
	}
	{
		InversionsInArray().Naive(std::vector<int>({ 2, 4, 2, 1, 3, 5 }));
		InversionsInArray().EnhancedMergeSort(std::vector<int>({ 2, 4, 2, 1, 3, 5 }));
		InversionsInArray().UsePrefixSums(std::vector<int>({ 2, 4, 2, 1, 3, 5 }));
		InversionsInArray().UseBinaryIndexedTree(std::vector<int>({ 2, 4, 2, 1, 3, 5 }));
		InversionsInArray().CountTotal_MergeSort2(std::vector<int>({ 2, 4, 2, 1, 3, 5 }));
        InversionsInArray().UseBST(std::vector<int>({ 2, 4, 2, 1, 3, 5 }));

		InversionsInArray().Naive(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2 }));
		InversionsInArray().EnhancedMergeSort(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2 }));
		InversionsInArray().UsePrefixSums(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2 }));
		InversionsInArray().UseBinaryIndexedTree(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2 }));
		InversionsInArray().CountTotal_MergeSort2(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2 }));
        InversionsInArray().UseBST(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2 }));

		InversionsInArray().Naive(std::vector<int>({ 6,3,6,5,2,4 }));
		InversionsInArray().EnhancedMergeSort(std::vector<int>({ 6,3,6,5,2,4 }));
		InversionsInArray().UsePrefixSums(std::vector<int>({ 6,3,6,5,2,4 }));
		InversionsInArray().UseBinaryIndexedTree(std::vector<int>({ 6,3,6,5,2,4 }));
		InversionsInArray().CountTotal_MergeSort2(std::vector<int>({ 6,3,6,5,2,4 }));
        InversionsInArray().UseBST(std::vector<int>({ 6,3,6,5,2,4 }));

        InversionsInArray().Naive(std::vector<int>({ 6,3,0,4,2,5,1 }));
        InversionsInArray().EnhancedMergeSort(std::vector<int>({ 6,3,0,4,2,5,1 }));
        InversionsInArray().UsePrefixSums(std::vector<int>({ 6,3,0,4,2,5,1 }));
        InversionsInArray().UseBinaryIndexedTree(std::vector<int>({ 6,3,0,4,2,5,1 }));
        InversionsInArray().CountTotal_MergeSort2(std::vector<int>({ 6,3,0,4,2,5,1 }));
        InversionsInArray().UseBST(std::vector<int>({ 6,3,0,4,2,5,1 }));

        InversionsInArray().Naive(std::vector<int>({ 5,3,0,4,2,5,1 }));
        InversionsInArray().EnhancedMergeSort(std::vector<int>({ 5,3,0,4,2,5,1 }));
        InversionsInArray().UsePrefixSums(std::vector<int>({ 5,3,0,4,2,5,1 }));
        InversionsInArray().UseBinaryIndexedTree(std::vector<int>({ 5,3,0,4,2,5,1 }));
        InversionsInArray().CountTotal_MergeSort2(std::vector<int>({ 5,3,0,4,2,5,1 }));
        InversionsInArray().UseBST(std::vector<int>({ 5,3,0,4,2,5,1 }));
	}
	{
		ReversePairs().UseMergeSort(std::vector<int>({ 1,3,2,3,1 }));
		ReversePairs().UseMergeSort(std::vector<int>({ 2,4,3,5,1 }));
	}
	{
		UnionIntersection2SortedArrays().Union(std::vector<int>({ 1, 3, 4, 5, 7 }), std::vector<int>({ 2, 3, 5, 6 }));
		UnionIntersection2SortedArrays().Intersection(std::vector<int>({ 1, 3, 4, 5, 7 }), std::vector<int>({ 2, 3, 5, 6 }));
		UnionIntersection2SortedArrays().Intersection(std::vector<int>({ 1, 3, 3, 3, 3, 3, 4, 4, 5, 5, 7 }), std::vector<int>({ 2, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6 }));
		UnionIntersection2SortedArrays().Intersection_WoDup(std::vector<int>({ 1, 3, 3, 3, 3, 3, 4, 4, 5, 5, 7 }), std::vector<int>({ 2, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6 }));
		UnionIntersection2SortedArrays().Intersection3(std::vector<int>({ 1, 1, 5, 10, 20, 20, 40, 80, 80, 100 }), std::vector<int>({ 1, 1, 1, 6, 7, 20, 20, 80, 100 }), std::vector<int>({ 1, 1, 3, 4, 15, 20, 20, 30, 70, 80, 80, 80, 80, 80, 120 }));
		UnionIntersection2SortedArrays().Intersection3_WoDup(std::vector<int>({ 1, 1, 5, 10, 20, 20, 40, 80, 80, 100 }), std::vector<int>({ 1, 1, 1, 6, 7, 20, 20, 80, 100 }), std::vector<int>({ 1, 1, 3, 4, 15, 20, 20, 30, 70, 80, 80, 80, 80, 80, 120 }));
		UnionIntersection2SortedArrays().Intersection3_WoDup(std::vector<int>({ 0, 1, 2, 3, 3, 4, 5 }), std::vector<int>({ 1, 2, 2, 3, 5, 5 }), std::vector<int>({ 1, 1, 3, 3, 5, 6, 6 }));
	}
	{
		MatchingNutsBoltsProblem().RandomizedQuickSort(std::vector<int>({ 3, 7, 2, 5, 6, 9, 1, 4, 8 }), std::vector<int>({ 7, 3, 1, 4, 8, 5, 9, 2, 6 }));
		MatchingNutsBoltsProblem().RandomizedQuickSort(std::vector<int>({ 5, 4, 2, 3, 1, 8, 6, 7, 9 }), std::vector<int>({ 1, 9, 8, 5, 7, 4, 3, 6, 2 }));
		MatchingNutsBoltsProblem().RandomizedQuickSort(TestCase::RandUniqueVec<int>(9, 1, 9), TestCase::RandUniqueVec<int>(9, 1, 9));
	}
	{
		Sort1toNAvgOutside2Nums().QuickSort(std::vector<int>({ 1, 2, 3 }));
		Sort1toNAvgOutside2Nums().QuickSort(std::vector<int>({ 1, 2, 3, 4 }));
		Sort1toNAvgOutside2Nums().QuickSort(std::vector<int>({ 1, 2, 3, 4, 5 }));
		Sort1toNAvgOutside2Nums().QuickSort(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }));
		Sort1toNAvgOutside2Nums().QuickSort(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 }));
	}
	{
		InterpolationSearch().Index_UpperBound(std::vector<int>({ 2, 4, 6, 8, 10, 12, 13, 14, 15, 16, 18, 20, 22, 24 }), 8);
		InterpolationSearch().Index_LowerBound(std::vector<int>({ 2, 4, 6, 8, 10, 12, 13, 14, 15, 16, 18, 20, 22, 24 }), 21);

		//for (int i = 1; i <= 25; ++i)
		//{
		//	InterpolationSearch().Index_UpperBound(std::vector<int>({ 2, 4, 6, 8, 10, 12, 13, 14, 15, 16, 18, 20, 22, 24 }), i);
		//	InterpolationSearch().Index_LowerBound(std::vector<int>({ 2, 4, 6, 8, 10, 12, 13, 14, 15, 16, 18, 20, 22, 24 }), i);
		//}
		//for (int i = 0; i <= 25; ++i)
		//{
		//	InterpolationSearch().Index_UpperBound(std::vector<int>({ 1, 4, 7, 7, 7, 7, 7, 15, 18, 18, 18, 18, 19, 20, 21, 24 }), i);
		//	InterpolationSearch().Index_LowerBound(std::vector<int>({ 1, 4, 7, 7, 7, 7, 7, 15, 18, 18, 18, 18, 19, 20, 21, 24 }), i);
		//}
		//for (int i = 0; i <= 100; ++i)
		//{
			//InterpolationSearch().Index_UpperBound(std::vector<int>({ 1, 1, 1, 1, 23, 56, 78, 78, 97, 98, 98, 98, 99, 99, 99, 99, 100, 100 }), i);
			//InterpolationSearch().Index_LowerBound(std::vector<int>({ 1, 1, 1, 1, 1, 1, 1, 97, 98, 98, 98, 99, 99, 99, 99, 100 }), i);
			//InterpolationSearch().Index(std::vector<int>({ 1, 4, 7, 7, 7, 7, 7, 18, 18, 18, 37, 39, 40, 61, 87, 100 }), i);
		//}
		//for (int i = 0; i <= 100; ++i)
		//{
		//	InterpolationSearch().Index_UpperBound(std::vector<int>({ 1, 4, 7, 7, 7, 7, 7, 18, 18, 18, 37, 39, 40, 61, 87, 100 }), i);
		//	InterpolationSearch().Index_LowerBound(std::vector<int>({ 1, 4, 7, 7, 7, 7, 7, 18, 18, 18, 37, 39, 40, 61, 87, 100 }), i);
		//}
	}
	{
		SortKIncrDecrArray().UseKwayMergeSort(std::vector<int>({ 57, 131, 493, 294, 221, 339, 418, 452, 442, 190 }));
		SortKIncrDecrArray().UseKwayMergeSort(std::vector<int>({ 2, 3, 4, 6, 8, 7, 7, 5, 4, 1, 0, 11, 13, 17, 18, 16, 14, 12, 10, 19 }));
	}
	{
		FirstKClosestStars().MaxHeap(std::vector<int>({ 65, 93, 94, 81, 63, 48, 53, 74, 60, 59, 30, 29, 88, 77, 23, 54, 26, 18, 37, 59, 32, 72 }), 5);
		FirstKClosestStars().MaxHeap_FromISS(std::istringstream("65, 0\n93, 1\n94, 2\n81, 3\n63, 4\n48, 5\n53, 6\n74, 7\n60, 8\n59, 9\n30, 10\n29, 11\n88, 12\n77, 13\n23, 14\n54, 15\n26, 16\n18, 17\n37, 18\n59, 19\n32, 20\n72, 21"), 5);
		FirstKClosestStars().Selection(std::vector<int>({ 65, 93, 94, 81, 63, 48, 53, 74, 60, 59, 30, 29, 88, 77, 23, 54, 26, 18, 37, 59, 32, 72 }), 5);
		FirstKClosestStars().STL_Nth_Element(std::vector<int>({ 65, 93, 94, 81, 63, 48, 53, 74, 60, 59, 30, 29, 88, 77, 23, 54, 26, 18, 37, 59, 32, 72 }), 5);
	}
	{
		FirstKClosestToMedianElements().BruteForce_MaxHeap(std::vector<int>({ 65, 93, 94, 81, 63, 48, 53, 74, 60, 4, 30, 29, 88, 77, 23, 54, 26, 18, 37, 59, 32, 72 }), 10);
		FirstKClosestToMedianElements().ModifiedSelection(std::vector<int>({ 65, 93, 94, 81, 63, 48, 53, 74, 60, 4, 30, 29, 88, 77, 23, 54, 26, 18, 37, 59, 32, 72 }), 10);
		FirstKClosestToMedianElements().ModifiedSelection2(std::vector<int>({ 65, 93, 94, 81, 63, 48, 53, 74, 60, 4, 30, 29, 88, 77, 23, 54, 26, 18, 37, 59, 32, 72 }), 10);
		FirstKClosestToMedianElements().STL_Nth_Element(std::vector<int>({ 65, 93, 94, 81, 63, 48, 53, 74, 60, 4, 30, 29, 88, 77, 23, 54, 26, 18, 37, 59, 32, 72 }), 10);
	}
	{
		LocalMinimaInUnsortedArray().Index_NonStrickly_Iterate(std::vector<int>({ 9, 7, 7, 2, 1, 3, 7, 5, 4, 7, 3, 3, 4, 8, 6, 9 }));
		LocalMinimaInUnsortedArray().Index_NonStrickly_Iterate(std::vector<int>({ 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 7, 8 }));
		LocalMinimaInUnsortedArray().Index_NonStrickly_Iterate(std::vector<int>({ 19, 18, 17, 17, 16, 15, 14, 13, 13, 12, 12, 11, 11, 10, 10, 9, 8, 7, 7, 6, 6, 7, 7, 8 }));
		LocalMinimaInUnsortedArray().Index_NonStrickly_Iterate(std::vector<int>({ 9, 7, 2, 1, 3, 7, 5, 4, 7, 3, 4, 8, 6, 9 }));
		LocalMinimaInUnsortedArray().Index_NonStrickly_Iterate(std::vector<int>({ 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 7, 8 }));
		LocalMinimaInUnsortedArray().Index_NonStrickly_Iterate(std::vector<int>({ 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 7, 8, 17, 19 }));
		LocalMinimaInUnsortedArray().Index_NonStrickly_Iterate(std::vector<int>({ 8, 7, 7, 8 }));
		LocalMinimaInUnsortedArray().Index_NonStrickly_Iterate(std::vector<int>({ 8, 6, 9, 7, 8 }));
		LocalMinimaInUnsortedArray().Index_NonStrickly_Iterate(std::vector<int>({ 8, 6, 6, 6, 8 }));

		LocalMinimaInUnsortedArray().Index_Strickly_AllowDup(std::vector<int>({ 9, 7, 7, 2, 1, 3, 7, 5, 4, 7, 3, 3, 4, 8, 6, 9 }));
		LocalMinimaInUnsortedArray().Index_Strickly_AllowDup(std::vector<int>({ 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 7, 8 }));
		LocalMinimaInUnsortedArray().Index_Strickly_AllowDup(std::vector<int>({ 19, 18, 17, 17, 16, 15, 14, 13, 13, 12, 12, 11, 11, 10, 10, 9, 8, 7, 7, 6, 6, 7, 7, 8 }));
		LocalMinimaInUnsortedArray().Index_Strickly_AllowDup(std::vector<int>({ 9, 7, 2, 1, 3, 7, 5, 4, 7, 3, 4, 8, 6, 9 }));
		LocalMinimaInUnsortedArray().Index_Strickly_AllowDup(std::vector<int>({ 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 7, 8 }));
		LocalMinimaInUnsortedArray().Index_Strickly_AllowDup(std::vector<int>({ 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 7, 8, 17, 19 }));
		LocalMinimaInUnsortedArray().Index_Strickly_AllowDup(std::vector<int>({ 8, 7, 7, 8 }));
		LocalMinimaInUnsortedArray().Index_Strickly_AllowDup(std::vector<int>({ 8, 6, 9, 7, 8 }));
		LocalMinimaInUnsortedArray().Index_Strickly_AllowDup(std::vector<int>({ 8, 6, 6, 6, 8 }));

		std::vector<int> v = TestCase::RandVec(20, 1, 10);
		LocalMinimaInUnsortedArray().Index_Strickly_AllowDup(v);
		LocalMaximumInUnsortedArray().Strickly_Iterate(v);

        LocalMaximumInUnsortedArray().Strickly_Iterate(std::vector<int>({1,2,1,2,3,4,5,6,7}));
	}
	{
		BinarySearchUnknownLength().Iterate(std::vector<int>({ 3, 5, 24, 27, 34, 41, 45, 58, 61, 62, 64, 67, 69, 78, 78, 78, 81 }), 78);
	}
	{
		QuickSort().GO(&std::vector<int>(
		{ 3, 9, 8, 7, 6, -5, -5, 13, -2, -1, -7, -9, 5, 4, 4, 11, 2, 12, 1, 14, 20, 19, 17, 16, 18, -3, -4, -6, 21, 11, 13, 15, 16, 24 })[0], 34);
		for (int i = 8; i <= 8; ++i)
		{
			KthSmallestElementUnknownLength().BruteForce_MaxHeap(std::istringstream("3 9 8 7 6 -5 -5 13 -2 -1 -7 -9 5 4 4 11 2 12 1 14 20 19 17 16 18 -3 -4 -6 21 11 13 15 16 24"), i);
			KthSmallestElementUnknownLength().ModifiedSelection(std::istringstream("3 9 8 7 6 -5 -5 13 -2 -1 -7 -9 5 4 4 11 2 12 1 14 20 19 17 16 18 -3 -4 -6 21 11 13 15 16 24"), i);
		}
	}
	{
		CountingSort2().GroupSameKeys(std::vector<std::pair<int, std::string>>(
		{
			{ 5, "a" }, { 2, "b" }, { 6, "c" }, { 9, "d" }, { 4, "e" }, { 5, "f" }, { 9, "g" }, { 2, "h" }, { 5, "i" }, { 7, "j" }, { 8, "k" }, { 6, "l" }, { 7, "m" }, { 2, "n" }, { 9, "o" }, { 4, "p" }, { 7, "q" }, { 8, "r" }, { 5, "t" }
		}));
		CountingSort2().SortKeys(std::vector<std::pair<int, std::string>>(
		{
			{ 5, "a" }, { 2, "b" }, { 6, "c" }, { 9, "d" }, { 4, "e" }, { 5, "f" }, { 9, "g" }, { 2, "h" }, { 5, "i" }, { 7, "j" }, { 8, "k" }, { 6, "l" }, { 7, "m" }, { 2, "n" }, { 9, "o" }, { 4, "p" }, { 7, "q" }, { 8, "r" }, { 5, "t" }
		}));
	}
	{
		IndirectSortTextLineLengthInFile().Test();
        IndirectSortTextLinesInLogFile().Sort(std::vector<std::string>({"zz 93 1", "a2da abd fjdks lkdf", "b3ds gfi skl", "sji akdk jige", "d1ka 123 345 943 32", "dkj dks jdf", "d0k 8342 372 83", "dki dks jdf"}));
        IndirectSortTextLinesInLogFile().UseStableSort(std::vector<std::string>({"a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"}));
	}
	{
		LeastDistanceSort().IndirectAndPermute(std::vector<int>({ 41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 }));
	}
	{
		WeightedMedianElement().UseSort(std::vector<std::pair<double, int>>({ { 2.0, 0 }, { 5.0, 1 }, { 1.0, 2 }, { 4.0, 3 }, { 6.0, 4 }, { 2.0, 5 }, { 9.0, 6 }, { 1.0, 7 }, { 8.0, 8 }, { 13.0, 9 }, { 7.0, 10 }, { 10.0, 11 }, { 17.0, 12 }, { 13.0, 13 }, { 8.0, 14 }, { 12.0, 15 } }));
		WeightedMedianElement().UseSelect(std::vector<std::pair<double, int>>({ { 13.0, 13 }, { 1.0, 2 }, { 7.0, 10 }, { 9.0, 6 }, { 10.0, 11 }, { 12.0, 15 }, { 17.0, 12 }, { 13.0, 9 }, { 8.0, 14 }, { 2.0, 0 }, { 6.0, 4 }, { 2.0, 5 }, { 1.0, 7 }, { 5.0, 1 }, { 4.0, 3 }, { 8.0, 8 } }));
		WeightedMedianElement().UseSelect2(std::vector<std::pair<double, int>>({ { 13.0, 13 }, { 1.0, 2 }, { 7.0, 10 }, { 9.0, 6 }, { 10.0, 11 }, { 12.0, 15 }, { 17.0, 12 }, { 13.0, 9 }, { 8.0, 14 }, { 2.0, 0 }, { 6.0, 4 }, { 2.0, 5 }, { 1.0, 7 }, { 5.0, 1 }, { 4.0, 3 }, { 8.0, 8 } }));

		WeightedMedianElement().UseSort(std::vector<std::pair<double, int>>({ { 27.0, 0 }, { 18.0, 1 }, { 13.0, 2 }, { 7.0, 3 }, { 6.0, 4 }, { 2.0, 5 }, { 6.0, 6 }, { 1.0, 7 }, { 8.0, 8 }, { 3.0, 9 }, { 4.0, 10 }, { 3.0, 11 }, { 4.0, 12 }, { 2.0, 13 }, { 3.0, 14 }, { 2.0, 15 } }));
		WeightedMedianElement().UseSelect(std::vector<std::pair<double, int>>({ { 2.0, 13 }, { 13.0, 2 }, { 4.0, 10 }, { 6.0, 6 }, { 3.0, 11 }, { 2.0, 15 }, { 4.0, 12 }, { 3.0, 9 }, { 3.0, 14 }, { 27.0, 0 }, { 6.0, 4 }, { 2.0, 5 }, { 1.0, 7 }, { 18.0, 1 }, { 7.0, 3 }, { 8.0, 8 } }));
		WeightedMedianElement().UseSelect2(std::vector<std::pair<double, int>>({ { 2.0, 13 }, { 13.0, 2 }, { 4.0, 10 }, { 6.0, 6 }, { 3.0, 11 }, { 2.0, 15 }, { 4.0, 12 }, { 3.0, 9 }, { 3.0, 14 }, { 27.0, 0 }, { 6.0, 4 }, { 2.0, 5 }, { 1.0, 7 }, { 18.0, 1 }, { 7.0, 3 }, { 8.0, 8 } }));

		std::vector<std::pair<double, int>> v = TestCase::RandVecPair<double, int>(16, 1.0, 30.0, 1, 99);
		WeightedMedianElement().UseSort(v);
		WeightedMedianElement().UseSelect(v);
		WeightedMedianElement().UseSelect(v);
	}
	{
		RearrangeArrWEqualEntriesKAway().MaxHeapGreedyAssign(std::string("aabbcc"), 2);
		RearrangeArrWEqualEntriesKAway().MaxHeapGreedyAssign(std::string("aabbcc"), 3);
		RearrangeArrWEqualEntriesKAway().MaxHeapGreedyAssign(std::string("aaabc"), 2);
		RearrangeArrWEqualEntriesKAway().MaxHeapGreedyAssign(std::string("aaadbbcc"), 2);

        RearrangeArrWEqualCharsKAway().CountLeastSpace_Linear(std::vector<char>({'a','a','b','b','c','c'}), 2);
        RearrangeArrWEqualCharsKAway().CountLeastSpace_Linear(std::vector<char>({'a','a','b','b','c','c'}), 3);
        RearrangeArrWEqualCharsKAway().CountLeastSpace_Linear(std::vector<char>({'a','a','a','b','c'}), 2);
        RearrangeArrWEqualCharsKAway().CountLeastSpace_Linear(std::vector<char>({'a','a','a','d','b','b','c','c'}), 2);

        RearrangeArrWEqualCharsKAway().CountLeastSpace_MaxHeap(std::vector<char>({'a','a','b','b','c','c'}), 2);
        RearrangeArrWEqualCharsKAway().CountLeastSpace_MaxHeap(std::vector<char>({'a','a','b','b','c','c'}), 3);
        RearrangeArrWEqualCharsKAway().CountLeastSpace_MaxHeap(std::vector<char>({'a','a','a','b','c'}), 2);
        RearrangeArrWEqualCharsKAway().CountLeastSpace_MaxHeap(std::vector<char>({'a','a','a','d','b','b','c','c'}), 2);

        RearrangeArrWEqualCharsKAway().CountLeastSpace_WithSameOrder(std::vector<char>({'a','a','b','b','c','c'}), 2);
        RearrangeArrWEqualCharsKAway().CountLeastSpace_WithSameOrder(std::vector<char>({'a','a','b','b','c','c'}), 3);
        RearrangeArrWEqualCharsKAway().CountLeastSpace_WithSameOrder(std::vector<char>({'a','a','a','b','c'}), 2);
        RearrangeArrWEqualCharsKAway().CountLeastSpace_WithSameOrder(std::vector<char>({'a','a','a','d','b','b','c','c'}), 2);

        RearrangeArrWithoutAdjacentEqualChars().Linear(std::string("aab"));
        RearrangeArrWithoutAdjacentEqualChars().Linear(std::string("aabb"));

        RearrangeArrWo3ConsecuEqualChars().UseMaxHeap(1, 1, 6);
        RearrangeArrWo3ConsecuEqualChars().UseMaxHeap(1, 2, 3);
        RearrangeArrWo3ConsecuEqualChars().UseMaxHeap(3, 3, 3);
        RearrangeArrWo3ConsecuEqualChars().UseMaxHeap(1, 1, 9);
	}
	{
		for (int i = 1; i <= 35; i += 20)
			KthSmallestElementInMatrix().OneDQuickSelectIterate(std::vector<std::vector<int>>(
		{
			{ 21, 34, 4, 24, 18, 27, 1 },
			{ 25, 17, 35, 29, 13, 3, 31 },
			{ 7, 20, 6, 15, 22, 9, 23 },
			{ 26, 33, 30, 16, 8, 14, 5 },
			{ 11, 10, 2, 12, 32, 28, 19 },

		}), i);
	}
	{
		for (int i = 11; i <= 35; i += 11)
			KthSmallestElementInSortedMatrix().MinHeap_InPlace(std::vector<std::vector<int>>(
		{
			{ 1, 3, 4, 8, 12, 22, 25 },
			{ 2, 5, 6, 9, 18, 27, 30 },
			{ 7, 11, 15, 20, 23, 28, 32 },
			{ 10, 13, 17, 21, 26, 31, 34 },
			{ 14, 16, 19, 24, 29, 33, 35 },
		}), i);
		for (int i = 11; i <= 35; i += 11)
			KthSmallestElementInSortedMatrix().MinHeap(std::vector<std::vector<int>>(
		{
			{  1,  3,  4,  8, 12, 22, 25 },
			{  2,  5,  6,  9, 18, 27, 30 },
			{  7, 11, 15, 20, 23, 28, 32 },
			{ 10, 13, 17, 21, 26, 31, 34 },
			{ 14, 16, 19, 24, 29, 33, 35 },
		}), i);
		for (int i = 11; i <= 35; i += 11)
			KthSmallestElementInSortedMatrix().ExtractMin(std::vector<std::vector<int>>(
		{
			{ 1, 3, 4, 8, 12, 22, 25 },
			{ 2, 5, 6, 9, 18, 27, 30 },
			{ 7, 11, 15, 20, 23, 28, 32 },
			{ 10, 13, 17, 21, 26, 31, 34 },
			{ 14, 16, 19, 24, 29, 33, 35 },
		}), i);

		KthSmallestElementInSortedMatrix().MinHeap_InPlace(std::vector<std::vector<int>>(
		{
			{ 1,5,9 },
			{ 10,11,13 },
			{ 12,13,15 },
		}), 8);
		KthSmallestElementInSortedMatrix().MinHeap(std::vector<std::vector<int>>(
		{
			{ 1,5,9 },
			{ 10,11,13 },
			{ 12,13,15 },
		}), 8);
		KthSmallestElementInSortedMatrix().ExtractMin(std::vector<std::vector<int>>(
		{
			{ 1,5,9 },
			{ 10,11,13 },
			{ 12,13,15 },
		}), 8);
	}
	{
		std::vector<std::vector<int>> search2dMatrixGrid(
		{
			{ 11, 12, 13, 14, 15, 16, 17 },
			{ 21, 22, 23, 24, 25, 26, 27 },
			{ 31, 32, 33, 34, 35, 36, 37 },
			{ 41, 42, 43, 44, 45, 46, 47 },
			{ 51, 52, 53, 54, 55, 56, 57 },
			{ 61, 62, 63, 64, 65, 66, 67 }
		});
		Search2dSortedMatrix().UpperRightLinearSearch(search2dMatrixGrid, 44);
		Search2dSortedMatrix().TwoDQuadSearchRecur(search2dMatrixGrid, 47);
		Search2dSortedMatrix().OneDBinarySearch(search2dMatrixGrid, 33);
		Search2dSortedMatrix().TwoDBinarySearchRecur(search2dMatrixGrid, 67);
		Search2dSortedMatrix().TwoDBinarySearchRecur2(search2dMatrixGrid, 47);

		std::vector<std::vector<int>> search2dMatrixGrid2(
		{
			{ 2, 2, 3, 5 },
			{ 3, 4, 6, 6 },
			{ 3, 5, 6, 6 },
			{ 3, 6, 6, 9 },
		});
		int row, col;
		SaddlebackSearchSortedMatrix().FirstFound(search2dMatrixGrid2, 6, row, col);
		SaddlebackSearchSortedMatrix().FirstOccurrence(search2dMatrixGrid2, 6, row, col);
		SaddlebackSearchSortedMatrix().AllOccurrences(search2dMatrixGrid2, 6);
		SaddlebackSearchSortedMatrix().Count(search2dMatrixGrid2, 6);

		//2d matrix where the first integer of each row is NOT necessarily greater than the last integer of the previous row.
		std::vector<std::vector<int>> search2dMatrixGrid3(
		{
			{ 1, 4, 7, 11, 15 },
			{ 2, 5, 8, 12, 19 },
			{ 3, 6, 9, 16, 22 },
			{ 10, 13, 14, 17, 24 },
			{ 18, 21, 23, 26, 30 },
		});
		for (int i = 0; i < 10; ++i)
		{
			int r = TestCase::RandNum<int>(-2, 33);
			Search2dSortedMatrix().UpperRightLinearSearch(search2dMatrixGrid3, r);
			Search2dSortedMatrix().TwoDQuadSearchRecur(search2dMatrixGrid3, r);
			Search2dSortedMatrix().TwoDBinarySearchRecur(search2dMatrixGrid3, r);
			Search2dSortedMatrix().TwoDBinarySearchRecur2(search2dMatrixGrid3, r);
			Search2dSortedMatrix().OneDBinarySearch(search2dMatrixGrid3, r);//only this is not working
		}
	}
	{
		YoungTableau().ExtractMin(std::vector<std::vector<int>>(
		{
			{ 1, 3, 4, 8, 12, 22, 25 },
			{ 2, 5, 6, 9, 18, 27, 30 },
			{ 7, 11, 15, 20, 23, 28, 32 },
			{ 10, 13, 17, 21, 26, 31, 34 },
			{ 14, 16, 19, 24, 29, 33, 35 },
		}));
		YoungTableau().Extract_K_Min(std::vector<std::vector<int>>(
		{
			{ 1, 3, 4, 8, 12, 22, 25 },
			{ 2, 5, 6, 9, 18, 27, 30 },
			{ 7, 11, 15, 20, 23, 28, 32 },
			{ 10, 13, 17, 21, 26, 31, 34 },
			{ 14, 16, 19, 24, 29, 33, 35 },
		}), 17);

		YoungTableau().Insert(std::vector<std::vector<int>>(
		{
			{ 11, 13, 14, 19, INT_MAX, INT_MAX, INT_MAX },
			{ 12, 15, 16, 32, INT_MAX, INT_MAX, INT_MAX },
			{ 17, 18, 33, 34, INT_MAX, INT_MAX, INT_MAX },
			{ 20, 35, 36, 39, INT_MAX, INT_MAX, INT_MAX },
			{ 31, 37, 38, 40, INT_MAX, INT_MAX, INT_MAX },
		}), 1);
		YoungTableau().Insert(std::vector<std::vector<int>>(
		{
			{ 11, 13, 14, 19, INT_MAX, INT_MAX, INT_MAX },
			{ 12, 15, 16, 32, INT_MAX, INT_MAX, INT_MAX },
			{ 17, 18, 33, 34, INT_MAX, INT_MAX, INT_MAX },
			{ 20, 35, 36, 39, INT_MAX, INT_MAX, INT_MAX },
			{ 31, 37, 38, 40, INT_MAX, INT_MAX, INT_MAX },
		}), std::vector<int>({1, 2, 3, 4, 5, 6, 7, 8, 9, 21, 22, 23, 24, 25, 26}));

		YoungTableau().Sort(std::vector<int>({15, 3, 14, 16, 12, 7, 9, 17, 18, 11, 5, 8, 10, 4, 2, 13, 1, 6}));
	}
	{
		HIndex().Sort_LinearScan(std::vector<int>({ 3,0,6,1,5 }));
		HIndex().LinearTimeExtraSpace(std::vector<int>({ 3,0,6,1,5 }));
		HIndex().QuickSelect(std::vector<int>({ 3,0,6,1,5 }));
		HIndex().BinarySearch(std::vector<int>({ 0,1,3,5,6 }));
		HIndex().BinarySearch2(std::vector<int>({ 0,1,3,5,6 }));
	}
	{
		FirstBadVersion().BinarySearch(1000);
	}
	{
		GuessNumberHigherOrLower().BinarySearch(1000);

		GuessNumberHigherOrLower().DP2D(10);
		GuessNumberHigherOrLower().Recur(10);

		GuessNumberHigherOrLower().DP2D(3);
		GuessNumberHigherOrLower().Recur(3);

		GuessNumberHigherOrLower().DP2D(15);
		GuessNumberHigherOrLower().Recur(15);
	}
	{
		CreateMaxNumberFrom2Arrays().UseSortedStkAndMerge(std::vector<int>({ 3, 4, 6, 5 }), std::vector<int>({ 9, 1, 2, 5, 8, 3 }), 5);
		CreateMaxNumberFrom2Arrays().UseSortedStkAndMerge(std::vector<int>({ 2, 5, 6, 4, 4, 0 }), std::vector<int>({ 7, 3, 8, 0, 6, 5, 7, 6, 2 }), 15);
	}
	{
		TopKFrequentElements().UseMaxHeap(std::vector<int>({ 1,1,1,2,2,3 }), 2);
		TopKFrequentElements().UseSelection(std::vector<int>({ 1,1,1,2,2,3 }), 2);
		TopKFrequentElements().UseBucketSort(std::vector<int>({ 1,1,1,2,2,3 }), 2);
	}
	{
		TopKFrequentStrings().BucketSort_Trie(std::vector<std::string>({ "i", "love", "leetcode", "i", "love", "coding" }), 2);
		TopKFrequentStrings().MinHeap(std::vector<std::string>({ "i", "love", "leetcode", "i", "love", "coding" }), 2);
	}
	{
		SortTransformedArray().UseMinHeap(std::vector<int>({ -4, -2, 2, 4 }), 1, 3, 5);
		SortTransformedArray().Greedy(std::vector<int>({ -4, -2, 2, 4 }), 1, 3, 5);

		SortTransformedArray().UseMinHeap(std::vector<int>({ -4, -2, 2, 4 }), -1, 3, 5);
		SortTransformedArray().Greedy(std::vector<int>({ -4, -2, 2, 4 }), -1, 3, 5);

		SortTransformedArray().TransformToSortedSquares_Greedy(std::vector<int>({ -4,1,3,5 }));
		SortTransformedArray().TransformToSortedSquares_Greedy(std::vector<int>({ -5,-2,-1,0,1,2,2,3,5 }));
	}
	{
		MaxTop3AvgScoreStudent().Find(std::istringstream("a 78 b 95 c 94 d 83 e 83 a 82 e 59 f 64 g 85 b 80 c 98 d 70 e 87 b 88 c 97 b 79 d 83 h 99 i 98 g 96 f 89 a 99 b 96 c 95 d 67"));
	}
	{
		SinglesFrom2SortedStrArr().Solve(std::vector<std::string>({ "abc", "cde", "ijk", "mno", "rst", "xyz" }), std::vector<std::string>({ "abc", "def", "ghi", "ijk", "mno", "pqr", "rst", "xyz", "zab" }));
	}
	{
		SortCharsByFrequency().frequencySort("Aabb");
		SortCharsByFrequency().frequencySort("2a554442f544asfasssffffasss");
	}
	{
		SlidingWindowMedian().UseSortedMultiSetWindow(std::vector<int>({ 1,3,-1,-3,5,3,6,7 }), 3);
	}
	{
		NextGreaterElement().NonCircular_UseStack(std::vector<int>({ 2,4 }), std::vector<int>({ 1,2,3,4 }));
		NextGreaterElement().NonCircular_UseStack(std::vector<int>({ 2,4 }), std::vector<int>({ 4,3,2,1 }));
		NextGreaterElement().Circular_UseStack(std::vector<int>({ 1,2,1 }));

        DailyTemperatures().UseStack(std::vector<int>({73, 74, 75, 71, 69, 72, 76, 73}));
	}
	{
		MaxCapitalForIPO().SortAndMaxHeap(1, 2, std::vector<int>({ 2,1,3 }), std::vector<int>({ 1,1,2 }));
		MaxCapitalForIPO().SortAndMaxHeap(11, 11, std::vector<int>({ 1,2,3 }), std::vector<int>({ 11,12,13 }));
	}
	{
		AssignCookiesToMaxNumChildren().SortAndGreedy(std::vector<int>({ 1,2,3 }), std::vector<int>({ 1,1 }));
		AssignCookiesToMaxNumChildren().SortAndGreedy(std::vector<int>({ 1,2 }), std::vector<int>({ 1,2,3 }));
	}
	{
		ArrangeCoinsStaircaseShape().BinarySearch(5);
		ArrangeCoinsStaircaseShape().BinarySearch(8);
	}
	{
		GenericPartition().GroupSame(std::vector<int>({ 1 })
			, std::function<bool(int a, int b)>([](int a, int b) { return a % 3 == b % 3; }));
		GenericPartition().GroupSame(std::vector<int>({ 1,1 })
			, std::function<bool(int a, int b)>([](int a, int b) { return a % 3 == b % 3; }));
		GenericPartition().GroupSame(std::vector<int>({ 1,2 })
			, std::function<bool(int a, int b)>([](int a, int b) { return a % 3 == b % 3; }));
		GenericPartition().GroupSame(std::vector<int>({ 1,1,1 })
			, std::function<bool(int a, int b)>([](int a, int b) { return a % 3 == b % 3; }));
		GenericPartition().GroupSame(std::vector<int>({ 1,2,1 })
			, std::function<bool(int a, int b)>([](int a, int b) { return a % 3 == b % 3; }));
		GenericPartition().GroupSame(std::vector<int>({ 1,2,2 })
			, std::function<bool(int a, int b)>([](int a, int b) { return a % 3 == b % 3; }));
		GenericPartition().GroupSame(std::vector<int>({ 1,1,2 })
			, std::function<bool(int a, int b)>([](int a, int b) { return a % 3 == b % 3; }));
		GenericPartition().GroupSame(std::vector<int>({ 1,2,3 })
			, std::function<bool(int a, int b)>([](int a, int b) { return a % 3 == b % 3; }));

		GenericPartition().GroupSame(std::vector<int>({ 1,2,3,4,5,6,7,8,9,10 })
			, std::function<bool(int a, int b)>([](int a, int b) { return a % 2 == b % 2; }));
		GenericPartition().GroupSame(std::vector<int>({ 1,2,3,4,5,6,7,8,9,10 })
			, std::function<bool(int a, int b)>([](int a, int b) { return a % 3 == b % 3; }));

		GenericPartition().GroupSame(std::vector<int>({ 1,2,3,4,5,6,7,8,9 })
			, std::function<bool(int a, int b)>([](int a, int b) { return a % 2 == b % 2; }));
		GenericPartition().GroupSame(std::vector<int>({ 1,2,3,4,5,6,7,8,9 })
			, std::function<bool(int a, int b)>([](int a, int b) { return a % 3 == b % 3; }));

		for (int i = 0; i < 10; ++i)
		{
			GenericPartition().GroupSame(TestCase::RandVec<int>(20, 1, 10)
				, std::function<bool(int a, int b)>([](int a, int b) { return a % 3 == b % 3; }));
		}
	}
    {
        FindAnagramMappings().UseHashMap(std::vector<int>({12, 28, 46, 32, 50}), std::vector<int>({50, 12, 32, 46, 28}));
    }
    {
        SortByMinSwapPairsOf2Arrays().DFS(std::vector<int>({1,3,5,4}), std::vector<int>({1,2,3,7}));
        SortByMinSwapPairsOf2Arrays().DP(std::vector<int>({1,3,5,4}), std::vector<int>({1,2,3,7}));
        SortByMinSwapPairsOf2Arrays().DP2(std::vector<int>({1,3,5,4}), std::vector<int>({1,2,3,7}));
        SortByMinSwapPairsOf2Arrays().DFS(std::vector<int>({0,4,4,5,9}), std::vector<int>({0,1,6,8,10}));
        SortByMinSwapPairsOf2Arrays().DP(std::vector<int>({0,4,4,5,9}), std::vector<int>({0,1,6,8,10}));
        SortByMinSwapPairsOf2Arrays().DP2(std::vector<int>({0,4,4,5,9}), std::vector<int>({0,1,6,8,10}));
    }
    {
        OneSwapToSortedArr().Validate(std::vector<int>({3,4,5,1,6}));
        OneSwapToSortedArr().Validate(std::vector<int>({1,3,7,4}));
        OneSwapToSortedArr().Validate(std::vector<int>({3,4,5,6}));
        OneSwapToSortedArr().Validate(std::vector<int>({2,5,3,4}));
        OneSwapToSortedArr().Validate(std::vector<int>({2,5,3,6}));
        OneSwapToSortedArr().Validate(std::vector<int>({5,6,7,4}));
    }
    {
        MaxDropLToRIn1PeakValleyArr().BinarySearch(std::vector<int>({1,3,5,7,9,8,6,4,2,0}));
        MaxDropLToRIn1PeakValleyArr().BinarySearch(std::vector<int>({9,8,6,4,2,0,1,3,5,7}));
    }
    {
        SortArrWithMultiSortedSubArrs().MinHeap(std::vector<int>({7,1,3,5,2,4,6,0,9,7}));
    }
    {
        SortStringsWithNewAlphabet().SortString(std::string("zyxwvutsr"), std::string("xrxuvwztvxzyurz"));
        SortStringsWithNewAlphabet().SortStringArr(std::string("zyxwvutsr"), std::vector<std::string>({"suzwy","rux","yrwu","tyzvx","rt","xvyr","r","uv","vs","w","y","z"}));
    }
    {
        CutWoodsToKPiecesWSameLen().FindMaxLen_BinarySearch(std::vector<int>({232,124,456}), 7);
    }
    {
        PrintSeqInOrderFromUnorderedStream().Test(std::vector<int>({4,5,3,1,2}));
        PrintSeqInOrderFromUnorderedStream().Test(std::vector<int>({4,1,5,2,3}));
        PrintSeqInOrderFromUnorderedStream().Test(std::vector<int>({3,5,1,2,4}));
        PrintSeqInOrderFromUnorderedStream().Test(std::vector<int>({1,3,2,4,5}));
        //std::cout << std::endl;
        PrintSeqInOrderFromUnorderedStream_AllowRepeats().Test(std::vector<int>({4,5,3,4,1,5,2,1}));
        PrintSeqInOrderFromUnorderedStream_AllowRepeats().Test(std::vector<int>({4,1,4,4,5,1,2,3}));
        PrintSeqInOrderFromUnorderedStream_AllowRepeats().Test(std::vector<int>({3,5,1,2,5,4,1,2}));
        PrintSeqInOrderFromUnorderedStream_AllowRepeats().Test(std::vector<int>({7,8,5,3,4,4,5,2,1,2,6,3}));
        /*
        for (int i = 0; i < 10; ++i)
        {
            std::vector<int> v = TestCase::RandVec<int>(10, 1, 5);
            PrintSeqInOrderFromUnorderedStream_AllowRepeats().Test(v);
        }
        */

        for (int i = 0; i < 1; ++i)
        {
            PrintSeqInOrderFromUnorderedStream_AllowRepeats_ThreadSafe pat;
            pat.Run();
        }

    }
    {
        LoginCountFromUnorderedStream_PrefixSum s;
        s.Insert(2, 1);
        s.Insert(10, 1);
        s.Insert(5, 1);
        s.Insert(6, -1);
        s.Insert(20, -1);
        s.Insert(6, 1);
        s.Insert(13, -1);
        s.Insert(8, -1);
        s.Insert(11, 1);
        s.Insert(30, 1);
        s.Insert(40, 1);
        s.Insert(25, -1);
        s.Insert(50, -1);
        s.QueryLoginCount(45);
        s.QueryLoginCount(20);
        s.QueryLoginCount(70);
        s.QueryLoginCount(15);

        LoginCountFromUnorderedStream_BST bst;
        bst.Insert(2, 1);
        bst.Insert(10, 1);
        bst.Insert(5, 1);
        bst.Insert(6, -1);
        bst.Insert(20, -1);
        bst.Insert(6, 1);
        bst.Insert(13, -1);
        bst.Insert(8, -1);
        bst.Insert(11, 1);
        bst.Insert(30, 1);
        bst.Insert(40, 1);
        bst.Insert(25, -1);
        bst.Insert(50, -1);
        bst.QueryLoginCount(45);
        bst.QueryLoginCount(20);
        bst.QueryLoginCount(70);
        bst.QueryLoginCount(15);

        LoginCountFromUnorderedStream_PrefixSum_Map m;
        m.Insert(2, 1);
        m.Insert(10, 1);
        m.Insert(5, 1);
        m.Insert(6, -1);
        m.Insert(20, -1);
        m.Insert(6, 1);
        m.Insert(13, -1);
        m.Insert(8, -1);
        m.Insert(11, 1);
        m.Insert(30, 1);
        m.Insert(40, 1);
        m.Insert(25, -1);
        m.Insert(50, -1);
        m.QueryLoginCount(45);
        m.QueryLoginCount(20);
        m.QueryLoginCount(70);
        m.QueryLoginCount(15);
    }
    {
        EqualGlobalAndLocalInversions().Test(std::vector<int>({1,0,2}));
        EqualGlobalAndLocalInversions().Test(std::vector<int>({1,2,0}));
    }
    {
        MinimizeMaxDistToGasStation().MaxHeapGreedyAssign(std::vector<int>({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), 9);
        MinimizeMaxDistToGasStation().BinarySearch(std::vector<int>({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), 9);
    }
    {
        MaxNumPartitionsToSort().FromIdxSeqArr(std::vector<int>({1,0,2,3,4}));
        MaxNumPartitionsToSort().WithDuplicates(std::vector<int>({2,1,3,4,4}));
    }
    {
        MinCostHireKWorkers().SortAndMaxHeap(std::vector<int>({10,20,5}), std::vector<int>({70,50,30}),2);
    }
    {
        KClosest2DPointsToOrigin().Test(std::vector<std::vector<int>>({{3,3},{5,-1},{-2,4}}), 2);
    }
    {
        MonotonicArray().Valid(std::vector<int>({1,2,2,3}));
    }
    {
        MinFlip01StrToMonotoneIncr().PrefixSum("010110");
        MinFlip01StrToMonotoneIncr().DP("010110");
    }
    {
        RevealCardsInIncrOrder().ReverseProcessUseQueue(std::vector<int>({17,13,11,2,3,5,7}));
    }
    {
        MaxProfitAssignWork().SortplusTwoPtrs(std::vector<int>({2,4,6,8,10}), std::vector<int>({10,20,30,40,50}), std::vector<int>({4,5,6,7}));
    }
    {
        MinNumBoatsToSavePeople().SortGreedy(std::vector<int>({3,2,2,1}),3);
    }
    {
        for (int i = 1; i < 10; ++i)
            KthSmallestNumInMissingRangeOfSortedArr().BinarySearch(std::vector<int>({2,4,7,8,9,15}), i);
    }
    {
        PancakeSort().FindRevFrontArrSizeSeq(std::vector<int>({3,2,4,1}));
    }
    {
        MinCostScheduleHalfHalfTo2Cities().SortBySavings(std::vector<std::vector<int>>({{10,20},{30,200},{400,50},{30,20}}));
    }

#endif
#ifdef _Interval_
	/*Interval*/
	RdCout ? redirect_cout::to_file("Out_Interval.txt") : redirect_cout::to_cout();
	PrintH("Interval");
	{
		MergeIntervals().Merge(std::vector<MergeIntervals::Interval>(
		{ MergeIntervals::Interval(9, 11), MergeIntervals::Interval(5, 7), MergeIntervals::Interval(4, 6), MergeIntervals::Interval(1, 2), MergeIntervals::Interval(7, 8), MergeIntervals::Interval(3, 5) }));
		MergeIntervals().Merge_OpenClosedPoints(std::vector<std::pair<std::pair<int, bool>, std::pair<int, bool>>>(
		{ 
			{ { 2, true }, { 4, true } }, { { 8, true }, { 11, false } }, { { 13, false }, { 15, false } }, { { 16, false }, { 17, false } },
			{ { 1, true }, { 1, true } }, { { 3, true }, { 4, false } }, { { 7, true }, { 8, false } }, { { 12, false }, { 16, true } },
			{ { 0, false }, { 3, false } }, { { 5, true }, { 7, false } }, { { 9, false }, { 11, true } }, { { 12, true }, { 14, true } },
		}));

		InsertInterval().Insert(std::vector<std::pair<int, int>>({ { 1, 3 }, { 4, 6 }, { 7, 8 }, { 12, 14 }, { 17, 18 }, { 20, 24 } }), { 5, 19 });
		InsertInterval().Insert(std::vector<InsertInterval::Interval>(
		{ InsertInterval::Interval(1, 3), InsertInterval::Interval(4, 6), InsertInterval::Interval(7, 8), InsertInterval::Interval(12, 14), InsertInterval::Interval(17, 18), InsertInterval::Interval(20, 24) }),
		InsertInterval::Interval(5, 19));
	}
	{
	    //========[start,end]
		IntersectionOfIntervals().CountTotal(std::vector<int>({ 2, 2, 2, 1, 2, 2, 1 }));
		IntersectionOfIntervals().CountTotal(std::vector<int>({ 1, 5, 2, 1, 4, 0 }));

		IntersectionOfIntervals().CountMaxAtATime(std::vector<std::pair<int, int>>({ { -2, 2 }, { -1, 3 }, { 0, 4 }, { 2, 4 }, { 2, 6 }, { 3, 7 }, { 5, 7 } }));
		IntersectionOfIntervals().CountMaxAtATime(std::vector<std::pair<int, int>>({ { -4, 6 }, { -1, 1 }, { 0, 4 }, { 0, 8 }, { 2, 4 }, { 5, 5 } }));
		IntersectionOfIntervals().CountMaxAtATime(std::vector<std::pair<int, int>>({ { 10, 19 }, { 2, 10 } }));
        //========[start,end)
		IntersectionOfIntervals().CountMaxAtATimeII(std::vector<std::pair<int, int>>({ { -2, 2 },{ -1, 3 },{ 0, 4 },{ 2, 4 },{ 2, 6 },{ 3, 7 },{ 5, 7 } }));
		IntersectionOfIntervals().CountMaxAtATimeII(std::vector<std::pair<int, int>>({ { -4, 6 },{ -1, 1 },{ 0, 4 },{ 0, 8 },{ 2, 4 },{ 5, 5 } }));
		IntersectionOfIntervals().CountMaxAtATimeII(std::vector<std::pair<int, int>>({ { 10, 19 },{ 2, 10 } }));

        IntersectionOfIntervals().CountMaxAtATimeII_Simple(std::vector<std::pair<int, int>>({ { -2, 2 },{ -1, 3 },{ 0, 4 },{ 2, 4 },{ 2, 6 },{ 3, 7 },{ 5, 7 } }));
        IntersectionOfIntervals().CountMaxAtATimeII_Simple(std::vector<std::pair<int, int>>({ { -4, 6 },{ -1, 1 },{ 0, 4 },{ 0, 8 },{ 2, 4 },{ 5, 5 } }));
        IntersectionOfIntervals().CountMaxAtATimeII_Simple(std::vector<std::pair<int, int>>({ { 10, 19 },{ 2, 10 } }));
        IntersectionOfIntervals().CountMaxAtATimeII_Simple(std::vector<std::pair<int, int>>({ { 1, 10 },{ 2, 6 },{ 9, 12 },{ 14, 16 },{ 16, 17 } }));
	}
	{
		LeastPointsCoveringAllIntervals().TwoSortedSets(std::vector<std::pair<int, int>>({ { -2, 2 }, { -1, 3 }, { 0, 4 }, { 2, 4 }, { 2, 6 }, { 5, 7 } }));
		LeastPointsCoveringAllIntervals().Count_SortGreedy(std::vector<std::pair<int, int>>({ { -2, 2 },{ -1, 3 },{ 0, 4 },{ 2, 4 },{ 2, 6 },{ 5, 7 } }));
		LeastPointsCoveringAllIntervals().TwoSortedSets(std::vector<std::pair<int, int>>({ { -4, 6 }, { -1, 1 }, { 0, 4 }, { 0, 8 }, { 2, 4 }, { 5, 5 } }));
		LeastPointsCoveringAllIntervals().Count_SortGreedy(std::vector<std::pair<int, int>>({ { -4, 6 },{ -1, 1 },{ 0, 4 },{ 0, 8 },{ 2, 4 },{ 5, 5 } }));
	}
	{
		ViewFromAboveIntervals().SortedEndPoints(std::vector<std::pair<std::pair<int, int>, std::pair<int, int>>>(
		{
			{ { 0, 4 }, { 1, 101 } }, { { 5, 7 }, { 1, 102 } }, { { 9, 18 }, { 1, 103 } },
			{ { 2, 7 }, { 2, 104 } }, { { 8, 9 }, { 2, 105 } }, { { 12, 15 }, { 2, 106 } },
			{ { 1, 3 }, { 3, 107 } }, { { 6, 10 }, { 3, 108 } }, { { 11, 13 }, { 3, 109 } }, { { 14, 15 }, { 3, 120 } }, { { 16, 17 }, { 3, 121 } },
			{ { 4, 5 }, { 4, 122 } }, { { 19, 20 }, { 4, 123 } }
		}));
	}
	{
		DataStreamAsDisjointIntervals d;
		d.addNum(1);
		d.getIntervals();
		d.addNum(3);
		d.getIntervals();
		d.addNum(7);
		d.getIntervals();
		d.addNum(2);
		d.getIntervals();
		d.addNum(6);
		d.getIntervals();
	}
	{
		MinRemovalForNonOverlapIntervals().Greedy(std::vector<MinRemovalForNonOverlapIntervals::Interval>({ { 1,2 },{ 2,3 },{ 3,4 },{ 1,3 } }));
		MinRemovalForNonOverlapIntervals().Greedy2(std::vector<MinRemovalForNonOverlapIntervals::Interval>({ { 1,2 },{ 2,3 },{ 3,4 },{ 1,3 } }));
		MinRemovalForNonOverlapIntervals().Greedy(std::vector<MinRemovalForNonOverlapIntervals::Interval>({ { 1,2 },{ 1,2 },{ 1,2 } }));
		MinRemovalForNonOverlapIntervals().Greedy2(std::vector<MinRemovalForNonOverlapIntervals::Interval>({ { 1,2 },{ 1,2 },{ 1,2 } }));
		MinRemovalForNonOverlapIntervals().Greedy(std::vector<MinRemovalForNonOverlapIntervals::Interval>({ { 1,2 },{ 2,3 } }));
		MinRemovalForNonOverlapIntervals().Greedy2(std::vector<MinRemovalForNonOverlapIntervals::Interval>({ { 1,2 },{ 2,3 } }));
	}
	{
		FindRightInterval().Sort_BinarySearch(std::vector<FindRightInterval::Interval>({ { 1,2 } }));
		FindRightInterval().Sort_BinarySearch(std::vector<FindRightInterval::Interval>({ { 3,4 },{ 2,3 },{ 1,2 } }));
		FindRightInterval().Sort_BinarySearch(std::vector<FindRightInterval::Interval>({ { 1,4 },{ 2,3 },{ 3,4 } }));
	}
	{
		TeemoAttacking().FindPoisonedDuration(std::vector<int>({ 1,4 }), 2);
		TeemoAttacking().FindPoisonedDuration(std::vector<int>({ 1,2 }), 2);
	}
	{
		Heaters().MinRadius(std::vector<int>({ 1,2,3 }), std::vector<int>({ 2 }));
		Heaters().MinRadius(std::vector<int>({ 1,2,3,4 }), std::vector<int>({ 1,4 }));
	}
    {
        IntersectionOfListsOfIntervals().Linear(std::vector<std::pair<int,int>>({{0, 2}, {5, 10}, {13, 23}, {24, 25}}), std::vector<std::pair<int,int>>({{1, 5}, {8, 12}, {15, 18}, {20, 24}}));
        IntersectionOfListsOfIntervals().Linear(std::vector<std::pair<int,int>>({{1, 2}, {5, 7}}), std::vector<std::pair<int,int>>({{2, 6}}));
        IntersectionOfListsOfIntervals().Linear(std::vector<std::pair<int,int>>({{3, 8}, {100, 150}}), std::vector<std::pair<int,int>>({{2, 5}, {7, 10}}));
        IntersectionOfListsOfIntervals().Linear(std::vector<std::pair<int,int>>({{0, 4}, {7, 12}}), std::vector<std::pair<int,int>>({{1, 3}, {5, 8}, {9, 11}}));
    }
    {
        LeastNumOfIntervalsCoverRange().SortGreedy(std::vector<std::vector<int>>({{3,4},{2,7},{0,3},{4,6}}), 6);
        LeastNumOfIntervalsCoverRange().SortGreedy(std::vector<std::vector<int>>({{0,3},{4,7}}), 6);
        LeastNumOfIntervalsCoverRange().HashMap(std::vector<std::vector<int>>({{3,4},{2,7},{0,3},{4,6}}), 6);
        LeastNumOfIntervalsCoverRange().HashMap(std::vector<std::vector<int>>({{0,3},{4,7}}), 6);
        LeastNumOfIntervalsCoverRange().SortGreedy2(std::vector<std::pair<int,int>>({{3,4},{2,7},{0,3},{4,6}}), std::pair<int,int>({0,6}));
        LeastNumOfIntervalsCoverRange().SortGreedy2(std::vector<std::pair<int,int>>({{0,3},{4,7}}), std::pair<int,int>({0,6}));
        LeastNumOfIntervalsCoverRange().SortGreedy2(std::vector<std::pair<int,int>>({{3,4},{2,7},{0,3},{4,6}}), std::pair<int,int>({-1,6}));
    }
    {
        AddBoldTagInStrMergeInterval().MergeInterval(std::string("aaabbcc"), std::vector<std::string>({"aaa","aab","bc"}));
    }
    {
        FallingSquares().FindCurMaxHeights(std::vector<std::pair<int,int>>({{1,2},{2,3},{6,1}}));
    }
    {
        NonCoverredFromListsOfNonOvlpIntervals().MergeAndFind(std::vector<std::vector<NonCoverredFromListsOfNonOvlpIntervals::Interval>>(
                {
                        {NonCoverredFromListsOfNonOvlpIntervals::Interval(1, 2),NonCoverredFromListsOfNonOvlpIntervals::Interval(5, 6)},
                        {NonCoverredFromListsOfNonOvlpIntervals::Interval(1, 3)},
                        {NonCoverredFromListsOfNonOvlpIntervals::Interval(4, 10)},
                }));
        NonCoverredFromListsOfNonOvlpIntervals().MergeAndFind(std::vector<std::vector<NonCoverredFromListsOfNonOvlpIntervals::Interval>>(
                {
                        {NonCoverredFromListsOfNonOvlpIntervals::Interval(1, 3),NonCoverredFromListsOfNonOvlpIntervals::Interval(6, 7)},
                        {NonCoverredFromListsOfNonOvlpIntervals::Interval(2, 4)},
                        {NonCoverredFromListsOfNonOvlpIntervals::Interval(2, 5),NonCoverredFromListsOfNonOvlpIntervals::Interval(9, 12)},
                }));
    }
    {
        ExamRoom er(10);
        er.seat();
        er.seat();
        er.seat();
        er.seat();
        er.leave(4);
        er.seat();
    }

#endif
#ifdef _PermuteCombinePartition_
	/*Permute Combine Partition*/
	RdCout ? redirect_cout::to_file("Out_PermuteCombinePartition.txt") : redirect_cout::to_cout();
	PrintH("Permute Combine Partition");
	{
		Permutations().FindAll_FromNoDupArray_InPlace_Recur(&std::string("ABC")[0], 3);
		Permutations().FindAllUnique_FromDupArray_InPlace_Recur(&std::string("ABAB")[0], 4);

		Permutations2().FindAll_FromNoDupArray_InPlace_Iterate(std::vector<int>({ 2, 3, 1 }));
		Permutations2().FindAll_FromNoDupArray_InPlace_Recur(std::vector<int>({ 2, 3, 1 }));
		Permutations2().FindAllUnique_FromDupArray_InPlace_Iterate(std::vector<int>({ 1, 2, 1, 2 }));
		Permutations2().FindAllUnique_FromDupArray_InPlace_Recur(std::vector<int>({ 1, 2, 1, 2 }));

		Permutations2().FindAllUnique_FromDupArray_InPlace_Recur(std::vector<int>({ 2, 1, 3, 1, 2 }));
		Permutations2().Count_FromDupArray_Formula(std::vector<int>({ 2, 1, 3, 1, 2 }));
		
		Permutations2().FindAllUnique_FromDupArray_InPlace_Recur(std::vector<int>({ 1, 1, 1, 2, 2 }));//for UniquePath 4x3 grid

		Permutations2().FindAll_FromNoDupArray_InPlace_Iterate(std::vector<int>({ 1, 2, 3, 4 }));
		Permutations2().FindAll_FromNoDupArray_InPlace_Recur(std::vector<int>({ 1, 2, 3, 4 }));
	}
	{
		NextPermutation().Next(std::vector<int>({ 1, 2, 3 }));
		NextPermutation().Next(std::vector<int>({ 3, 2, 1 }));
		NextPermutation().Next(std::vector<int>({ 1, 1, 3 }));
		NextPermutation().Next(std::vector<int>({ 6, 2, 1, 5, 4, 3, 0 }));

		PreviousPermutation().InPlace(std::vector<int>({ 6, 2, 3, 0, 1, 4, 5 }));
		PreviousPermutation().InPlace(std::vector<int>({ 1, 3, 1 }));
		PreviousPermutation().InPlace(std::vector<int>({ 1, 2, 3 }));
		PreviousPermutation().InPlace(std::vector<int>({ 1, 3, 2 }));
	}
	{
		KthPermutationSequence().NextPermutationBased(4, 5);
		KthPermutationSequence().MathBased(4, 5);
		KthPermutationSequence().MathBased2(4, 5);
	}
	{
		Swap0ConvertPermutation().Count_BruteForce(std::vector<int>({ 0, 2, 3, 1, 4, 5, 9, 8, 7, 6 }), std::vector<int>({ 1, 0, 2, 3, 5, 4, 7, 9, 6, 8 }));
		Swap0ConvertPermutation().Count_Better(std::vector<int>({ 0, 2, 3, 1, 4, 5, 9, 8, 7, 6 }), std::vector<int>({ 1, 0, 2, 3, 5, 4, 7, 9, 6, 8 }));
		Swap0ConvertPermutation().Count_BruteForce_HashMap(std::vector<int>({ 0, 2, 3, 1, 4, 5, 9, 8, 7, 6 }), std::vector<int>({ 1, 0, 2, 3, 5, 4, 7, 9, 6, 8 }));
	}
	{
		Combinations().FindAll_FixRecur_NoRepeats(4, 2);
		Combinations().FindAll_InExcludeRecur_NoRepeats(4, 2);
		Combinations().FindAll_FixRecur_NoRepeats(4, 3);
		Combinations().FindAll_InExcludeRecur_NoRepeats(4, 3);
		Combinations().FindAll_Iterate_NoRepeats(7, 3);
		for (int i = 0; i <= 4; ++i)
		{
			Combinations().FindAll_FixRecur_NoRepeats(4, i);
		}
		Combinations().Count_NoRepeats_Formula(7, 3);
		Combinations().Count_NoRepeats_Formula(9, 5);
		Combinations().Count_NoRepeats_DP2D(7, 3);
		Combinations().Count_NoRepeats_DP2D(7, 7);
		Combinations().Count_NoRepeats_DP2D(9, 9);

		Combinations().FindAll_FixRecur_AllowRepeats(4, 3);
		Combinations().FindAll_InExcludeRecur_AllowRepeats(4, 3);
		Combinations().Count_AllowRepeats_Formula(7, 3);
		Combinations().Count_AllowRepeats_Formula(7, 7);
		Combinations().Count_AllowRepeats_Formula(9, 5);
		Combinations().Count_AllowRepeats_Formula(9, 9);
		Combinations().Count_AllowRepeats_DP2D(7, 7);
		Combinations().Count_AllowRepeats_DP2D(9, 9);

		Combinations2().Recur(std::vector<std::vector<std::string>>(
		{
			{ "quick", "medium", "slow" },
			{ "brown", "red", "silver" },
			{ "fox", "dog", "cat" },
		}));
	}
	{
		Subsets().FindAll_FromNoDupArray_FixReucr(std::vector<int>({ 8, 3, 7, 5 }));
		Subsets().FindAll_FromNoDupArray_InExcludeReucr(std::vector<int>({ 8, 3, 7, 5 }));
		Subsets().FindAll_FromNoDupArray_Iterate(std::vector<int>({ 8, 3, 7, 5 }));
		Subsets().FindAll_FromNoDupArray_Iterate_BitArray(std::vector<int>({ 8, 3, 7, 5 }));
		Subsets().FindAllUnique_FromDupArray_FixRecur(std::vector<int>({ 8, 3, 3, 5 }));
		Subsets().FindAllUnique_FromDupArray_InExcludeRecur(std::vector<int>({ 8, 3, 3, 5 }));
		Subsets().FindAllUnique_FromDupArray_Iterate(std::vector<int>({ 8, 3, 3, 5 }));
	}
	{
		CombinationSum().FindAllUnique_AllowRepeats_FromNoDupArray_FixRecur(std::vector<int>({ 10, 1, 2, 7, 6, 5, 9, 8 }), 8);
		CombinationSum().FindAllUnique_AllowRepeats_FromNoDupArray_InExcludeRecur(std::vector<int>({ 10, 1, 2, 7, 6, 5, 9, 8 }), 8);
		CombinationSum().FindAllUnique_NoRepeats_FromDupArray_FixRecur(std::vector<int>({ 10, 1, 2, 7, 6, 1, 5, 9, 8 }), 8);
		CombinationSum().FindAllUnique_NoRepeats_FromDupArray_InExcludeRecur(std::vector<int>({ 10, 1, 2, 7, 6, 1, 5, 9, 8 }), 8);
		CombinationSum().NumOfWays_AllowRepeats_FromNoDupArray_Recur(std::vector<int>({ 10, 1, 2, 7, 6, 5, 9, 8 }), 8);
		CombinationSum().NumOfWays_NoRepeats_FromDupArray_Recur(std::vector<int>({ 10, 1, 2, 7, 6, 1, 5, 9, 8 }), 8);
		CombinationSum().NumOfWays_AllowRepeats_FromNoDupArray_DP2D(std::vector<int>({ 1, 2, 5, 6, 7, 8, 9, 10 }), 8);
		CombinationSum().NumOfWays_AllowRepeats_FromNoDupArray_DP1D(std::vector<int>({ 1, 2, 5, 6, 7, 8, 9, 10 }), 8);
		CombinationSum().NumOfDistinctOrderWays_AllowRepeats_FromNoDupArray_DP1D(std::vector<int>({ 1 }), 8);
		CombinationSum().NumOfDistinctOrderWays_AllowRepeats_FromNoDupArray_DP1D(std::vector<int>({ 1, 2 }), 8);
		CombinationSum().NumOfDistinctOrderWays_AllowRepeats_FromNoDupArray_DP1D(std::vector<int>({ 1, 2, 5 }), 8);
		CombinationSum().NumOfDistinctOrderWays_AllowRepeats_FromNoDupArray_DP1D(std::vector<int>({ 1, 2, 5, 6 }), 8);
		CombinationSum().NumOfDistinctOrderWays_AllowRepeats_FromNoDupArray_DP1D(std::vector<int>({ 1, 2, 5, 6, 7 }), 8);
		CombinationSum().NumOfDistinctOrderWays_AllowRepeats_FromNoDupArray_DP1D(std::vector<int>({ 1, 2, 5, 6, 7, 8 }), 8);
		CombinationSum().NumOfDistinctOrderWays_AllowRepeats_FromNoDupArray_DP1D(std::vector<int>({ 1, 2, 5, 6, 7, 8, 9 }), 8);
		CombinationSum().NumOfDistinctOrderWays_AllowRepeats_FromNoDupArray_DP1D(std::vector<int>({ 1, 2, 5, 6, 7, 8, 9, 10 }), 8);
		CombinationSum().NumOfDistinctOrderWays_AllowRepeats_From1tok_DP1D(2, 4);
		CombinationSum().NumOfWays_NoRepeats_FromDupArray_DP2D(std::vector<int>({ 1, 1, 2, 5, 6, 7, 8, 9, 10 }), 8);
		CombinationSum().NumOfWays_NoRepeats_FromDupArray_DP2D_DistinguishDups(std::vector<int>({ 1, 1, 2, 5, 6, 7, 8, 9, 10 }), 8);
		CombinationSum().NumOfWays_NoRepeats_FromDupArray_DP1D_DistinguishDups(std::vector<int>({ 1, 1, 2, 5, 6, 7, 8, 9, 10 }), 8);
		CombinationSum().NumOfDistinctOrderWays_NoRepeats_FromDupArray_DP1D_DistinguishDups(std::vector<int>({ 1, 1, 2, 5, 6, 7, 8, 9, 10 }), 8);
		CombinationSum().NumOfWays_NoRepeats_FromDupArray_DP2D(std::vector<int>({ 1, 2, 5, 6, 7, 8, 9, 10 }), 8);
		CombinationSum().NumOfWays_NoRepeats_FromDupArray_DP2D_DistinguishDups(std::vector<int>({ 1, 2, 5, 6, 7, 8, 9, 10 }), 8);
		CombinationSum().NumOfWays_NoRepeats_FromDupArray_DP1D_DistinguishDups(std::vector<int>({ 1, 2, 5, 6, 7, 8, 9, 10 }), 8);
		CombinationSum().NumOfDistinctOrderWays_NoRepeats_FromDupArray_DP1D_DistinguishDups(std::vector<int>({ 1, 2, 5, 6, 7, 8, 9, 10 }), 8);
		std::cout << "===" << std::endl;
		CombinationSum().FindAllUnique_NoRepeats_FromDupArray_FixRecur(std::vector<int>({ 10, 1, 2, 7, 3, 2, 6, 2, 1, 5, 9, 8, 3 }), 8);
		CombinationSum().FindAllUnique_NoRepeats_FromDupArray_InExcludeRecur(std::vector<int>({ 10, 1, 2, 7, 3, 2, 6, 2, 1, 5, 9, 8, 3 }), 8);
		CombinationSum().NumOfWays_NoRepeats_FromDupArray_Recur(std::vector<int>({ 10, 1, 2, 7, 3, 2, 6, 2, 1, 5, 9, 8, 3 }), 8);
		CombinationSum().NumOfWays_NoRepeats_FromDupArray_DP2D(std::vector<int>({ 1, 1, 2, 2, 2, 3, 3, 5, 6, 7, 8, 9, 10 }), 8);
		CombinationSum().NumOfWays_NoRepeats_FromDupArray_DP2D_DistinguishDups(std::vector<int>({ 1, 1, 2, 2, 2, 3, 3, 5, 6, 7, 8, 9, 10 }), 8);
		CombinationSum().NumOfWays_NoRepeats_FromDupArray_DP1D_DistinguishDups(std::vector<int>({ 1, 1, 2, 2, 2, 3, 3, 5, 6, 7, 8, 9, 10 }), 8);
		CombinationSum().NumOfDistinctOrderWays_NoRepeats_FromDupArray_DP1D_DistinguishDups(std::vector<int>({ 1, 1, 2, 2, 2, 3, 3, 5, 6, 7, 8, 9, 10 }), 8);
		std::cout << "===" << std::endl;
		CombinationSum().FindAllUnique_NoRepeats_FromDupArray_FixRecur(std::vector<int>({ 10, 1, 3, 2, 7, 3, 2, 6, 3, 4, 2, 4, 1, 5, 9, 8, 3, 4 }), 12);
		CombinationSum().FindAllUnique_NoRepeats_FromDupArray_InExcludeRecur(std::vector<int>({ 10, 1, 3, 2, 7, 3, 2, 6, 3, 4, 2, 4, 1, 5, 9, 8, 3, 4 }), 12);
		CombinationSum().NumOfWays_NoRepeats_FromDupArray_Recur(std::vector<int>({ 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9, 10 }), 12);
		CombinationSum().NumOfWays_NoRepeats_FromDupArray_DP2D(std::vector<int>({ 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9, 10 }), 12);
		CombinationSum().NumOfWays_NoRepeats_FromDupArray_DP2D_DistinguishDups(std::vector<int>({ 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9, 10 }), 12);
		CombinationSum().NumOfWays_NoRepeats_FromDupArray_DP1D_DistinguishDups(std::vector<int>({ 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9, 10 }), 12);
		CombinationSum().NumOfDistinctOrderWays_NoRepeats_FromDupArray_DP1D_DistinguishDups(std::vector<int>({ 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9, 10 }), 12);
		std::cout << "===" << std::endl;

		CombinationSum().MinCoins_AllowRepeats_FromNoDupArray_DP2D(std::vector<int>({ 5, 1, 25, 20, 10 }), 40);
		CombinationSum().MinCoins_AllowRepeats_FromNoDupArray_DP1D(std::vector<int>({ 5, 1, 25, 20, 10 }), 40);
		CombinationSum().MinCoins_AllowRepeats_FromNoDupArray_DP2D(std::vector<int>({ 5, 1, 25, 20, 10 }), 52);
		CombinationSum().MinCoins_AllowRepeats_FromNoDupArray_DP1D(std::vector<int>({ 5, 1, 25, 20, 10 }), 52);
		CombinationSum().MinCoins_NoRepeats_FromDupArray_DP2D(std::vector<int>({ 5, 1, 25, 25, 20, 5, 10, 10, 10, 1, 20 }), 40);
		CombinationSum().MinCoins_NoRepeats_FromDupArray_DP1D(std::vector<int>({ 5, 1, 25, 25, 20, 5, 10, 10, 10, 1, 20 }), 40);
		CombinationSum().MinCoins_NoRepeats_FromDupArray_DP2D(std::vector<int>({ 5, 1, 25, 25, 20, 5, 10, 10, 10, 1, 20 }), 52);
		CombinationSum().MinCoins_NoRepeats_FromDupArray_DP1D(std::vector<int>({ 5, 1, 25, 25, 20, 5, 10, 10, 10, 1, 20 }), 52);
		std::cout << "===" << std::endl;

		CombinationSum().MinCost_AllowRepeats_FromNoDupArray_DP2D(std::vector<int>({ 1,7,30 }), std::vector<int>({ 20,125,510 }), 30);
		CombinationSum().MinCost_AllowRepeats_FromNoDupArray_DP1D(std::vector<int>({ 1,7,30 }), std::vector<int>({ 20,125,510 }), 30);
		CombinationSum().MinCost_NoRepeats_FromDupArray_DP2D(std::vector<int>({ 1,1,1,1,1,1,1,1,1,7,7,7,7,30 }), std::vector<int>({ 20,20,20,20,20,20,20,20,20,125,125,125,125,510 }), 30);
		CombinationSum().MinCost_NoRepeats_FromDupArray_DP1D(std::vector<int>({ 1,1,1,1,1,1,1,1,1,7,7,7,7,30 }), std::vector<int>({ 20,20,20,20,20,20,20,20,20,125,125,125,125,510 }), 30);
		CombinationSum().MinCost_AllowRepeats_FromNoDupArray_DP2D(std::vector<int>({ 1,7,17,27,30 }), std::vector<int>({ 178,1236,2995,4790,5330 }), 30);//minCost=17*1+7*1+1*6
		CombinationSum().MinCost_AllowRepeats_FromNoDupArray_DP1D(std::vector<int>({ 1,7,17,27,30 }), std::vector<int>({ 178,1236,2995,4790,5330 }), 30);//minCost=17*1+7*1+1*6
		CombinationSum().MinCost_NoRepeats_FromDupArray_DP2D(std::vector<int>({ 1,1,1,1,1,1,7,7,7,7,17,17,27,30 }), std::vector<int>({ 178,178,178,178,178,178,1236,1236,1236,1236,2995,2995,4790,5330 }), 30);//minCost=17*1+7*1+1*6
		CombinationSum().MinCost_NoRepeats_FromDupArray_DP1D(std::vector<int>({ 1,1,1,1,1,1,7,7,7,7,17,17,27,30 }), std::vector<int>({ 178,178,178,178,178,178,1236,1236,1236,1236,2995,2995,4790,5330 }), 30);//minCost=17*1+7*1+1*6


		SubsetSumProblem().Recur(std::vector<int>({ 10, 1, 2, 7, 6, 5, 9, 8 }), 8);
		SubsetSumProblem().DP2D(std::vector<int>({ 10, 1, 2, 7, 6, 5, 9, 8 }), 8);

		CombinationPrimeSum1toN().NumOfWays_NoRepeats_DP2D(6);

		for (int i = 0; i < 2; ++i)
		{
			std::vector<int> v = TestCase::RandVec(10, 1, 20);
			int targetSum = TestCase::RandNum(40, 60);
			int K = TestCase::RandNum(4, 6);
			KSum().TwoSum_FixRecur(v, targetSum, K);
			KSum().FindAllUnique_NoRepeats_FromDupArray_FixRecur(v, targetSum, K);
			KSum().FindAllUnique_NoRepeats_FromDupArray_InExcludeRecur(v, targetSum, K);
		}
	}
	{
		DiceCombinationSum().NumOfWays_DP2D(2, 6, 10);
		DiceCombinationSum().NumOfWays_DP2D(2, 6, 5);
		DiceCombinationSum().NumOfWays_DP2D(2, 6, 1);
		DiceCombinationSum().NumOfWays_Recur(2, 6, 10);
        DiceCombinationSum().NumOfWays_Recur(2, 6, 5);
        DiceCombinationSum().NumOfWays_Recur(2, 6, 1);
	}
	{
		FactorCombinations().Recur(1);
		FactorCombinations().Recur(37);
		FactorCombinations().Recur(12);
		FactorCombinations().Recur(32);
	}
	{
		ParenthesesCombination().GenRecur(3);
	}
	{
		LetterCombinationPhoneNum().Recur(std::string("232"));
		LetterCombinationPhoneNum().Iterate(std::string("232"));
	}
	{
		RestoreIPAddress().Recur(std::string("25525511135"));
		RestoreIPAddress().Iterate(std::string("25525511135"));
	}
	{
		DecodeWays().DP1D_Iterate(std::string("1261345723452912364512"));
		DecodeWays().DP_Iterate(std::string("1261345723452912364512"));
		DecodeWays().DP1D_Recur(std::string("1261345723452912364512"));
		DecodeWays().FindAllRecur(std::string("1123"));
		//DecodeWays().DP_Iterate(std::string("101126"));
		//DecodeWays().DP_Iterate(std::string("101110"));
	}
	{
		Knapsack().MaxVal_NoRepeats_Recur(&std::vector<int>({ 2, 1, 3, 2 })[0], &std::vector<int>({ 3, 2, 4, 2 })[0], 4, 5);
		Knapsack().MaxVal_NoRepeats_DP2D(&std::vector<int>({ 2, 1, 3, 2 })[0], &std::vector<int>({ 3, 2, 4, 2 })[0], 4, 5);
		Knapsack().MaxVal_AllowRepeats_DP2D(&std::vector<int>({ 3, 4, 2 })[0], &std::vector<int>({ 4, 5, 3 })[0], 3, 7);
		Knapsack().MaxVal_NoRepeats_DP1D(&std::vector<int>({ 2, 1, 3, 2 })[0], &std::vector<int>({ 3, 2, 4, 2 })[0], 4, 5);
		Knapsack().MaxVal_AllowRepeats_DP1D(&std::vector<int>({ 3, 4, 2 })[0], &std::vector<int>({ 4, 5, 3 })[0], 3, 7);

		FractionalKnapsack().Greedy(std::vector<std::pair<double, double>>({ { 2.0, 140 }, { 3.0, 240 }, { 5.0, 150.0 }, { 1.0, 200.0 } }), 5.0);
	}
	{
		MatrixChainMultiplication().Recur(std::vector<int>({ 40, 20, 30, 10, 30 }));
		MatrixChainMultiplication().DP2D(std::vector<int>({ 40, 20, 30, 10, 30 }));

		MaxVerticesSumOfPolygon().DP2D(std::vector<int>({ -2, 3, 2, 4, -8, 5 }), std::vector<int>({ 1, 0, 1, 1, 0, 1 }));//0: +, 1: *
		//MaxVerticesSumOfPolygon().DP2D(std::vector<int>({ -8, 4, 2, 3, -2, 5 }), std::vector<int>({ 1, 1, 0, 1, 1, 0 }));//0: +, 1: *
		MaxVerticesSumOfPolygon().DP2D(std::vector<int>({ -8, 2, -3, 5 }), std::vector<int>({ 1, 0, 1, 0 }));
		MaxVerticesSumOfPolygon().DP2D(std::vector<int>({ 1, 2, -2, 3 }), std::vector<int>({ 0, 1, 1, 0 }));
		MaxVerticesSumOfPolygon().DP2D(std::vector<int>({ 1, 2, 6 }), std::vector<int>({ 1, 1, 0 }));//max(12, 14, 14)
		MaxVerticesSumOfPolygon().DP2D(std::vector<int>({ 1, 2, 6 }), std::vector<int>({ 1, 0, 0 }));//max(8, 9, 14)
		MaxVerticesSumOfPolygon().DP2D(std::vector<int>({ 2, 6 }), std::vector<int>({ 1, 0 }));//max(8, 12)


		MaxSumParenthesizeArithmeticExpr().DP2D(std::vector<int>({ -8, 4, 2, 3, -2, 5 }), std::vector<int>({ 1, 1, 0, 1, 1 }));
		MaxSumParenthesizeArithmeticExpr().DP2D(std::vector<int>({ -8, 2, -3, 5 }), std::vector<int>({ 1, 0, 1 }));

		MinCostPolygonTriangulation().Recur(std::vector<std::pair<int, int>>({ std::make_pair(0, 0), std::make_pair(1, 0), std::make_pair(2, 1), std::make_pair(1, 2), std::make_pair(0, 2) }));
		MinCostPolygonTriangulation().DP2D(std::vector<std::pair<int, int>>({ std::make_pair(0, 0), std::make_pair(1, 0), std::make_pair(2, 1), std::make_pair(1, 2), std::make_pair(0, 2) }));
	}
	{
		ParenthesizeBoolExpr().CountRecur(std::string("1|1&0^0"), true);
		ParenthesizeBoolExpr().Count_DP2D_Recur(std::string("1|1&0^0"), true);
		ParenthesizeBoolExpr().Count_DP2D_Recur(std::string("1|1&0^0"), false);
	}
	{
		SynthesizeExpression().Recur(std::string("123"), 6);
        SynthesizeExpression().BetterRecur(std::string("123"), 6);
        SynthesizeExpression().BestRecur(std::string("123"), 6);
		SynthesizeExpression().Recur(std::string("232"), 8);
        SynthesizeExpression().BetterRecur(std::string("232"), 8);
        SynthesizeExpression().BestRecur(std::string("232"), 8);
		SynthesizeExpression().Recur(std::string("105"), 5);
        SynthesizeExpression().BetterRecur(std::string("105"), 5);
        SynthesizeExpression().BestRecur(std::string("105"), 5);
		SynthesizeExpression().Recur(std::string("00"), 0);
        SynthesizeExpression().BetterRecur(std::string("00"), 0);
        SynthesizeExpression().BestRecur(std::string("00"), 0);
		//SynthesizeExpression().Recur(std::string("2147483647"), 2147483647);


        SynthesizeExpressionEquation().Solve(std::string("738=497"));
	}
	{
		PaintersPartitionFairWorkload().BruteForce_Recur(std::vector<int>({ 10, 20, 30, 40, 50, 60, 70, 80, 90 }), 5);
		PaintersPartitionFairWorkload().DP2D_Recur(std::vector<int>({ 10, 20, 30, 40, 50, 60, 70, 80, 90 }), 5);
		PaintersPartitionFairWorkload().DP2D_Iterate(std::vector<int>({ 10, 20, 30, 40, 50, 60, 70, 80, 90 }), 5);
		PaintersPartitionFairWorkload().BinarySearchGreedyPartition(std::vector<int>({ 10, 20, 30, 40, 50, 60, 70, 80, 90 }), 5);
		PaintersPartitionFairWorkload().BinarySearchGreedyPartition2(std::vector<int>({ 10, 20, 30, 40, 50, 60, 70, 80, 90 }), 5);

		PaintersPartitionFairWorkload().BruteForce_Recur(std::vector<int>({ 70, 10, 20, 40, 80, 30, 50, 90, 60 }), 5);
		PaintersPartitionFairWorkload().DP2D_Recur(std::vector<int>({ 70, 10, 20, 40, 80, 30, 50, 90, 60 }), 5);
		PaintersPartitionFairWorkload().DP2D_Iterate(std::vector<int>({ 70, 10, 20, 40, 80, 30, 50, 90, 60 }), 5);
		PaintersPartitionFairWorkload().BinarySearchGreedyPartition(std::vector<int>({ 70, 10, 20, 40, 80, 30, 50, 90, 60 }), 5);
		PaintersPartitionFairWorkload().BinarySearchGreedyPartition2(std::vector<int>({ 70, 10, 20, 40, 80, 30, 50, 90, 60 }), 5);

		PaintersPartitionFairWorkload().BruteForce_Recur(std::vector<int>({ 568, 712, 412, 231, 241, 393, 865, 287, 128, 457, 238, 98, 980, 23, 782 }), 4);
		PaintersPartitionFairWorkload().DP2D_Recur(std::vector<int>({ 568, 712, 412, 231, 241, 393, 865, 287, 128, 457, 238, 98, 980, 23, 782 }), 4);
		PaintersPartitionFairWorkload().DP2D_Iterate(std::vector<int>({ 568, 712, 412, 231, 241, 393, 865, 287, 128, 457, 238, 98, 980, 23, 782 }), 4);
		PaintersPartitionFairWorkload().BinarySearchGreedyPartition(std::vector<int>({ 568, 712, 412, 231, 241, 393, 865, 287, 128, 457, 238, 98, 980, 23, 782 }), 4);
		PaintersPartitionFairWorkload().BinarySearchGreedyPartition2(std::vector<int>({ 568, 712, 412, 231, 241, 393, 865, 287, 128, 457, 238, 98, 980, 23, 782 }), 4);

		std::vector<int> v(TestCase::RandVec(10, 10, 90));
		PaintersPartitionFairWorkload().BruteForce_Recur(v, 5);
		PaintersPartitionFairWorkload().DP2D_Recur(v, 5);
		PaintersPartitionFairWorkload().DP2D_Iterate(v, 5);
		PaintersPartitionFairWorkload().BinarySearchGreedyPartition(v, 5);
		PaintersPartitionFairWorkload().BinarySearchGreedyPartition2(v, 5);

		MinMaxSubarrSumToPartitionKSubarr().BinarySearch(std::vector<int>({1,2,3,4,5,6,7,8,9,10}),5);
		MaxMinSubarrSumToPartitionKSubarr().BinarySearch(std::vector<int>({1,2,3,4,5,6,7,8,9}),5);
	}
	{
		Fair2TaskAssignment().Partition(std::vector<int>({ 18, 3, 12, 9, 7, 17, 4, 11, 14, 20, 5, 1, 8, 15, 6, 10, 13, 16, 19, 2 }));
	}
	{
		BalancedPartitionWMin2SumDiff().DP1D(std::vector<int>({ 9, 16, 1, 4 }));//[1 4 9][16]
		BalancedPartitionWMin2SumDiff().DP1D(std::vector<int>({ 1, 5, 9, 3, 8 }));//[1 9 3][5 8]
		BalancedPartitionWMin2SumDiff().DP1D(std::vector<int>({ 1, 2, 3, 5, 10 }));//[1 2 3 5][10]
		BalancedPartitionWMin2SumDiff().DP1D(std::vector<int>({ 2, 10, 3, 8, 5, 7, 9, 5, 3, 2 }));//[2 5 3 10 7][2 5 3 9 8]

		BalancedPartitionWMin2SumDiff().EqualSized_Recur(std::vector<int>({ 9, 16, 1, 4 }));
		BalancedPartitionWMin2SumDiff().EqualSized_Recur(std::vector<int>({ 1, 5, 9, 3, 8 }));
		BalancedPartitionWMin2SumDiff().EqualSized_Recur(std::vector<int>({ 1, 2, 3, 5, 10 }));
		BalancedPartitionWMin2SumDiff().EqualSized_Recur(std::vector<int>({ 2, 10, 3, 8, 5, 7, 9, 5, 3, 2 }));
		BalancedPartitionWMin2SumDiff().EqualSized_Recur(std::vector<int>({ 425, 180, 120, 110, 5, 4, 2, 1 }));
		BalancedPartitionWMin2SumDiff().EqualSized_Recur(std::vector<int>({ 3 }));
	}
	{
		BalancedPartitionWEqual2Sum().Recur(std::vector<int>({ 3, 1, 5, 9, 12 }));//[3 12][1 5 9]
		BalancedPartitionWEqual2Sum().Recur(std::vector<int>({ 1, 5, 11, 5 }));//[1 5 5][11]
		BalancedPartitionWEqual2Sum().Recur(std::vector<int>({ 1, 5, 3 }));

		BalancedPartitionWEqual2Sum().DP2D(std::vector<int>({ 3, 1, 5, 9, 12 }));//[3 12][1 5 9]
		BalancedPartitionWEqual2Sum().DP2D(std::vector<int>({ 1, 5, 11, 5 }));//[1 5 5][11]
		BalancedPartitionWEqual2Sum().DP2D(std::vector<int>({ 1, 5, 3 }));
	}
	{
		BinPacking().MinCount_DP3D(5, 3, 3, 5, 2, 7, 10);//5�� for size of 3, 3�� for size of 5, 2�� for size of 7, capacity of bin is 10
		BinPacking().MinCount_DP3D(1, 2, 1, 3, 1, 4, 5);//1�� for size of 2, 1�� for size of 3, 1�� for size of 4, capacity of bin is 5
	}
	{
		BinPacking2().Valid_EnumerateAll_Recur(std::vector<int>({ 2, 3, 4 }), std::vector<int>({ 4, 5 }));
		BinPacking2().Valid_EnumerateAll_Recur(std::vector<int>({ 2, 3, 5 }), std::vector<int>({ 4, 5 }));
		BinPacking2().Valid_EnumerateAll_Recur(std::vector<int>({ 18, 4, 8, 4, 6, 6, 8, 8 }), std::vector<int>({ 8, 16, 8, 32 }));

		BinPacking2().MinBin_EnumerateAll_Recur(std::vector<int>({ 2, 3, 4 }), std::vector<int>({ 4, 5 }));
		BinPacking2().MinBin_EnumerateAll_Recur(std::vector<int>({ 2, 3, 5 }), std::vector<int>({ 4, 5 }));
		BinPacking2().MinBin_EnumerateAll_Recur(std::vector<int>({ 18, 4, 8, 4, 6, 6, 8, 8 }), std::vector<int>({ 8, 16, 8, 32 }));
	}
	{
		AllSubArrayPartitions().Generate(std::vector<int>({ 1, 2, 3, 4, 5, 6 }));
	}
	{
		MinNonSubsetSumSortedArray().Find(std::vector<int>({ 1, 1, 3, 4 }));
		MinNonSubsetSumSortedArray().Find2(std::vector<int>({ 1, 1, 3, 4 }));
		MinNonSubsetSumSortedArray().Find(std::vector<int>({ 1, 2, 5, 10 }));
		MinNonSubsetSumSortedArray().Find2(std::vector<int>({ 1, 2, 5, 10 }));
	}
	{
		MeasureWithDefectiveJugs().FindAllUnique_AllowRepeats_FromNoDupArr_FixRecur(std::vector<std::pair<int, int>>({ { 230, 240 }, { 290, 310 }, { 500, 515 } }), 2100, 2300);
		MeasureWithDefectiveJugs().FindAllUnique_AllowRepeats_FromNoDupArr_InExcludeRecur(std::vector<std::pair<int, int>>({ { 230, 240 }, { 290, 310 }, { 500, 515 } }), 2100, 2300);

		MeasureWithDefectiveJugs().CheckFeasible(std::vector<std::pair<int, int>>({ { 230, 240 }, { 290, 310 }, { 500, 515 } }), 2100, 2300);
	}
	{
		MonotoneDecimalNums().Count_DP2D(10);
		MonotoneDecimalNums().EnumerateAll_AllowRepeats_Recur(3);

		StricklyMonotoneDecimalNums().Count_DP2D(3);
		StricklyMonotoneDecimalNums().EnumerateAll_NoRepeats_Recur(3);
	}
	{
		FirstFitPacking().Solve(TestCase::RandVec<double>(20, 5.0, 20.0), 20);
		FirstFitPacking().Solve(std::vector<double>({ 1.0, 2.0, 4.0, 3.0 }), 5);
		FirstFitPacking().Solve(std::vector<double>({ 1.0, 1.0, 1.0, 1.0, 4.0, 3.0, 2.0, 2.0 }), 5);
	}
	{
		MaxPermutedConcatNum().BySort(std::vector<int>({ 3, 30, 34, 5, 9 }));
		MaxPermutedConcatNum().BySort(std::vector<int>({ 12, 121 }));
	}
	{
		MinSumOf2IntFromADigitArr().Sort_And_Alternate(std::vector<int>({ 1, 2, 7, 8, 9 }));
		MinSumOf2IntFromADigitArr().Sort_And_Alternate(std::vector<int>({ 6, 4, 6, 0, 1, 4, 8, 7, 3 }));
	}
	{
		MaxProductCutting().Recur(10);
		MaxProductCutting().DP1D_Recur(10);
		MaxProductCutting().DP1D_Iterate(10);
		MaxProductCutting().Tricky(10);

		//MaxProductCutting().Recur(40);//too slow
		//MaxProductCutting().DP1D_Recur(40);//too slow
		MaxProductCutting().DP1D_Iterate(40);
		MaxProductCutting().Tricky(40);

		MaxPriceCutting().Recur(std::vector<int>({ 1, 5, 8, 9, 10, 17, 17, 20 }), 8);
		MaxPriceCutting().DP1D_Recur(std::vector<int>({ 1, 5, 8, 9, 10, 17, 17, 20 }), 8);
		MaxPriceCutting().DP1D_Iterate(std::vector<int>({ 1, 5, 8, 9, 10, 17, 17, 20 }), 8);

		MaxPriceCutting().Recur(std::vector<int>({ 3, 5, 18, 9, 10, 17, 17, 20 }), 8);
		MaxPriceCutting().DP1D_Recur(std::vector<int>({ 3, 5, 18, 9, 10, 17, 17, 20 }), 8);
		MaxPriceCutting().DP1D_Iterate(std::vector<int>({ 3, 5, 18, 9, 10, 17, 17, 20 }), 8);
	}
    {
        MaxPriceCutting2().DFSRecur(1, 10, std::vector<int>({26,103,59}));
        MaxPriceCutting2().DFSRecur(100, 10, std::vector<int>({26,103,59}));
        MaxPriceCutting2().DFSRecur(1, 10, std::vector<int>({30,59,110}));
    }
	{
		AllBinaryStrWithWildCard().Recur(std::string("1?00?101"));
	}
	{
		std::unordered_set<std::string> wordBreakDict;
		wordBreakDict.insert("cat");
		wordBreakDict.insert("cats");
		wordBreakDict.insert("and");
		wordBreakDict.insert("sand");
		wordBreakDict.insert("dog");
		WordBreak().CanBreak_Recur("catsanddog", wordBreakDict);
		WordBreak().CanBreak_DP1D("catsanddog", wordBreakDict);
		WordBreak().CanBreak_FindOne_DP1D("catsanddog", wordBreakDict);
		WordBreak().FindAllBreaks_DP2D("catsanddog", wordBreakDict);
		WordBreak().FindAllBreaks_DP2D_Recur("catsanddog", wordBreakDict);
		std::unordered_set<std::string> wordBreakDict2;
		wordBreakDict2.insert("hot");
		wordBreakDict2.insert("dog");
		wordBreakDict2.insert("hotdog");
		wordBreakDict2.insert("pop");
		wordBreakDict2.insert("corn");
		wordBreakDict2.insert("po");
		wordBreakDict2.insert("pc");
		wordBreakDict2.insert("orn");
		wordBreakDict2.insert("popcorn");
		WordBreak().CanBreak_Recur("hotdogpopcorn", wordBreakDict2);
		WordBreak().CanBreak_DP1D("hotdogpopcorn", wordBreakDict2);
		WordBreak().CanBreak_FindOne_DP1D("hotdogpopcorn", wordBreakDict2);
		WordBreak().FindAllBreaks_DP2D("hotdogpopcorn", wordBreakDict2);
		WordBreak().FindAllBreaks_DP2D_Recur("hotdogpopcorn", wordBreakDict2);
	}
	{
		LongestWordMadeOfOthers().Solve_DP(std::vector<std::string>(
		{
			"cat", "cats", "catsdogcats", "catxdogcatsrat", "dog", "dogcatsdog", "hippopotamuses", "rat", "ratcatdogcat"
		}));
	}
	{
		ParenthesizeArithmeticExpr().EnumerateAll(std::string("1+2+3"));
		ParenthesizeArithmeticExpr().EnumerateAll(std::string("2-1-1"));
		ParenthesizeArithmeticExpr().EnumerateAll(std::string("2*3-4*5"));
	}
	{
		PaintHouseCombinations().DP2D_3Color(std::vector<std::vector<int>>(
		{
			{ 5,8,6 },
			{ 19,14,13 },
			{ 7,5,12 },
			{ 14,15,17 },
			{ 3,20,10 },
		}));
		PaintHouseCombinations().DP2D_KColor(std::vector<std::vector<int>>(
		{
			{ 5,8,6 },
			{ 19,14,13 },
			{ 7,5,12 },
			{ 14,15,17 },
			{ 3,20,10 },
		}));
		PaintHouseCombinations().DP1D_KColor(std::vector<std::vector<int>>(
		{
			{ 5,8,6 },
			{ 19,14,13 },
			{ 7,5,12 },
			{ 14,15,17 },
			{ 3,20,10 },
		}));
		PaintHouseCombinations().BestTime_KColor(std::vector<std::vector<int>>(
		{
			{ 5,8,6 },
			{ 19,14,13 },
			{ 7,5,12 },
			{ 14,15,17 },
			{ 3,20,10 },
		}));
	}
	{
		PaintFenceCombinations().ConstSpace(3, 3);
	}
	{
		for (int i = 0; i < 1; ++i)
		{
			std::vector<int> v = TestCase::RandVec(15, 0, 30);
			HouseRobber().DP1D(v);
			HouseRobber().ConstSpace(v);
		}
		HouseRobber().Circular_DP1D(std::vector<int>({ 2, 7, 9, 3, 1 }));
	}
	{
		TwoAssemblyLineScheduling().DP1D(std::vector<std::vector<int>>(
		{
			{ 4, 5, 3, 2 },//station time of line1
			{ 2, 10, 1, 4 }//station time of line2
		}),
			std::vector<std::vector<int>>(
			{
				{ 0, 7, 4, 5 },//transfer time of line1
				{ 0, 9, 2, 8 }//transfer time of line2
			}),
			std::vector<int>({ 10, 12 }),//entry time
			std::vector<int>({ 18, 7 }));//exit time
	}
	{
		BurstBallons().DP2D(std::vector<int>({ 3,1,5,8 }));
		BurstBallons().Recur(std::vector<int>({ 3,1,5,8 }));
	}
	{
		BombsInACircle().FixedOrderFromBegin_InPlace_Recur(std::vector<int>({ 1, 3, 1, 1, 1, 1 }), std::vector<int>({ 1, 2, 1, 1, 0, 0 }));//4
		//BombsInACircle().FixedOrderFromBegin_InPlace_Recur(std::vector<int>({ 2, 1, 3 }), std::vector<int>({ 0, 1, 1 }));//5
		//BombsInACircle().FixedOrderFromBegin_InPlace_Recur(std::vector<int>({ 7, 2, 3, 4, 10, 4, 3, 8 }), std::vector<int>({ 3, 3, 1, 4, 4, 1, 1, 2 }));//17
		//BombsInACircle().FixedOrderFromBegin_InPlace_Recur(std::vector<int>({ 1, 4, 3 }), std::vector<int>({ 9, 0, 3 }));//7
		//BombsInACircle().FixedOrderFromBegin_InPlace_Recur(std::vector<int>({ 1, 1, 10, 1 }), std::vector<int>({ 0, 1, 2, 1 }));//11
		//BombsInACircle().FixedOrderFromBegin_InPlace_Recur(std::vector<int>({ 10, 5, 8 }), std::vector<int>({ 5, 0, 0 }));//13

		BombsInACircle().FixedOrderFromBegin_ExtraSpace_Recur(std::vector<int>({ 1, 3, 1, 1, 1, 1 }), std::vector<int>({ 1, 2, 1, 1, 0, 0 }));//4
		//BombsInACircle().FixedOrderFromBegin_ExtraSpace_Recur(std::vector<int>({ 2, 1, 3 }), std::vector<int>({ 0, 1, 1 }));//5
		//BombsInACircle().FixedOrderFromBegin_ExtraSpace_Recur(std::vector<int>({ 7, 2, 3, 4, 10, 4, 3, 8 }), std::vector<int>({ 3, 3, 1, 4, 4, 1, 1, 2 }));//17
		//BombsInACircle().FixedOrderFromBegin_ExtraSpace_Recur(std::vector<int>({ 1, 4, 3 }), std::vector<int>({ 9, 0, 3 }));//7
		//BombsInACircle().FixedOrderFromBegin_ExtraSpace_Recur(std::vector<int>({ 1, 1, 10, 1 }), std::vector<int>({ 0, 1, 2, 1 }));//11
		//BombsInACircle().FixedOrderFromBegin_ExtraSpace_Recur(std::vector<int>({ 10, 5, 8 }), std::vector<int>({ 5, 0, 0 }));//23

		BombsInACircle().ArbitraryOrder_Recur(std::vector<int>({ 1, 3, 1, 1, 1, 1 }), std::vector<int>({ 1, 2, 1, 1, 0, 0 }));//6
		//BombsInACircle().ArbitraryOrder_Recur(std::vector<int>({ 2, 1, 3 }), std::vector<int>({ 0, 1, 1 }));//5
		//BombsInACircle().ArbitraryOrder_Recur(std::vector<int>({ 7, 2, 3, 4, 10, 4, 3, 8 }), std::vector<int>({ 3, 3, 1, 4, 4, 1, 1, 2 }));//23
		//BombsInACircle().ArbitraryOrder_Recur(std::vector<int>({ 1, 4, 3 }), std::vector<int>({ 9, 0, 3 }));//7
		//BombsInACircle().ArbitraryOrder_Recur(std::vector<int>({ 1, 1, 10, 1 }), std::vector<int>({ 0, 1, 2, 1 }));//11
		//BombsInACircle().ArbitraryOrder_Recur(std::vector<int>({ 10, 5, 8 }), std::vector<int>({ 5, 0, 0 }));//23

		//BombsInACircle().ArbitraryOrder_Recur(std::vector<int>({ 7, 2, 3, 4, 10, 4, 5, 5, 3, 8 }), std::vector<int>({ 5, 5, 2, 6, 6, 1, 2, 4, 3, 3 }));//18
	}
	{
		GeneralizedAbbreviation().Recur(std::string("word"));
		GeneralizedAbbreviation().Recur(std::string("abcde"));
		GeneralizedAbbreviation().Recur(std::string("abcdefghij"));

		GeneralizedAbbreviation().Validate(std::string("internationalization"), std::string("i12iz4n"));
		GeneralizedAbbreviation().Validate(std::string("apple"), std::string("a2e"));

		ConvertAllWordsToMinUniqueAbbrs().BruteForce(std::vector<std::string>({ "like", "god", "internal", "me", "internet", "interval", "intension", "face", "intrusion" }));
	}
	{
		PatchingArray().CountMinPatches(std::vector<int>({ 1,4,10 }), 50);
		PatchingArray().CountMinPatches(std::vector<int>({ 1,4,10 }), 52);
		PatchingArray().CountMinPatches(std::vector<int>({ 1,2,5,6,20 }), 50);
		PatchingArray().CountMinPatches(std::vector<int>({ 1,2,4,11,30 }), 50);
		PatchingArray().CountMinPatches(std::vector<int>({ }), 50);
	}
	{
		CountNumbersWithUniqueDigits().DP(10);
		CountNumbersWithUniqueDigits().Recur(10);
	}
	{
		EqualSum2SubArrPartition().FindBreakPoints(std::vector<int>({ 1, -1, 0, 1, 1 }));
		EqualSum2SubArrPartition().FindBreakPoints_PrefixSums(std::vector<int>({ 1, -1, 0, 1, 1 }));
		EqualSum2SubArrPartition().FindBreakPoints(std::vector<int>({ 1, 1, -1, 1, 0 }));
		EqualSum2SubArrPartition().FindBreakPoints_PrefixSums(std::vector<int>({ 1, 1, -1, 1, 0 }));
	}
	{
		EquilibriumIndexOfArray().FindAll_2Scan(std::vector<int>({ -7, 1, 5, 2, -4, 3, 0 }));
	}
	{
		MinEqualSumSubArrPartition().Greedy(std::vector<int>({ 3, 1, 3, 7, 5, 2 }));//[3 1 3][7][5 2]
		MinEqualSumSubArrPartition().Greedy(std::vector<int>({ 3, 1, 3, 6, 6, 2 }));//[3 1 3 6 6 2]
		MinEqualSumSubArrPartition().Greedy(std::vector<int>({ 3, 2, 7, 1, 5, 3 }));//[3 2 7 1 5 3]
	}
	{
		PalindromePartitioning().FindAll_Recur("babcbabcbaccba");
		PalindromePartitioning().FindAll_DP2D("babcbabcbaccba");
		PalindromePartitioning().CountMinCut_DP2D_1(std::string("babcbabcbaccba"));
		PalindromePartitioning().CountMinCut_DP2D_2(std::string("babcbabcbaccba"));
	}
	{
		InterleavingString().Recur("aabcc", "dbbca", "aadbbcbcac");
		InterleavingString().Recur("aabcc", "dbbca", "aadbbbaccc");
		InterleavingString().DP2D("aabcc", "dbbca", "aadbbcbcac");
		InterleavingString().DP2D("aabcc", "dbbca", "aadbbbaccc");
	}
	{
		Interleave2Strings().Recur(std::string("ab"), std::string("cd"));
		Interleave2Strings().Recur(std::string("abcd"), std::string("xy"));
	}
	{
		KPalindrome().Valid_K_Recur(std::string("abxcdycba"), 2);
		KPalindrome().Valid_K_Recur(std::string("abxcdycbaz"), 2);
		KPalindrome().Valid_K_EditDistWReverse(std::string("abxcdycba"), 2);
		KPalindrome().Valid_K_EditDistWReverse(std::string("abxcdycbaz"), 2);

		KPalindrome().Count_K_Recur(std::string("abxcdycba"));
		KPalindrome().Count_K_Recur(std::string("abxcdycbaz"));
		KPalindrome().Count_K_Recur(std::string("abcd"));
		KPalindrome().Count_K_DP2D(std::string("abxcdycba"));
		KPalindrome().Count_K_DP2D(std::string("abxcdycbaz"));
		KPalindrome().Count_K_DP2D(std::string("abcd"));
	}
	{
		WordPattern().Match(std::string("abba"), std::string("dog cat cat dog"));
		WordPattern().Match(std::string("abba"), std::string("dog cat cat fish"));
		WordPattern().Match(std::string("aaaa"), std::string("dog cat cat dog"));
		WordPattern().Match(std::string("abba"), std::string("dog dog dog dog"));

		WordPattern().MatchII(std::string("abab"), std::string("redblueredblue"));
		WordPattern().MatchII(std::string("aaaa"), std::string("asdasdasdasd"));
		WordPattern().MatchII(std::string("aabb"), std::string("xyzabcxyzabc"));
	}
	{
		PermutedPalindrome().HashTable(std::string("edified"));
		PermutedPalindrome().Sort(std::string("edified"));

		PermutedPalindrome().GenerateAllPalindromePermutations(std::string("aaa"));
		PermutedPalindrome().GenerateAllPalindromePermutations(std::string("aabb"));
		PermutedPalindrome().GenerateAllPalindromePermutations(std::string("aaabb"));
		PermutedPalindrome().GenerateAllPalindromePermutations(std::string("abccba"));
		PermutedPalindrome().GenerateAllPalindromePermutations(std::string("abcdcba"));
	}
	{
		ScrambleString().Recur(std::string("great"), std::string("rgtae"));
		ScrambleString().DP3D(std::string("great"), std::string("rgtae"));
	}
	{
		abcCombination_1b_2cs().DFS(1);
		abcCombination_1b_2cs().DFS(2);
		abcCombination_1b_2cs().DFS(3);
		abcCombination_1b_2cs().DFS(4);
		abcCombination_1b_2cs().DFS(5);

		abcCombination_1b_2cs().DP3D(1);
		abcCombination_1b_2cs().DP3D(2);
		abcCombination_1b_2cs().DP3D(3);
		abcCombination_1b_2cs().DP3D(4);
		abcCombination_1b_2cs().DP3D(5);
		abcCombination_1b_2cs().DP3D(6);
		abcCombination_1b_2cs().DP3D(7);
		abcCombination_1b_2cs().DP3D(8);

		abcCombination_1b_2cs().DP2D(1);
		abcCombination_1b_2cs().DP2D(2);
		abcCombination_1b_2cs().DP2D(3);
		abcCombination_1b_2cs().DP2D(4);
		abcCombination_1b_2cs().DP2D(5);
		abcCombination_1b_2cs().DP2D(6);
		abcCombination_1b_2cs().DP2D(7);
		abcCombination_1b_2cs().DP2D(8);
	}
	{
		BinaryStrWoConsecu1s().Count_DP1D(5);
		BinaryStrWoConsecu1s().Count_DP(5);
	}
	{
		BinStrCombinationWGiven0n1Count().InExcludeRecur(std::vector<std::string>({ "10", "0001", "111001", "1", "0" }), 5, 3);
		BinStrCombinationWGiven0n1Count().DP3D(std::vector<std::string>({ "10", "0001", "111001", "1", "0" }), 5, 3);
		BinStrCombinationWGiven0n1Count().DP2D(std::vector<std::string>({ "10", "0001", "111001", "1", "0" }), 5, 3);
		BinStrCombinationWGiven0n1Count().InExcludeRecur(std::vector<std::string>({ "10", "0", "1" }), 1, 1);
		BinStrCombinationWGiven0n1Count().DP3D(std::vector<std::string>({ "10", "0", "1" }), 1, 1);
		BinStrCombinationWGiven0n1Count().DP2D(std::vector<std::string>({ "10", "0", "1" }), 1, 1);
	}
	{
		PlusMinusCombinationSum().NumOfWaysRecur(std::vector<int>({ 1, 1, 1, 1, 1 }), 3);
		PlusMinusCombinationSum().NumOfWaysRecurDP(std::vector<int>({ 1, 1, 1, 1, 1 }), 3);
		PlusMinusCombinationSum().NumOfWaysDP2D(std::vector<int>({ 1, 1, 1, 1, 1 }), 3);
	}
	{
		SmallestPermutationFromIncrDecrArray().FindSmallestPermutation(std::string("IDIDDDI"));
		SmallestPermutationFromIncrDecrArray().FindSmallestPermutation(std::string("DDIIDDD"));
        SmallestPermutationFromIncrDecrArray().FindAnyPermutation(std::string("IDIDDDI"));
        SmallestPermutationFromIncrDecrArray().FindAnyPermutation(std::string("DDIIDDD"));
	}
	{
		BeautifulArrangement().Recur(4);
	}
	{
		MatchsticksToSquare().CanMakeSquare(std::vector<int>({ 1,1,2,2,2 }));
		MatchsticksToSquare().CanMakeSquare(std::vector<int>({ 3,3,3,3,4 }));
	}
	{
		EqualSum4SubArrExcludeSplitter().CanSplit(std::vector<int>({ 1,2,1,2,1,2,1 }));
	}
	{
		OptimalDivision().RecurDP(std::vector<int>({ 2,3,4 }));
		OptimalDivision().Math(std::vector<int>({ 2,3,4 }));
		OptimalDivision().RecurDP(std::vector<int>({ 1000,100,10,2 }));
		OptimalDivision().Math(std::vector<int>({ 1000,100,10,2 }));
	}
	{
		RemoveBoxes().Recur(std::vector<int>({ 1, 3, 2, 2, 2, 3, 4, 3, 1 }));
		RemoveBoxes().RecurDP3D(std::vector<int>({ 1, 3, 2, 2, 2, 3, 4, 3, 1 }));
	}
	{
		MaxSumOfPairMins().Sort(std::vector<int>({ 1,4,3,2 }));
	}
	{
		RemoveConsecuSameChars().Linear("aacbbbccd");
		RemoveConsecuSameChars().Linear("aabbba");
		RemoveConsecuSameChars().Linear("aabbccccdd");
		RemoveConsecuSameChars().Linear("aabbcccbadd");
		RemoveConsecuSameChars().Linear("abbbdbbccddaccddddccaaddcb");
	}
    {
        PartitionSameCharsInSingleSubstr().TwoScanHashMap(std::string("ababcbacadefegdehijhklij"));
    }
    {
        NextClosestTime().Solve(std::string("19:34"));
        NextClosestTime().Solve(std::string("23:59"));
    }
    {
        PartitionIntoFibonacciSeq().Recur_FindAnyOne(std::string("1101111"));
        PartitionIntoFibonacciSeq().Recur_FindAll(std::string("1101111"));
    }
    {
        MinStickersToSpellWord().DFS_DP(std::vector<std::string>({"with", "example", "science"}), std::string("thehat"));
    }
    {
        Game24().DFS(std::vector<int>({4,1,8,7}));
    }
    {
        MaxPointsDeleteAndEarn().DP(std::vector<int>({2,2,3,3,3,4}));
    }
    {
        PartitionArrToDoubleValuedPairs().Test(std::vector<int>({4,-2,2,-4}));
    }
    {
        PartitionSameNumsInGroupsWSameSizes().Valid(std::vector<int>({1,1,2,2,2,2}));
    }
    {
        ArrPermutationConsecuNumSumIsSquare().DFS(std::vector<int>({1,17,8}));
    }
    {
        MinCostOfMultiDayPassTickets().DP(std::vector<int>({1,4,6,7,8,20}), std::vector<int>({2,7,15}));
    }
    {
        AssignBikesToWorkersWShortestDist().ShortestPairDistFirst_MinHeap(std::vector<std::vector<int>>({{0,0},{1,1},{2,0}}), std::vector<std::vector<int>>({{1,0},{2,2},{2,1}}));
        AssignBikesToWorkersWShortestDist().ShortestPairDistFirst_BucketSort(std::vector<std::vector<int>>({{0,0},{1,1},{2,0}}), std::vector<std::vector<int>>({{1,0},{2,2},{2,1}}));
        AssignBikesToWorkersWShortestDist().MinAllPairDistSums_DFS(std::vector<std::vector<int>>({{0,0},{1,1},{2,0}}), std::vector<std::vector<int>>({{1,0},{2,2},{2,1}}));
        AssignBikesToWorkersWShortestDist().MinAllPairDistSums_DFS_Memo(std::vector<std::vector<int>>({{0,0},{1,1},{2,0}}), std::vector<std::vector<int>>({{1,0},{2,2},{2,1}}));
        AssignBikesToWorkersWShortestDist().MinAllPairDistSums_BFS_MinHeap(std::vector<std::vector<int>>({{0,0},{1,1},{2,0}}), std::vector<std::vector<int>>({{1,0},{2,2},{2,1}}));
    }
    {
        CountPermu1toNWPrimeOnPrimeIdx().Solve(100);
    }
    {
        PartitionArrMinimizeSumOfEachSubArrMax().Recur(std::vector<int>({30,10,40,20,50}),2);
        PartitionArrMinimizeSumOfEachSubArrMax().Recur(std::vector<int>({74303,20452,66120,44483,5370,68585}),5);
    }

#endif
#ifdef _TrieSuffixArray_
	/*TrieSuffixTreeArray*/
	RdCout ? redirect_cout::to_file("Out_TrieSuffixArray.txt") : redirect_cout::to_cout();
	PrintH("Trie Suffix Array");
	{
		SuffixArrayNaive san_test("abracadabra");
		SuffixArrayNaive san_test2("mississippi");
		SuffixArrayNaive san_test3("aabbabbaab");
		SuffixArrayNaive san_test4("baabaabbbbaa");

		SuffixArraySimple sas_test("abracadabra");
		SuffixArraySimple sas_test2("abac");
		SuffixArraySimple sas_test3("ababbababbabababbabababbababbaba");
	}
	/*test TrieST<>*/
	{
		TrieST<int> trieST;
		trieST.Put(std::string("peter"), 1);
		trieST.Put(std::string("piper"), 2);
		trieST.Put(std::string("picked"), 3);
		trieST.Put(std::string("a"), 4);
		trieST.Put(std::string("peck"), 5);
		trieST.Put(std::string("of"), 6);
		trieST.Put(std::string("pickled"), 7);
		trieST.Put(std::string("peppers"), 8);
		trieST.Get("peter");
		trieST.Get("piper");
		trieST.Get("picked");
		trieST.Get("a");
		trieST.Get("peck");
		trieST.Get("of");
		trieST.Get("pickled");
		trieST.Get("peppers");
		trieST.Contains("p");
		trieST.Contains("pe");
		trieST.Contains("pi");
		trieST.Contains("pet");
		trieST.Contains("a");
		trieST.Keys();
		trieST.KeysWithPrefix(std::string("pe"));
		trieST.KeysThatMatch(std::string("p..er"));
		trieST.LongestPrefixKeyOf(std::string("peterpiper"));
		trieST.LongestPrefixOf(std::string("picture"));
		trieST.Delete(std::string("peter"));
		trieST.Delete(std::string("picked"));
		trieST.Keys();
		trieST.Delete();
		trieST.Keys();
	}

	/*test TST<>*/
	{
		TST<int> tST;
		tST.Put(std::string("peter"), 1);
		tST.Put(std::string("piper"), 2);
		tST.Put(std::string("picked"), 3);
		tST.Put(std::string("a"), 4);
		tST.Put(std::string("peck"), 5);
		tST.Put(std::string("of"), 6);
		tST.Put(std::string("pickled"), 7);
		tST.Put(std::string("peppers"), 8);
		std::cout << tST.Get("peter") << tST.Get("piper") << tST.Get("picked") << tST.Get("a") << tST.Get("peck") << tST.Get("of") << tST.Get("pickled") << tST.Get("peppers") << std::endl;
		std::cout << tST.Contains("p") << "," << tST.Contains("pe") << "," << tST.Contains("pi") << "," << tST.Contains("pet") << "," << tST.Contains("a") << std::endl;
		std::queue<std::string> keys = tST.Keys();
		std::ostringstream oss;
		while (!keys.empty())
		{
			oss << keys.front();
			keys.pop();
			oss << ",";
		}
		std::cout << oss.str() << std::endl;
		oss.str(std::string());
		keys = tST.KeysWithPrefix(std::string("pe"));
		while (!keys.empty())
		{
			oss << keys.front();
			keys.pop();
			oss << ",";
		}
		std::cout << oss.str() << std::endl;
		oss.str(std::string());
		keys = tST.KeysThatMatch(std::string("p..er"));
		while (!keys.empty())
		{
			oss << keys.front();
			keys.pop();
			oss << ",";
		}
		std::cout << oss.str() << std::endl;
		oss.str(std::string());
		std::cout << tST.LongestPrefixKeyOf(std::string("peterpiper")) << std::endl;
		std::cout << tST.LongestPrefixOf(std::string("picture")) << std::endl;
		tST.Delete(std::string("peter"));
		tST.Delete(std::string("picked"));
		keys = tST.Keys();
		while (!keys.empty())
		{
			oss << keys.front();
			keys.pop();
			oss << ",";
		}
		std::cout << oss.str() << std::endl;
		oss.str(std::string());
		tST.Delete();
		keys = tST.Keys();
		while (!keys.empty())
		{
			oss << keys.front();
			keys.pop();
			oss << ",";
		}
		std::cout << oss.str() << std::endl;
	}
	{
		FirstUniqueURL().Find_1Pass(std::vector<std::string>({ "www.facebook.com", "www.facebook.com", "www.google.com", "www.google.com", "www.facebook.com", "www.apple.com", "www.battle.net", "www.google.com", "www.twitter.com", "www.battle.net", "linkedin.com", "www.apple.com", "www.yahoo.com", "qualgame.com", "amazon.com", "qualgame.com" }));
		//FirstUniqueURL().Find_1Pass(std::vector<std::string>({ "abc", "def", "abc", "def", "xyz", "ghi", "jkl", "xyz" }));
		//FirstUniqueURL().Find_1Pass(std::vector<std::string>({ "abc", "def", "abc" }));
	}
	{
		MaxXORof2NumsInArray().FindMaxXOR_BinaryTrie(std::vector<int>({ 3, 10, 5, 25, 2, 8 }));
	}
    {
        SearchWordWithPrefixSuffix_1 s1(std::vector<std::string>({"apple"}));
        std::cout << "Search(\"a\",\"e\")=" << s1.Search("a", "e") << std::endl;
        std::cout << "Search(\"b\",\"\")=" << s1.Search("b", "") << std::endl;
        SearchWordWithPrefixSuffix_2 s2(std::vector<std::string>({"apple"}));
        std::cout << "Search(\"a\",\"e\")=" << s2.Search("a", "e") << std::endl;
        std::cout << "Search(\"b\",\"\")=" << s2.Search("b", "") << std::endl;
    }
    {
        SerializeDeserializeTrie::Trie * root = new SerializeDeserializeTrie::Trie;
        //SerializeDeserializeTrie().Construct(root, std::vector<std::string>({"cap","cat","caption","captain","capital"}));
        SerializeDeserializeTrie().Construct(root, std::vector<std::string>({"cap","cat","caption","captain","capital","city","citadel","cisco","good","google","goodbye","goose"}));
        std::string s = SerializeDeserializeTrie().Serialize(root);
        SerializeDeserializeTrie::Trie * root2 = SerializeDeserializeTrie().Deserialize(s);
        SerializeDeserializeTrie().Serialize(root2);
    }
    {
        OneCharMismatchDictionary d;
        d.BuildDict(std::vector<std::string>({"hello", "leetcode"}));
        d.Search("hello");
        d.Search("hhllo");
        d.Search("hell");
        d.Search("leetcoded");
    }

#endif
#ifdef _FindSubstringSubsequence_
	/*Find Substring Subsequence*/
	RdCout ? redirect_cout::to_file("Out_FindSubstrSubseq.txt") : redirect_cout::to_cout();
	PrintH("Find Substring Subsequence");
	{
		AllSubstr().Iterate(std::string("a"));
		AllSubstr().Iterate(std::string("aa"));
		AllSubstr().Iterate(std::string("ab"));
		AllSubstr().Iterate(std::string("abbc"));
		AllSubstr().Iterate(std::string("abac"));
		AllSubstr().Iterate(std::string("aabab"));
		AllSubstr().Iterate(std::string("12345"));
		AllSubstr().Recur(std::string("a"));
		AllSubstr().Recur(std::string("aa"));
		AllSubstr().Recur(std::string("ab"));
		AllSubstr().Recur(std::string("abbc"));
		AllSubstr().Recur(std::string("abac"));
		AllSubstr().Recur(std::string("aabab"));
		AllSubstr().Recur(std::string("12345"));
	}
	{
		LIS().Len_Greedy_LowerBound(std::vector<int>({ 3, 1, 5, 7, 6, 8, 2, -5, 4, -4, 5, -3, 6, -2, 7, -1 }));
		LIS().Len_Greedy_LowerBound(std::vector<int>({ 1, 1, 5, 5, 6, 7, 7, 8 }));
		LIS().Len_Greedy_LowerBound2(std::vector<int>({ 3, 1, 5, 7, 6, 8, 2, -5, 4, -4, 5, -3, 6, -2, 7, -1 }));
		LIS().Len_Greedy_LowerBound2(std::vector<int>({ 1, 1, 5, 5, 6, 7, 7, 8 }));
		LIS().Len_DP1D_Quadratic(std::vector<int>({ 3, 1, 5, 7, 6, 8, 2, -5, 4, -4, 5, -3, 6, -2, 7, -1 }));
		LIS().Len_DP1D_Quadratic(std::vector<int>({ 1, 1, 5, 5, 6, 7, 7, 8 }));

		LIS().FindAll_InExcludeRecur(std::vector<int>({ 3, 1, 5, 7, 6, 8, 2, -5, 4, -4, 5, -3, 6, -2, 7, -1 }));
		LIS().Len_InExcludeRecur(std::vector<int>({ 3, 1, 5, 7, 6, 8, 2, -5, 4, -4, 5, -3, 6, -2, 7, -1 }));

		//LIS().FindAll_FixRecur(std::vector<int>({ 3, 1, 5, 7, 6, 8, 2, -5, 4, -4, 5, -3, 6, -2, 7, -1 }));

		LIS().Len_ShrinkLen_Recur(std::vector<int>({ 3, 1, 5, 7, 6, 8, 2, -5, 4, -4, 5, -3, 6, -2, 7, -1 }));
		LIS().Len_ShrinkLen_DP_Recur(std::vector<int>({ 3, 1, 5, 7, 6, 8, 2, -5, 4, -4, 5, -3, 6, -2, 7, -1 }));

		LIS().FindAllDistinct_FixRecur(std::vector<int>({ 4,6,7,7 }));

		LIS().Count_IS_DP1D_Quadratic(std::vector<int>({ 3,2,4,5,4 }));
		LIS().Count_IS_DP1D_Linear(std::string("dcefe"));

        LIS().Count_LIS_DP1D(std::vector<int>({ 3, 1, 5, 7, 6, 8, 2, -5, 4, -4, 5, -3, 6, -2, 7, -1 }));
        LIS().Count_LIS_DP1D(std::vector<int>({ 1, 1, 5, 5, 6, 7, 7, 8 }));
        LIS().Count_LIS_Greedy_LowerBound(std::vector<int>({ 3, 1, 5, 7, 6, 8, 2, -5, 4, -4, 5, -3, 6, -2, 7, -1 }));
        LIS().Count_LIS_Greedy_LowerBound(std::vector<int>({ 1, 1, 5, 5, 6, 7, 7, 8 }));
	}
	{
		LongestAlternatingSubseq().DP1D(std::vector<int>({ 1, 3, 2, 1, 5, 7, 6, 5, 4, 3, 2, 7, 8, 9, 2, 3, 4, 0 }));
		LongestAlternatingSubseq().LinearDP1D(std::vector<int>({ 1, 3, 2, 1, 5, 7, 6, 5, 4, 3, 2, 7, 8, 9, 2, 3, 4, 0 }));
		LongestAlternatingSubseq().Greedy(std::vector<int>({ 1, 3, 2, 1, 5, 7, 6, 5, 4, 3, 2, 7, 8, 9, 2, 3, 4, 0 }));
		LongestAlternatingSubseq().DP1D_DecrFirst(std::vector<int>({ 1, 3, 2, 1, 5, 7, 6, 5, 4, 3, 2, 7, 8, 9, 2, 3, 4, 0 }));
		LongestWeaklyAlternatingSubseq().DP1D(std::vector<int>({ 1, 3, 2, 1, 5, 7, 6, 5, 4, 3, 2, 7, 8, 9, 2, 3, 4, 0 }));
		LongestAlternatingSubseq().DP1D(std::vector<int>({ 1, 11, 2, 10, 4, 5, 2, 1 }));
		LongestAlternatingSubseq().LinearDP1D(std::vector<int>({ 1, 11, 2, 10, 4, 5, 2, 1 }));
		LongestAlternatingSubseq().Greedy(std::vector<int>({ 1, 11, 2, 10, 4, 5, 2, 1 }));
		LongestAlternatingSubseq().DP1D_DecrFirst(std::vector<int>({ 1, 11, 2, 10, 4, 5, 2, 1 }));
		LongestWeaklyAlternatingSubseq().DP1D(std::vector<int>({ 1, 11, 2, 10, 4, 5, 2, 1 }));
		LongestAlternatingSubseq().DP1D(std::vector<int>({ 12, 11, 13, 5, 3, 1 }));
		LongestAlternatingSubseq().LinearDP1D(std::vector<int>({ 12, 11, 13, 5, 3, 1 }));
		LongestAlternatingSubseq().Greedy(std::vector<int>({ 12, 11, 13, 5, 3, 1 }));
		LongestAlternatingSubseq().DP1D_DecrFirst(std::vector<int>({ 12, 11, 13, 5, 3, 1 }));
		LongestWeaklyAlternatingSubseq().DP1D(std::vector<int>({ 12, 11, 13, 5, 3, 1 }));
		LongestAlternatingSubseq().DP1D(std::vector<int>({ 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 }));
		LongestAlternatingSubseq().LinearDP1D(std::vector<int>({ 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 }));
		LongestAlternatingSubseq().Greedy(std::vector<int>({ 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 }));
		LongestAlternatingSubseq().DP1D_DecrFirst(std::vector<int>({ 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 }));
		LongestWeaklyAlternatingSubseq().DP1D(std::vector<int>({ 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 }));

		//for (int i = 0; i < 10; ++i)
		//{
		//	std::vector<int> test = TestCase::RandVec<int>(20, 0, 99);
		//	LongestAlternatingSubseq().DP1D(test);
		//	LongestAlternatingSubseq().DP1D_DecrFirst(test);
		//}

		for (int i = 0; i < 1; ++i)
		{
			std::vector<int> test = TestCase::RandVec<int>(20, 0, 7);
			LongestAlternatingSubseq().DP1D(test);
			LongestAlternatingSubseq().LinearDP1D(test);
			LongestAlternatingSubseq().Greedy(test);
			LongestAlternatingSubseq().DP1D_DecrFirst(test);
			LongestWeaklyAlternatingSubseq().DP1D(test);
		}
	}
	{
		LongestConvexSubseq().DP1D(std::vector<int>({ 1, 2, -1, 0, 3, 8, 5 }));
		//for (int i = 0; i < 10; ++i)
		//{
		//	std::vector<int> test = TestCase::RandVec<int>(20, 0, 5);
		//	LongestConvexSubseq().DP1D(test);
		//}
	}
	{
		LBS().Len_Greedy_LowerBound(std::vector<int>({ 3, 1, 5, 7, 6, 8, 2, 4 }));
		LBS().Len_DP1D_Quadratic(std::vector<int>({ 3, 1, 5, 7, 6, 8, 2, 4 }));
		LBS().Len_Greedy_LowerBound(std::vector<int>({ 1, 11, 2, 10, 4, 5, 2, 1 }));
		LBS().Len_DP1D_Quadratic(std::vector<int>({ 1, 11, 2, 10, 4, 5, 2, 1 }));
		LBS().Len_Greedy_LowerBound(std::vector<int>({ 12, 11, 13, 5, 3, 1 }));
		LBS().Len_DP1D_Quadratic(std::vector<int>({ 12, 11, 13, 5, 3, 1 }));
		LBS().Len_Greedy_LowerBound(std::vector<int>({ 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 }));
		LBS().Len_DP1D_Quadratic(std::vector<int>({ 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 }));
	}
	{
		LISPairs().Len_DP1D_Quadratic(std::vector<std::pair<int, int>>({ { 3, 3 },{ 1, 0 },{ 5, 4 },{ 7, 5 },{ 6, 7 },{ 8, 3 },{ 2, 5 },{ -5, -3 },{ 4, 6 },{ -4, -1 },{ 5, 7 },{ -3, 0 },{ 6, 8 },{ -2, 1 },{ 7, 9 },{ -1, 3 } }));
		LISPairs().Len_DP1D_Quadratic(std::vector<std::pair<int, int>>({ { 1, 2 },{ 1, 3 },{ 2, 3 },{ 4, 5 },{ 4, 6 },{ 4, 6 },{ 4, 7 },{ 5, 6 },{ 6, 7 },{ 10, 12 },{ 10, 32 },{ 12, 32 } }));
		std::cout << "LongestIncreasingPairs===>" << std::endl;
		LongestIncreasingPairs().Len_Greedy_LowerBound(std::vector<std::pair<int, int>>({ { 3, 3 },{ 1, 0 },{ 5, 4 },{ 7, 5 },{ 6, 7 },{ 8, 3 },{ 2, 5 },{ -5, -3 },{ 4, 6 },{ -4, -1 },{ 5, 7 },{ -3, 0 },{ 6, 8 },{ -2, 1 },{ 7, 9 },{ -1, 3 } }));
		LongestIncreasingPairs().Len_DP1D_Quadratic(std::vector<std::pair<int, int>>({ { 3, 3 },{ 1, 0 },{ 5, 4 },{ 7, 5 },{ 6, 7 },{ 8, 3 },{ 2, 5 },{ -5, -3 },{ 4, 6 },{ -4, -1 },{ 5, 7 },{ -3, 0 },{ 6, 8 },{ -2, 1 },{ 7, 9 },{ -1, 3 } }));
		LongestIncreasingPairs().Len_Greedy_LowerBound(std::vector<std::pair<int, int>>({ { 1, 2 },{ 1, 3 },{ 2, 3 },{ 4, 5 },{ 4, 6 },{ 4, 6 },{ 4, 7 },{ 5, 6 },{ 6, 7 },{ 10, 12 },{ 10, 32 },{ 12, 32 } }));
		LongestIncreasingPairs().Len_DP1D_Quadratic(std::vector<std::pair<int, int>>({ { 1, 2 },{ 1, 3 },{ 2, 3 },{ 4, 5 },{ 4, 6 },{ 4, 6 },{ 4, 7 },{ 5, 6 },{ 6, 7 },{ 10, 12 },{ 10, 32 },{ 12, 32 } }));
		for (int i = 0; i < 10; ++i)
		{
			std::vector<std::pair<int, int>> test = TestCase::RandVecPair<int>(20, 0, 99);
			int a = LongestIncreasingPairs().Len_Greedy_LowerBound(test);
			int b = LongestIncreasingPairs().Len_DP1D_Quadratic(test);
			if (a != b)
				std::cout << "!!!!!!!!!!!!!!!!" << std::endl;
		}
		std::cout << "<===LongestIncreasingPairs" << std::endl;
	}
	{
		for (int i = 0; i < 1; ++i)
		{
			std::vector<std::pair<int, int>> test = TestCase::RandVecPair<int>(20, 0, 99);
			for (auto & p : test)
				if (p.first > p.second)
					std::swap(p.first, p.second);
			LongestChainOfPairs().Len_DP1D_Quadratic(test);
		}
	}
	{
		BoxStacking().Solve(std::vector<std::pair<std::pair<int, int>, int>>({ { { 4, 6 }, 7 }, { { 1, 3 }, 2 }, { { 4, 5 }, 6 }, { { 10, 12 }, 32 } }));
	}
	{
		MaxSumIncrSubseq().DP1D_Quadratic(std::vector<int>({ 5, 105, 10, 15, 100, 20, 25 }));
		//MaxSumIncrSubseq().DP1D_LowerBound(std::vector<int>({ 5, 105, 10, 15, 100, 20, 25 }));
	}
	{
		LISubstr().Len_HeuristicSkip(std::vector<int>({ 2, 3, -1, -3, 6, 8, 9, 10, 5, 6, 7 }));
		LISubstr().Len_Iterate(std::vector<int>({ 2, 3, -1, -3, 6, 8, 9, 10, 5, 6, 7 }));
		LISubstr().Len_Iterate2(std::vector<int>({ 2, 3, -1, -3, 6, 8, 9, 10, 5, 6, 7 }));

		//for (int i = 0; i < 10; ++i)
		//{
		//	std::vector<int> v = TestCase::RandVec<int>(30, 1, 99);
		//	LISubstr().Len_HeuristicSkip(v);
		//	LISubstr().Len_Iterate(v);
		//	LISubstr().Len_Iterate2(v);
		//}
	}
	{
		LongestRepeatedSubstr().SuffixArray("aababbaab");
        LongestRepeatedSubstr().DP("aababbaab");
        LongestRepeatedSubstr().DP2("aababbaab");
        LongestRepeatedSubstr().BinarySearchLen("aababbaab");
		LongestRepeatedSubstr().AtLeastKRepeats_SuffixArray("aababbaab", 3);
		LongestRepeatedSubstr().BruteForce_HashMap("aababbaab", 3);
		ShortestUniqueSubstr().SuffixArray("aababbaab");
		ShortestUniqueSubstr().BruteForce_HashMap("aababbaab");

		LongestRepeatedSubstr().SuffixArray("mississippi");
        LongestRepeatedSubstr().DP("mississippi");
        LongestRepeatedSubstr().DP2("mississippi");
        LongestRepeatedSubstr().BinarySearchLen("mississippi");
		LongestRepeatedSubstr().AtLeastKRepeats_SuffixArray("mississippi", 2);
		LongestRepeatedSubstr().BruteForce_HashMap("mississippi", 2);
		ShortestUniqueSubstr().SuffixArray("mississippi");
		ShortestUniqueSubstr().BruteForce_HashMap("mississippi");
	}
	{
		LongestSubstrWoRepeatChars().FindFirstOne_SlideWindow("abcdefgdijkxyz");//abcdefg=7, efgdijkxyz=10
        LongestSubstrWoRepeatChars().FindFirstOne_SlideWindow2("abcdefgdijkxyz");//abcdefg=7, efgdijkxyz=10
        SubstrWDistinctCharsSizeK().FindAll_SlideWindow("awaglknagawunagwkwagl", 4);

		LongestSubArrWDistinctEntries().HashTable(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7, 4, 8, 9, 10, 11, 12, 13 }));
		LongestSubArrWDistinctEntries().HashTable(std::vector<int>({ 5, 7, 5, 11, 13, 2, 11, 19, 2, 11 }));

		for (int i = 0; i < 10; ++i)
		{
			std::vector<int> v = TestCase::RandVec(25, 0, 9);
			LongestSubArrWDistinctEntries().HashTable(v);
			LongestSubArrWDistinctEntries().AtMost2_HashTable(v);
			LongestSubArrWDistinctEntries().AtMost2_2Ptrs(v);
			LongestSubArrWDistinctEntries().AtMostK_HashTable(v, TestCase::RandNum(3, 6));
		}
	}
	{
		LongestValidParentheses().Stack(")(((())()()(((");
		LongestValidParentheses().InPlace_TwoScans(")(((())()()(((");
		LongestValidParentheses().TwoScans_FindLongestValidSubstr(")(((())()()(((");
		LongestValidParentheses().TwoScans_FindLongestValidSubstr(")(())()((");
		LongestValidParentheses().TwoScans_FindLongestValidSubstr("()())()");
		LongestValidParentheses().TwoScans_FindLongestValidSubstr(")(");
        LongestValidParentheses().TwoScans_FindLongestValidSubstr("()())())(()()");
        LongestValidParentheses().TwoScans_FindLongestValidSubstr("()())())(()(()");
        LongestValidParentheses().TwoScans_FindLongestValidSubstr("()())(())()(()(()");
        LongestValidParentheses().TwoScans_FindLongestValidSubstr("()()))(()))(()(()))(()");

        LongestValidParentheses().TwoScans_FindLongestValidSubseq(")(((())()()(((");
        LongestValidParentheses().TwoScans_FindLongestValidSubseq(")(())()((");
        LongestValidParentheses().TwoScans_FindLongestValidSubseq("()())()");
        LongestValidParentheses().TwoScans_FindLongestValidSubseq(")(");
        LongestValidParentheses().TwoScans_FindLongestValidSubseq("()())())(()()");
        LongestValidParentheses().TwoScans_FindLongestValidSubseq("()())())(()(()");
        LongestValidParentheses().TwoScans_FindLongestValidSubseq("()())(())()(()(()");
        LongestValidParentheses().TwoScans_FindLongestValidSubseq("()()))(()))(()(()))(()");

        LongestValidParentheses().Stack_FindLongestValidSubseq(")(((())()()(((");
        LongestValidParentheses().Stack_FindLongestValidSubseq(")(())()((");
        LongestValidParentheses().Stack_FindLongestValidSubseq("()())()");
        LongestValidParentheses().Stack_FindLongestValidSubseq(")(");
        LongestValidParentheses().Stack_FindLongestValidSubseq("()())())(()()");
        LongestValidParentheses().Stack_FindLongestValidSubseq("()())())(()(()");
        LongestValidParentheses().Stack_FindLongestValidSubseq("()())(())()(()(()");
        LongestValidParentheses().Stack_FindLongestValidSubseq("()()))(()))(()(()))(()");
	}
	{
		int longestConsecutiveSeq[] = { 4, 2, 5, 1, -4, 8, 6, -6, 9, 11, 7, -3, -5 };
		LongestConsecutiveSeq().Len_HashSet(std::vector<int>(longestConsecutiveSeq, longestConsecutiveSeq + sizeof(longestConsecutiveSeq) / sizeof(int)));
		LongestConsecutiveSeq().Len_HashMap(std::vector<int>(longestConsecutiveSeq, longestConsecutiveSeq + sizeof(longestConsecutiveSeq) / sizeof(int)));
		LongestConsecutiveSeq().Len_HashMap2(std::vector<int>(longestConsecutiveSeq, longestConsecutiveSeq + sizeof(longestConsecutiveSeq) / sizeof(int)));
		LongestConsecutiveSeq().Len_Sort_Iterate(std::vector<int>(longestConsecutiveSeq, longestConsecutiveSeq + sizeof(longestConsecutiveSeq) / sizeof(int)));
		LongestConsecutiveSeq().Len_Sort_Iterate2(std::vector<int>(longestConsecutiveSeq, longestConsecutiveSeq + sizeof(longestConsecutiveSeq) / sizeof(int)));
	}
	{
		ShortestSubstrContainAllChars().FindAll_BruteForceIterate(std::string("ACBBACA"), std::string("ABA"));
		ShortestSubstrContainAllChars().Stormrage(std::string("ACBBACA"), std::string("ABA"));
		ShortestSubstrContainAllChars().Stormrage(std::string("ADOBECODEBANC"), std::string("ABC"));
		ShortestSubstrContainAllChars().Stormrage(std::string("this is a test string"), std::string("tist"));

		ShortestSubArrContainAllEntries().Stormrage(std::vector<std::string>({ "A", "C", "B", "B", "B", "A", "C", "D", "D", "A", "D", "C", "A", "C", "B" }), std::vector<std::string>({ "B", "D" }));
		ShortestSubArrContainAllEntries().Stormrage(std::vector<std::string>({ "A", "C", "D", "A", "B", "A", "C", "D", "A", "A", "D", "B", "A", "B", "C" }), std::vector<std::string>({ "A", "B", "B", "A" }));

		ShortestSubArrContainAllEntries().FromStream_DistinctEntries(std::istringstream({ "A C B B B A C D D A D C A C B" }), std::vector<std::string>({ "B", "D" }));
		ShortestSubArrContainAllEntries().FromStream_DistinctEntries(std::istringstream({ "A B D A B A A D D C A A A D B A B C" }), std::vector<std::string>({ "B", "C", "D" }));

		ShortestSubArrContainAllEntriesInOrder().DistinctEntries(std::vector<std::string>({ "A", "C", "B", "B", "B", "A", "C", "D", "D", "A", "D", "C", "A", "C", "B" }), std::vector<std::string>({ "B", "D" }));

        ShortestSubstrContainAllCharsInOrder().DP1D(std::string("acbbbacddadcacb"), std::string("bdd"));
        ShortestSubstrContainAllCharsInOrder().DP2D(std::string("acbbbacddadcacb"), std::string("bdd"));
	}
	{
		SubstrWConcatAllWords().FindAll_BruteForce_HashMap(std::string("xyzbarfoobarbarfoothe123foobarfoo456man"), std::vector<std::string>({ std::string("foo"), std::string("bar") }));
		SubstrWConcatAllWords().FindAll_SlideWindow(std::string("xyzbarfoobarbarfoothe123foobarfoo456man"), std::vector<std::string>({ std::string("foo"), std::string("bar") }));
	}
	{
		NumOfDistinctSubstr().SuffixArray(std::string("banana"));
		NumOfDistinctSubstr().BruteForce_HashSet(std::string("banana"));
		NumOfDistinctSubstr().SuffixArray(std::string("aabab"));
		NumOfDistinctSubstr().BruteForce_HashSet(std::string("aabab"));
		NumOfDistinctSubstr().SuffixArray(std::string("abac"));
		NumOfDistinctSubstr().BruteForce_HashSet(std::string("abac"));
	}
	{
		MinLexicographicStrRotation().SuffixArray(std::string("alabala"));
		MinLexicographicStrRotation().SuffixArray(std::string("baabaa"));
		MinLexicographicStrRotation().SuffixArray(std::string("bcabdadab"));
        MinLexicographicStrRotation().SuffixArray(std::string("ABCAAB"));
		//MinLexicographicStrRotation().SuffixArray(std::string("ab"));
		//MinLexicographicStrRotation().SuffixArray(std::string("aa"));
		//MinLexicographicStrRotation().SuffixArray(std::string("ba"));
		//MinLexicographicStrRotation().SuffixArray(std::string("bab"));
		//MinLexicographicStrRotation().SuffixArray(std::string("aba"));
		MinLexicographicStrRotation().Iterate(std::string("alabala"));
		MinLexicographicStrRotation().Iterate(std::string("baabaa"));
		MinLexicographicStrRotation().Iterate(std::string("bcabdadab"));
        MinLexicographicStrRotation().Iterate(std::string("ABCAAB"));

		MinLexicographicStrRotationK().OrderlyQueue("cba", 1);
        MinLexicographicStrRotationK().OrderlyQueue("baaca", 3);
        MinLexicographicStrRotationK().OrderlyQueue("ABCAAB", 1);
        MinLexicographicStrRotationK().OrderlyQueue("ABCAAB", 2);
	}
	{
		int begin, end;
		MaxSubArraySum().Kadane_2Pass(std::vector<int>({ -2, 1, -3, 4, -1, 2, 1, -5, 4 }), begin, end);
		MaxSubArraySum().Kadane_2Pass(std::vector<int>({ -2, -10, -3, -4, -7, -9, -1, -8, -5 }), begin, end);
		MaxSubArraySum().DP1D(&std::vector<int>({ -2, 1, -3, 4, -1, 2, 1, -5, 4 })[0], 9);
		MaxSubArraySum().DP(&std::vector<int>({ -2, 1, -3, 4, -1, 2, 1, -5, 4 })[0], 9);
		MaxSubArraySum().DivideConquerRecur(&std::vector<int>({ -2, 1, -3, 4, -1, 2, 1, -5, 4 })[0], 9);
		MaxSubArraySum().PrefixSum_Quadratic(std::vector<int>({ -2, 1, -3, 4, -1, 2, 1, -5, 4 }));

		MaxDiff2SubArraySum().DP1D(std::vector<int>({ 4, -1, 7 }));
		MaxDiff2SubArraySum().DP1D(std::vector<int>({ -1, -2, -3 }));
		MaxDiff2SubArraySum().DP1D(std::vector<int>({ -10, 7, -3, 2, 2, -20, 1 }));
		MaxDiff2SubArraySum().DP1D(std::vector<int>({ 2, -1, -2, 1, -4, 2, 8 }));

		MaxSubArraySumCircular().DP1D(std::vector<int>({ 904, 40, 523, 12, -335, -385, -124, 481, -31 }));
		MaxSubArraySumCircular().Math(std::vector<int>({ 904, 40, 523, 12, -335, -385, -124, 481, -31 }));
		MaxSubArraySumCircular().DP1D(std::vector<int>({ 10, -4, 5, -4, 10 }));
		MaxSubArraySumCircular().Math(std::vector<int>({ 10, -4, 5, -4, 10 }));
		MaxSubArraySumCircular().DP1D(std::vector<int>({ -2, 3, 5, 2, -4, -1 }));
		MaxSubArraySumCircular().Math(std::vector<int>({ -2, 3, 5, 2, -4, -1 }));
		MaxSubArraySumCircular().DP1D(std::vector<int>({ -4, -8, 0, 9, 2, -4 }));
		MaxSubArraySumCircular().Math(std::vector<int>({ -4, -8, 0, 9, 2, -4 }));
		MaxSubArraySumCircular().DP1D(std::vector<int>({ -10, -5, 5, 10, 9, 0 }));
		MaxSubArraySumCircular().Math(std::vector<int>({ -10, -5, 5, 10, 9, 0 }));
		MaxSubArraySumCircular().DP1D(std::vector<int>({ 7, 7, 3, 3, 5, 5 }));
		MaxSubArraySumCircular().Math(std::vector<int>({ 7, 7, 3, 3, 5, 5 }));

		//for (int i = 0; i < 10; ++i)
		//{
		//	std::vector<int> v = TestCase::RandVec<int>(6, -10, 10);
		//	MaxSubArraySumCircular().DP1D(v);
		//	MaxSubArraySumCircular().Math(v);
		//}

		MaxIncrSubArraySum().Kadane_2Pass(std::vector<std::pair<int, int>>(
		{ std::make_pair(0, -3), std::make_pair(1, 3), std::make_pair(4, -1), std::make_pair(6, 4), std::make_pair(5, 7), std::make_pair(6, -2), std::make_pair(7, 4), std::make_pair(8, -2), std::make_pair(7, 8), std::make_pair(9, -9), std::make_pair(10, 8), std::make_pair(11, 2), std::make_pair(12, -1) }
		), begin, end);

		//special cases: all non-zero numbers are individual negative isolated by 0(s) OR all 0(s)
		MaxSubArrayProduct().DP(std::vector<int>({ 0, 0, 0 }));
		MaxSubArrayProduct().DP_2Scans(std::vector<int>({ 0, 0, 0 }), begin, end);
		MaxSubArrayProduct().DP(std::vector<int>({ 0, -1 }));
		MaxSubArrayProduct().DP_2Scans(std::vector<int>({ 0, -1 }), begin, end);
		MaxSubArrayProduct().DP(std::vector<int>({ -1, 0 }));
		MaxSubArrayProduct().DP_2Scans(std::vector<int>({ -1, 0 }), begin, end);
		MaxSubArrayProduct().DP(std::vector<int>({ 0, -2, 0 }));
		MaxSubArrayProduct().DP_2Scans(std::vector<int>({ 0, -2, 0 }), begin, end);
		MaxSubArrayProduct().DP(std::vector<int>({ -1, 0, -2 }));
		MaxSubArrayProduct().DP_2Scans(std::vector<int>({ -1, 0, -2 }), begin, end);

		MaxSubArrayProduct().DP(std::vector<int>({ 2, -7, 0, 2, 3, 8, -6, 5 }));
		MaxSubArrayProduct().DP_2Scans(std::vector<int>({ 2, -7, 0, 2, 3, 8, -6, 5 }), begin, end);
		MaxSubArrayProduct().DP(std::vector<int>({ 2, -7, 0, 2, 3, 8, -6, 5, -1 }));
		MaxSubArrayProduct().DP_2Scans(std::vector<int>({ 2, -7, 0, 2, 3, 8, -6, 5, -1 }), begin, end);
		MaxSubArrayProduct().DP(std::vector<int>({ 0, -5, 9, -8, -9, 8, 0, -7, 9, -2, 1, -1, -8, -1, 1 }));
		MaxSubArrayProduct().DP_2Scans(std::vector<int>({ 0, -5, 9, -8, -9, 8, 0, -7, 9, -2, 1, -1, -8, -1, 1 }), begin, end);
		//for (int i = 0; i < 50; ++i)
		//{
		//	std::vector<int> v = TestCase::RandVec<int>(15, -9, 9);
		//	MaxSubArrayProduct().DP(v);
		//	MaxSubArrayProduct().DP_2Scans(v, begin, end);
		//}
	}
	{
		KMaxSubArraySum().UseSortedKMinPrefixSums(std::vector<int>({ -2, 1, -3, 4, -1, 2, 1, -5, 4 }), 17);
		KMaxSubArraySum().UseSortedKMinPrefixSums(std::vector<int>({ -2, -10, -3, -4, -7, -9, -1, -8, -5 }), 17);
	}
	{
		ShortestSubArrWGreaterSum().SlideWindow_Greater(std::vector<int>({ -6, -4, -7 }), -5);

		ShortestSubArrWGreaterSum().SlideWindow_Greater(std::vector<int>({ 2, -1, 0, 2, 1, -7, 1, 2, -1, 2, -5, 3, 0, 1, -4, 1, 3, -3, 4 }), 3);
		ShortestSubArrWGreaterSum().SlideWindow_Greater(std::vector<int>({ 2, -1, 0, 2, 1, -7, 1, 2, -1, 2, -5, 3, 0, 1, -4, 1, 3 }), 3);
		ShortestSubArrWGreaterSum().SlideWindow_Greater(std::vector<int>({ -1, 2, -1, 0, 2, -1, 2, 0, 1 }), 3);
		

		ShortestSubArrWGreaterSum().SlideWindow_Greater(std::vector<int>({ 1, 2, 3, 4, -10, -2, 22 }), 10);
		ShortestSubArrWGreaterSum().SlideWindow_Greater(std::vector<int>({ -3, -7, -5, -4, -2, -6, -8 }), -3);
		ShortestSubArrWGreaterSum().SlideWindow_Greater(std::vector<int>({ -3, -7, -5, -4, -2, -6, -8 }), 0);
		ShortestSubArrWGreaterSum().SlideWindow_Greater(std::vector<int>({ 7, -3, 8, 4, 13, -5 }), 15);

		ShortestSubArrWGreaterSum().SlideWindow_Greater(std::vector<int>({ 2, 1, 1, 4, 3, 6, 1 }), 8);
		ShortestSubArrWGreaterSum().SlideWindow_Greater(std::vector<int>({ 1, 1, 1, 1, 1, 1, 1, 1, 50 }), 57);//worst case O(n^2) time for case 1
		ShortestSubArrWGreaterSum().SlideWindow_Greater(std::vector<int>({ 1, 4, 45, 6, 10, 19 }), 51);
		ShortestSubArrWGreaterSum().SlideWindow_Greater(std::vector<int>({ 1, 10, 5, 2, 7 }), 9);
		ShortestSubArrWGreaterSum().SlideWindow_Greater(std::vector<int>({ 1, 11, 100, 1, 0, 200, 3, 2, 1, 250 }), 280);

		ShortestSubArrWGreaterSum().SlideWindow_GreaterEqual(std::vector<int>({ 2,3,1,2,4,3 }), 7);

		ShortestSubArrWGreaterSum().SlideWindow_GreaterEqual_PositiveNums(std::vector<int>({ 2,3,1,1 }), 7);
		ShortestSubArrWGreaterSum().SlideWindow_GreaterEqual_PositiveNums(std::vector<int>({ 2,3,1,2,4,3 }), 7);
		ShortestSubArrWGreaterSum().SlideWindow_GreaterEqual_PositiveNums(std::vector<int>({ 1,4,4 }), 4);
		ShortestSubArrWGreaterSum().SlideWindow_GreaterEqual_PositiveNums(std::vector<int>({ 10,3,1 }), 7);

		ShortestSubArrWGreaterSum().SortedPrefixSums_GreaterEqual_PositiveNums(std::vector<int>({ 2,3,1,1 }), 7);
		ShortestSubArrWGreaterSum().SortedPrefixSums_GreaterEqual_PositiveNums(std::vector<int>({ 2,3,1,2,4,3 }), 7);
		ShortestSubArrWGreaterSum().SortedPrefixSums_GreaterEqual_PositiveNums(std::vector<int>({ 1,4,4 }), 4);
		ShortestSubArrWGreaterSum().SortedPrefixSums_GreaterEqual_PositiveNums(std::vector<int>({ 10,3,1 }), 7);

        ShortestSubArrWGreaterSum().SortedQueue_GreaterEqual(std::vector<int>({2,-1,2}), 3);
        ShortestSubArrWGreaterSum().SortedQueue_GreaterEqual(std::vector<int>({-2,2,-1,2}), 3);
	}
	{
		LongestSubArrWLessEqualSum().Greedy_PrefixSums(std::vector<int>({ 431, -15, 639, 342, -14, 565, -924, 635, 167, -70 }), 184);
		LongestSubArrWLessEqualSum().BruteForce_PrefixSums(std::vector<int>({ 431, -15, 639, 342, -14, 565, -924, 635, 167, -70 }), 184);

		for (int i = 0; i < 30; ++i)
		{
			std::vector<int> v = TestCase::RandVec<int>(10, -30, 30);
			int num = TestCase::RandNum<int>(-30, 10);
			LongestSubArrWLessEqualSum().Greedy_PrefixSums(v, num);
			LongestSubArrWLessEqualSum().BruteForce_PrefixSums(v, num);
		}

		LongestSubArrWEqualSum().HashMap(std::vector<int>({ 1, -1, 5, -2, 3 }), 3);
		LongestSubArrWEqualSum().HashMap(std::vector<int>({ -2, -1, 2, 1 }), 1);

		LongestSubArrWMoreGreaterThan8NumCount().LongestOneAndMinusOneSubArrWPositiveSum(std::vector<int>({9,9,6,0,6,6,9}));
	}
	{
        SubArrayWGivenSum().SlideWindow_NonNegativeArr(std::vector<int>({ 0, 0, 0 }), 0);
		SubArrayWGivenSum().SlideWindow_NonNegativeArr(std::vector<int>({ 1, 2, 1, 0, 2, 1, 2, 0, 0, 1, 1, 2, 4 }), 4);
		SubArrayWGivenSum().SlideWindow_NonNegativeArr(std::vector<int>({ 1, 2, 1, -2, 0, 2, 1, 2, 0, 0, 1, -2, 1, 2, 4 }), 4);//wrong answer: miss [1,2,0,0,1]

		SubArrayWGivenSum().ExistSubArrSum_MultipleOfK(std::vector<int>({ 23,2,4,6,7 }), 6);
		SubArrayWGivenSum().ExistSubArrSum_MultipleOfK(std::vector<int>({ 23,2,6,4,7 }), 6);
	}
	{
		SubArrWLessEqualMinMaxDiff().SlideWindow(std::vector<int>({ 3, 5, 7, 6, 3 }), 2);
		SubArrWLessEqualMinMaxDiff().SlideWindow(std::vector<int>({ 4, 1, 6, 0, 5, 3, 2, 7, 6, 3, 9, 2, 4 }), 2);
	}
	{
		LongestBitonicSubArray().Len(std::vector<int>({ 20, 4, 1, 2, 3, 4, 2, 10 }));
		LongestBitonicSubArray().Len(std::vector<int>({ 9, 1, 3, 7, 4, 2, 5, 8, 10, 7, 6, 3, 5, 7, 1 }));
	}
	{
		LAPSubseq().ExistArithmeitcThree_Sorted(std::vector<int>({ 1, 7, 10, 13, 14, 19 }));//[1, 7, 13, 19]
		LAPSubseq().Len_DP2D_Sorted(std::vector<int>({ 1, 7, 10, 13, 14, 19 }));//[1, 7, 13, 19]

		LAPSubseq().ExistArithmeitcThree_Sorted(std::vector<int>({ 1, 7, 10, 15, 27, 29 }));//[1, 15, 29]
		LAPSubseq().Len_DP2D_Sorted(std::vector<int>({ 1, 7, 10, 15, 27, 29 }));//[1, 15, 29]

		LAPSubseq().ExistArithmeitcThree_Sorted(std::vector<int>({ 2, 4, 6, 8, 10 }));//[2, 4, 6, 8, 10]
		LAPSubseq().Len_DP2D_Sorted(std::vector<int>({ 2, 4, 6, 8, 10 }));//[2, 4, 6, 8, 10]

		LAPSubseq().Len_DP2D(std::vector<int>({ 20,1,15,3,10,5,8 }));
		LAPSubseq().FindAll_FixRecur(std::vector<int>({ 20,1,15,3,10,5,8 }));
	}
	{
		LongestEqualSumSubArrFrom2Arr().BruteForce_PrefixSums(std::vector<int>({ 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0 }), std::vector<int>({ 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0 }));
		LongestEqualSumSubArrFrom2Arr().BruteForce_PrefixSums(std::vector<int>({ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }), std::vector<int>({ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }));
		LongestEqualSumSubArrFrom2Arr().BruteForce_PrefixSums(std::vector<int>({ 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 }), std::vector<int>({ 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1 }));
		LongestEqualSumSubArrFrom2Arr().BruteForce_PrefixSums(std::vector<int>({ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }), std::vector<int>({ 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1 }));
		LongestEqualSumSubArrFrom2Arr().BruteForce_PrefixSums(std::vector<int>({ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }), std::vector<int>({ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }));
	}
	{
		RepeatedSubseq().CheckAllPairsInAlphabet(std::string("mnaopqrbstuavwbxyz"));
		RepeatedSubseq().CheckAllPairsInAlphabet(std::string("mnaopqrastubvwbxyz"));
		RepeatedSubseq().CheckAllPairsInAlphabet(std::string("mnaopqrastuavwaxyz"));
		RepeatedSubseq().CheckAllPairsInAlphabet(std::string("mcnaopaqcracstubvdwbxdydzb"));
	}
	{
		ClosestSubArraySum().Zero_MinAbsDiffOfAdjPairs_SortedPrefixSumArr(std::vector<int>({ 8, -3, 2, 1, -4, 10, -5 }));
		ClosestSubArraySum().Zero_MinAbsDiffOfAdjPairs_SortedPrefixSumArr(std::vector<int>({ -3, 2, 4, -6, -8, 10, 11 }));
		ClosestSubArraySum().Zero_MinAbsDiffOfAdjPairs_SortedPrefixSumArr(std::vector<int>({ 10, -2, 7 }));
		ClosestSubArraySum().Zero_MinAbsDiffOfAdjPairs_SortedPrefixSumArr(std::vector<int>({ 1, 7, -15, 10, -3 }));
		ClosestSubArraySum().Zero_MinAbsDiffOfAdjPairs_SortedPrefixSumArr(std::vector<int>({ 1, 7, -15, 10, -5 }));
		ClosestSubArraySum().Zero_MinAbsDiffOfAdjPairs_SortedPrefixSumArr(std::vector<int>({ 3, 11, -15, 10, -2 }));
		ClosestSubArraySum().Zero_MinAbsDiffOfAdjPairs_SortedPrefixSumArr(std::vector<int>({ 3, 7, -19, 6, -2 }));

		ClosestSubArraySum().K_MinAbsDiffOfAllPairs_SortedPrefixSumArr_Greedy(std::vector<int>({ 1, 7, -15, 10, -3 }), 0);
		ClosestSubArraySum().K_MinAbsDiffOfAllPairs_SortedPrefixSumArr_Greedy(std::vector<int>({ 1, 7, -15, 10, -5 }), 0);
		ClosestSubArraySum().K_MinAbsDiffOfAllPairs_SortedPrefixSumArr_Greedy(std::vector<int>({ 3, 11, -15, 10, -2 }), 0);
		ClosestSubArraySum().K_MinAbsDiffOfAllPairs_SortedPrefixSumArr_Greedy(std::vector<int>({ 3, 7, -19, 6, -2 }), 0);

		ClosestSubArraySum().K_MinAbsDiffOfAllPairs_PrefixSumArr_BruteForce(std::vector<int>({ 1, 7, -15, 10, -3 }), 0);
		ClosestSubArraySum().K_MinAbsDiffOfAllPairs_PrefixSumArr_BruteForce(std::vector<int>({ 1, 7, -15, 10, -5 }), 0);
		ClosestSubArraySum().K_MinAbsDiffOfAllPairs_PrefixSumArr_BruteForce(std::vector<int>({ 3, 11, -15, 10, -2 }), 0);
		ClosestSubArraySum().K_MinAbsDiffOfAllPairs_PrefixSumArr_BruteForce(std::vector<int>({ 3, 7, -19, 6, -2 }), 0);
	}
	{
		LongestSubArrWEqualElements().FromSortedArray(std::vector<int>({ 1, 1, 1, 1, 1, 1, 2, 3, 3, 3, 4, 4, 4, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8 }));
		LongestSubArrWEqualElements().FromSortedArray(std::vector<int>({ 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 3, 4, 5, 6, 7 }));
		LongestSubArrWEqualElements().Iterate(std::vector<int>({ 2, 3, 3, 3, 1, 1, 1, 1, 1, 1, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4, 4, 8, 8, 8, 8 }));
		LongestSubArrWEqualElements().Iterate(std::vector<int>({ 1, 1, 1, 1, 1, 2, 1, 4, 5, 6, 7, 1, 1, 2, 3 }));
	}
	{
		LongestSubArrPredicate().Length(std::vector<int>({ 3, 5, 5, 7, 3, 0, 0, 9, 9, 0, 0, 0, 0, 0, 6, 4, 4, 3, 6, 8 }), [](const int & a)->bool{ return a == 0; });
	}
	{
		RepeatedDNASubstr().HashTable(std::string("AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"));
	}
	{
		SlidingWindowMax().SortedQueue(std::vector<int>({ 1,3,-1,-3,5,3,6,7 }), 3);
	}
	{
		std::cout << "5 % 3 = " << (5 % 3) << std::endl;
		std::cout << "3 % 5 = " << (3 % 5) << std::endl;
		LargestDivisibleSet().DP(std::vector<int>({ 1,2,3 }));
		LargestDivisibleSet().DP(std::vector<int>({ 1,2,4,8 }));
	}
	{
		RangeAddition().getModifiedArray(5, std::vector<std::vector<int>>(
		{
			{ 1,3,2 },
			{ 2,4,3 },
			{ 0,2,-2 },
		}));
	}
	{
		ThreeIncrElementsInArray().Exist_Find(std::vector<int>({ 10, 16, 14, 11, 3, 7, 6, 5, 4, 2, 1, 5, 0 }));
		ThreeIncrElementsInArray().Exist_Find(std::vector<int>({ 10, 16, 14, 11, 3, 7, 6, 5, 4, 2, 0, 1, 2 }));
		ThreeIncrElementsInArray().Exist_Find(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2 }));
		ThreeIncrElementsInArray().Exist_Find(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2, 17 }));
		ThreeIncrElementsInArray().Exist_Find(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 4, 3, 2, 7 }));

		ThreeIncrElementsInArray().Exist_Find2(std::vector<int>({ 10, 16, 14, 11, 3, 7, 6, 5, 4, 2, 1, 5, 0 }));
		ThreeIncrElementsInArray().Exist_Find2(std::vector<int>({ 10, 16, 14, 11, 3, 7, 6, 5, 4, 2, 0, 1, 2 }));
		ThreeIncrElementsInArray().Exist_Find2(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2 }));
		ThreeIncrElementsInArray().Exist_Find2(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2, 17 }));
		ThreeIncrElementsInArray().Exist_Find2(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 4, 3, 2, 7 }));

		ThreeIncrElementsInArray().Find(std::vector<int>({ 10, 16, 14, 11, 3, 7, 6, 5, 4, 2, 1, 5, 0 }));
		ThreeIncrElementsInArray().Find(std::vector<int>({ 10, 16, 14, 11, 3, 7, 6, 5, 4, 2, 0, 1, 2 }));
		ThreeIncrElementsInArray().Find(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2 }));
		ThreeIncrElementsInArray().Find(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2, 17 }));
		ThreeIncrElementsInArray().Find(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 4, 3, 2, 7 }));

		ThreeIncrElementsInArray().DP1D(std::vector<int>({ 10, 16, 14, 11, 3, 7, 6, 5, 4, 2, 1, 5, 0 }));
		ThreeIncrElementsInArray().DP1D(std::vector<int>({ 10, 16, 14, 11, 3, 7, 6, 5, 4, 2, 0, 1, 2 }));
		ThreeIncrElementsInArray().DP1D(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2 }));
		ThreeIncrElementsInArray().DP1D(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2, 17 }));
		ThreeIncrElementsInArray().DP1D(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 4, 3, 2, 7 }));

		ThreeIncrElementsInArray().BruteForce(std::vector<int>({ 10, 16, 14, 11, 3, 7, 6, 5, 4, 2, 1, 5, 0 }));
		ThreeIncrElementsInArray().BruteForce(std::vector<int>({ 10, 16, 14, 11, 3, 7, 6, 5, 4, 2, 0, 1, 2 }));
		ThreeIncrElementsInArray().BruteForce(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2 }));
		ThreeIncrElementsInArray().BruteForce(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 1, 4, 3, 2, 17 }));
		ThreeIncrElementsInArray().BruteForce(std::vector<int>({ 10, 16, 15, 14, 9, 13, 12, 11, 5, 8, 7, 6, 4, 3, 2, 7 }));

		ThirdMaximumNumber().Solve(std::vector<int>({ 2,2,3,1 }));
	}
	{
		DistinctSubsequences().InExcludeRecur("rabbbit", "rabbit");
		DistinctSubsequences().DP_2D("rabbbit", "rabbit");
		DistinctSubsequences().DP_1D("rabbbit", "rabbit");
		DistinctSubsequences().InExcludeRecur("abcde", "ace");
		DistinctSubsequences().DP_2D("abcde", "ace");
		DistinctSubsequences().DP_1D("abcde", "ace");
		DistinctSubsequences().InExcludeRecur("abcde", "aec");
		DistinctSubsequences().DP_2D("abcde", "aec");
		DistinctSubsequences().DP_1D("abcde", "aec");
	}
	{
		DistinctSubsequences2().CountDP1D("abc");
		DistinctSubsequences2().CountDP1D("abcd");
		DistinctSubsequences2().CountDP1D("abad");
		DistinctSubsequences2().CountDP1D("gfg");
		DistinctSubsequences2().CountDP1D("ggg");
	}
	{
		LCS().Len_Recur(std::string("abcedfghi"), std::string("bxefhki"));
		LCS().Len_DP2D_Iterate(std::string("abcedfghi"), std::string("bxefhki"));
		ShortestCommonSuperSeq().UseLCS(std::string("abcedfghi"), std::string("bxefhki"));
	}
	{
		LCSubstr().Len_DP2D("acabcd", "caabcd");
		LCSubstr().Len_DP2D("wgekaaa", "vlgekw");
		LCSubstr().Len_SuffixArray("wgekaaa", "vlgekw");
		LCSubstr().Len_SuffixArray("aabcy", "abab");
		LCSubstr().Len_3Str_SuffixArray("abababca", "aababc", "aaababca");
	}
	{
		const char * psTxt = "AABAACAADAABAAABAA";
		const char * psPat = "AABA";
		PatternSearching().BruteForce(psPat, psTxt);
		PatternSearching().BruteForceModified(psPat, psTxt);
		PatternSearching().KMP(psPat, psTxt);
		PatternSearching().RabinKarp(psPat, psTxt, 101);//101: a prime number
		PatternSearching().SuffixArray(std::string("AABA"), std::string("AABAACAADAABAAABAA"));
		PatternSearching().BoyerMoore(std::string("AABA"), std::string("AABAACAADAABAAABAA"));

		ImplementStrStr2().BruteForce(std::string("AABAACAADAABAAABAA"), std::string("AABA"));
		ImplementStrStr2().BoyerMoore(std::string("AABAACAADAABAAABAA"), std::string("AABA"));
		ImplementStrStr2().RabinKarp(std::string("AABAACAADAABAAABAA"), std::string("AABA"));
		ImplementStrStr2().KMP(std::string("AABAACAADAABAAABAA"), std::string("AABA"));

		ImplementStrStr2().GetLPS(std::string("ABCABC"));
		ImplementStrStr2().GetLPS(std::string("ABCABCABC"));
		ImplementStrStr2().GetLPS(std::string("AAAAAA"));
		ImplementStrStr2().GetLPS(std::string("ABCXABC"));
	}
	{
		Kmismatch().BruteForce("ABCD", "ABCCBDCDCD", 2);
		Kmismatch().Kangaroo_SuffixArray("ABCD", "ABCCBDCDCD", 2);
		Kmismatch().BruteForce("AABA", "AABAACAADAABAAABAA", 2);
		Kmismatch().Kangaroo_SuffixArray("AABA", "AABAACAADAABAAABAA", 2);
	}
	{
		LongestCommonPrefix().MultiStrs(std::vector<std::string>({ std::string("abcdef"), std::string("abcxyz"), std::string("abc"), std::string("abc123"), std::string("abcc") }));
		LongestCommonPrefix().TwoStrs(std::string("abcxyzij"), std::string("abcde"));
		LongestCommonPrefix().MultiStrs(std::vector<std::string>({ std::string("cdef"), std::string("abcxyz"), std::string("xyz"), std::string("ijk123"), std::string("mnopq") }));
		LongestCommonPrefix().TwoStrs(std::string("xyz"), std::string("abcde"));
		LongestCommonPrefix().MultiStrs(std::vector<std::string>({ std::string("abc"), std::string("abc"), std::string("abc"), std::string("abc"), std::string("abc") }));
		LongestCommonPrefix().TwoStrs(std::string("abc"), std::string("abcdef"));
	}
	{
		ShortestUniquePrefix().UseTrie(std::vector<std::string>({ "dog", "be", "cut" }), "cat");
		ShortestUniquePrefix().UseTrie(std::vector<std::string>({ "dog", "be", "cut", "car" }), "cat");
		ShortestUniquePrefix().UseTrie(std::vector<std::string>({ "dog", "be", "cut", "car", "cat" }), "cat");
	}
	{
		RegexMatching().IsMatch_Recur(std::string("b"), std::string("a*b"));
		RegexMatching().IsMatch_Recur(std::string("ab"), std::string("a*b"));
		RegexMatching().IsMatch_Recur(std::string("aaaab"), std::string("a*b"));
		RegexMatching().IsMatch_Recur(std::string("b"), std::string("a*."));
		RegexMatching().IsMatch_Recur(std::string("ab"), std::string("a*."));
		RegexMatching().IsMatch_Recur(std::string("aaaab"), std::string("a*."));
		RegexMatching().IsMatch_Recur(std::string("xyaW9123"), std::string("a.9"));

		RegexMatching().IsMatch_DP2D(std::string("b"), std::string("a*b"));
		RegexMatching().IsMatch_DP2D(std::string("ab"), std::string("a*b"));
		RegexMatching().IsMatch_DP2D(std::string("aaaab"), std::string("a*b"));
		RegexMatching().IsMatch_DP2D(std::string("b"), std::string("a*."));
		RegexMatching().IsMatch_DP2D(std::string("ab"), std::string("a*."));
		RegexMatching().IsMatch_DP2D(std::string("aaaab"), std::string("a*."));
		RegexMatching().IsMatch_DP2D(std::string("xyaW9123"), std::string("a.9"));

        RegexMatching().IsMatch_DP2D_Plus(std::string("b"), std::string("a+b"));
        RegexMatching().IsMatch_DP2D_Plus(std::string("ab"), std::string("a+b"));
        RegexMatching().IsMatch_DP2D_Plus(std::string("aaaab"), std::string("a+b"));
        RegexMatching().IsMatch_DP2D_Plus(std::string("b"), std::string("a+."));
        RegexMatching().IsMatch_DP2D_Plus(std::string("ab"), std::string("a+."));
        RegexMatching().IsMatch_DP2D_Plus(std::string("aaaab"), std::string("a+."));
        RegexMatching().IsMatch_DP2D_Plus(std::string("xyaW9123"), std::string("..a+.9..."));
        RegexMatching().IsMatch_DP2D_Plus(std::string("xyaW9123"), std::string("..b+.9..."));

		ExtendedSimpleRegexMatching().Recur(std::string("a"), std::string("aa"));
		ExtendedSimpleRegexMatching().Recur(std::string("aW9"), std::string("xyaW9123"));
		ExtendedSimpleRegexMatching().Recur(std::string("a.9"), std::string("xyaW9123"));
		ExtendedSimpleRegexMatching().Recur(std::string("^aW9"), std::string("aW9123"));
		ExtendedSimpleRegexMatching().Recur(std::string("aW9$"), std::string("xyaW9"));
		ExtendedSimpleRegexMatching().Recur(std::string("^aW9$"), std::string("aW9"));
		ExtendedSimpleRegexMatching().Recur(std::string("^aW.*9$"), std::string("aWxyz9"));
	}
	{
		char str[] = "abc";
		std::cout << strlen(str) << std::endl;
		std::cout << strlen(&std::string("abc")[0]) << std::endl;

		WildcardMatching().IsMatch_Recur(std::string("aa"), std::string("a"));
		WildcardMatching().IsMatch_Recur(std::string("aa"), std::string("aa"));
		WildcardMatching().IsMatch_Recur(std::string("aaa"), std::string("aa"));
		WildcardMatching().IsMatch_Recur(std::string("aa"), std::string("*"));
		WildcardMatching().IsMatch_Recur(std::string("aa"), std::string("a*"));
		WildcardMatching().IsMatch_Recur(std::string("ab"), std::string("?*"));
		WildcardMatching().IsMatch_Recur(std::string("aab"), std::string("c*a*b"));
		WildcardMatching().IsMatch_Recur(std::string("acc"), std::string("a*b"));

		WildcardMatching().IsMatch_Iterate(std::string("aa"), std::string("a"));
		WildcardMatching().IsMatch_Iterate(std::string("aa"), std::string("aa"));
		WildcardMatching().IsMatch_Iterate(std::string("aaa"), std::string("aa"));
		WildcardMatching().IsMatch_Iterate(std::string("aa"), std::string("*"));
		WildcardMatching().IsMatch_Iterate(std::string("aa"), std::string("a*"));
		WildcardMatching().IsMatch_Iterate(std::string("ab"), std::string("?*"));
		WildcardMatching().IsMatch_Iterate(std::string("aab"), std::string("c*a*b"));
		WildcardMatching().IsMatch_Iterate(std::string("acc"), std::string("a*b"));

		WildcardMatching().IsMatch_DP2D(std::string("aa"), std::string("a"));
		WildcardMatching().IsMatch_DP2D(std::string("aa"), std::string("aa"));
		WildcardMatching().IsMatch_DP2D(std::string("aaa"), std::string("aa"));
		WildcardMatching().IsMatch_DP2D(std::string("aa"), std::string("*"));
		WildcardMatching().IsMatch_DP2D(std::string("aa"), std::string("a*"));
		WildcardMatching().IsMatch_DP2D(std::string("ab"), std::string("?*"));
		WildcardMatching().IsMatch_DP2D(std::string("aab"), std::string("c*a*b"));
		WildcardMatching().IsMatch_DP2D(std::string("acc"), std::string("a*b"));

		WildcardMatching().IsMatch_DP2D_2(std::string("aa"), std::string("a"));
		WildcardMatching().IsMatch_DP2D_2(std::string("aa"), std::string("aa"));
		WildcardMatching().IsMatch_DP2D_2(std::string("aaa"), std::string("aa"));
		WildcardMatching().IsMatch_DP2D_2(std::string("aa"), std::string("*"));
		WildcardMatching().IsMatch_DP2D_2(std::string("aa"), std::string("a*"));
		WildcardMatching().IsMatch_DP2D_2(std::string("ab"), std::string("?*"));
		WildcardMatching().IsMatch_DP2D_2(std::string("aab"), std::string("c*a*b"));
		WildcardMatching().IsMatch_DP2D_2(std::string("acc"), std::string("a*b"));
	}
	{
		LongestPalindromeSubseq().Len_Recur(std::string("ydijkrlmlkjixabcbayz"));
		LongestPalindromeSubseq().Len_DP2D(std::string("ydijkrlmlkjixabcbayz"));
		LongestPalindromeSubseq().Len_byLCS(std::string("ydijkrlmlkjixabcbayz"));
	}
	{
		LongestPalindromeSubstr().IsPalindrome(std::string("a b c d c b   a"));
		LongestPalindromeSubstr().IsPalindrome(std::string("A man, a plan, a canal, Panama."));
		LongestPalindromeSubstr().IsPalindrome(std::string("Able was I, ere I saw Elba!"));
		LongestPalindromeSubstr().IsPalindrome(&std::string("a b c d c b   a")[0]);//std::string to char *
		LongestPalindromeSubstr().IsPalindrome(&std::string("A man, a plan, a canal, Panama.")[0]);
		LongestPalindromeSubstr().IsPalindrome(&std::string("Able was I, ere I saw Elba!")[0]);

		//char * s = "Qaabcddcba123321EABCDEDCBAeQesdxyzzyxrtaweeesssdifjo";
		LongestPalindromeSubstr().BruteForce(std::string("babcbabcbaccba"));
		LongestPalindromeSubstr().Greedy(std::string("babcbabcbaccba"));
		LongestPalindromeSubstr().Greedy2(std::string("babcbabcbaccba"));
		LongestPalindromeSubstr().Manacher(std::string("babcbabcbaccba"));
		LongestPalindromeSubstr().DP2D(std::string("babcbabcbaccba"));
		LongestPalindromeSubstr().SuffixArray(std::string("babcbabcbaccba"));
	}
	{
		ShortestPalindrome().BruteForce(std::string("abcd"));
		ShortestPalindrome().BruteForce(std::string("abbacd"));
        ShortestPalindrome().BruteForce(std::string("abacd"));
		ShortestPalindrome().BruteForce(std::string("abba"));
		ShortestPalindrome().UseLPS_KMP(std::string("abcd"));
		ShortestPalindrome().UseLPS_KMP(std::string("abbacd"));
        ShortestPalindrome().UseLPS_KMP(std::string("abacd"));
		ShortestPalindrome().UseLPS_KMP(std::string("abba"));
	}
	{
		PalindromePairs().UseHashMap(std::vector<std::string>({ "bat", "tab", "cat" }));
		PalindromePairs().UseHashMap(std::vector<std::string>({ "abcd", "dcba", "lls", "s", "sssll" }));
	}
	{
		RepeatedSubstringPattern().UseKMP(std::string("abab"));
		RepeatedSubstringPattern().UseKMP(std::string("aba"));
		RepeatedSubstringPattern().UseKMP(std::string("abcabcabcabc"));
	}
	{
		IsSubsequence().Validate("abc", "ahbgdc");
		IsSubsequence().Validate("axc", "ahbgdc");
	}
	{
		LongestSubStrWLeastKRepeatChars().Recur("aaabb", 3);
		LongestSubStrWLeastKRepeatChars().Recur("ababbc", 2);
	}
	{
		ArithmeticProgressionSubseq().CountArithmeticSubarr(std::vector<int>({ 1, 2, 3, 4 }));
		ArithmeticProgressionSubseq().CountArithmeticSubseq(std::vector<int>({ 2, 4, 6, 8, 10 }));
	}
	{
		LongestSubArrWSameChars_AtMostKReplace().SlideWindow(std::string("ABAB"), 2);
		LongestSubArrWSameChars_AtMostKReplace().SlideWindow(std::string("AABABBA"), 1);

		LongestConsecu1s_AtMost1Replace().SlideWindow(std::vector<int>({ 1,0,1,1,0 }));
		LongestConsecu1s_AtMost1Replace().FromStream(std::vector<int>({ 1,0,1,1,0 }));

		LongestConsecu1s_AtMostKReplace().SlideWindow(std::vector<int>({1,1,1,0,0,0,1,1,1,1,0}),2);
	}
	{
		Pattern132().SolveStack(std::vector<int>({ 8,6,5,7,3,4,2,1,0,1,3,4,5 }));
	}
	{
		UniqueSubstrInWraproundStr().DP(std::string("zkbcdzabcd"));
	}
	{
		LongestUncommonSubseq().LUSOf2(std::string("aba"), std::string("cdc"));
		LongestUncommonSubseq().LUSOfArray(std::vector<std::string>({ "aaa","aaa","aa" }));
		LongestUncommonSubseq().LUSOfArray(std::vector<std::string>({ "aabbcc","aabbcc","ab" }));
		LongestUncommonSubseq().LUSOfArray(std::vector<std::string>({ "aabbcc","aabbcc","ab", "bcc", "aabbccc" }));
	}
	{
		CountAllPalindromeSubstr().DP2D(std::string("abaab"));
		CountAllPalindromeSubstr().DP2D(std::string("abaaba"));
		CountAllPalindromeSubstr().DP2D(std::string("abbaeae"));
		CountAllPalindromeSubstr().DP2D(std::string("abbaeaea"));
	}
	{
		FindAllDistinctPalindromeSubstr().Greedy(std::string("abaaa"));
		FindAllDistinctPalindromeSubstr().Greedy(std::string("abaaba"));
		FindAllDistinctPalindromeSubstr().Greedy(std::string("abbaeaea"));
	}
    {
        CountAllPalindromeSubseq().DP2D(std::string("bccb"));
        CountAllPalindromeSubseq().DP2D(std::string("abaab"));
        CountAllPalindromeSubseq().DP2D(std::string("abaaba"));
        CountAllPalindromeSubseq().DP2D(std::string("abbaeae"));
        //CountAllPalindromeSubseq().DP2D(std::string("abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba"));
    }
	{
        CountSubArrWSumEqualK().NonNegativeNums_SlideWindow(std::vector<int>({ 1,1,1 }), 2);
		CountSubArrWSumEqualK().UsePrefixSumMap(std::vector<int>({ 1,1,1 }), 2);
		CountSubArrWSumEqualK().FindAll_PrefixSumMap(std::vector<int>({ 1,1,1 }), 2);

		CountSubArrWSumEqualK().UsePrefixSumMap(std::vector<int>({ 0, 1, 0, -2, 2, 1, 0, 0, -2 }), 1);
		CountSubArrWSumEqualK().FindAll_PrefixSumMap(std::vector<int>({ 0, 1, 0, -2, 2, 1, 0, 0, -2 }), 1);
	}
	{
		MatchOrderBtwMatrixArray().BruteForce(std::vector<std::vector<std::string>>(
		{
			{ "apple","apple" },
			{ "banana","anything","banana" },
		}), std::vector<std::string>({ "orange","apple","apple","banana","orange","banana" }));

		MatchOrderBtwMatrixArray().BruteForce(std::vector<std::vector<std::string>>(
		{
			{ "apple","apple" },
			{ "banana","anything","banana" },
		}), std::vector<std::string>({ "banana","orange","banana","apple","apple" }));

		MatchOrderBtwMatrixArray().BruteForce(std::vector<std::vector<std::string>>(
		{
			{ "apple","apple" },
			{ "banana","anything","banana" },
		}), std::vector<std::string>({ "apple","banana","apple","banana","orange","banana" }));

		MatchOrderBtwMatrixArray().BruteForce(std::vector<std::vector<std::string>>(
		{
			{ "apple","apple" },
			{ "apple","apple","banana" },
		}), std::vector<std::string>({ "apple","apple","apple","banana" }));

		MatchOrderBtwMatrixArray().BruteForce(std::vector<std::vector<std::string>>(
		{
			{ "orange" },
			{ "apple","apple" },
			{ "banana","orange","apple" },
			{ "banana" }
		}), std::vector<std::string>({ "orange","apple","apple","banana","orange","apple","banana" }));

		MatchOrderBtwMatrixArray().BruteForce(std::vector<std::vector<std::string>>(
		{
			{ "apple","apricot" },
			{ "banana","anything","guava" },
			{ "papaya","anything" },
		}), std::vector<std::string>({ "banana","orange","guava","apple","apricot","papaya","kiwi" }));
	}
    {
        RepeatedStringMatch().BruteForce(std::string("abcd"), std::string("cdabcdab"));
        RepeatedStringMatch().BruteForce(std::string("abaabaa"), std::string("abaababaab"));
        RepeatedStringMatch().UseKMP(std::string("abcd"), std::string("cdabcdab"));
        RepeatedStringMatch().UseKMP(std::string("abaabaa"), std::string("abaababaab"));
    }
    {
        ShortestSubArrContainMaxFreqNums().GetLen_HashMap(std::vector<int>({1,2,2,3,1}));
        ShortestSubArrContainMaxFreqNums().GetLen_HashMap(std::vector<int>({1,2,2,3,1,4,2}));
    }
    {
        FindFirstDayContainKEmptySlots().UseSet(std::vector<int>({1,5,2,4,3}), 2);
    }
    {
        MaxMSubArrSumWSizeK().DP2D(std::vector<int>({1,2,1,2,6,7,5,1}), 2, 3);
    }
    {
        AllSubstrSizeKContainDistinctChars().SlideWindow1(std::string("awaglknagawunagwkwagl"), 4);
        AllSubstrSizeKContainDistinctChars().SlideWindow2(std::string("awaglknagawunagwkwagl"), 4);
    }
    {
        SumOfAllSubArrMins().UseMonotoneIncrStk(std::vector<int>({3,1,2,4}));

        CountSubArrWLeftmostNumLessEqualToAll().UseStack(std::vector<int>({1,4,2,5,3,1}));
    }
    {
        CountSubArrWSumDivisibleByK().UsePrefixSumMap(std::vector<int>({4,5,0,-2,-3,1}), 5);
    }
    {
        MaxDistToClosestPerson().FindLongest0sSubArr(std::vector<int>({1,0,0,0,1,0,1}));
        MaxDistToClosestPerson().FindLongest0sSubArr(std::vector<int>({1,0,0,0}));
    }
    {
        LBSubArr().BruteForce(std::vector<int>({2,1,4,7,3,2,5}));
        LBSubArr().DP(std::vector<int>({2,1,4,7,3,2,5}));
        LBSubArr().OnePass(std::vector<int>({2,1,4,7,3,2,5}));
    }
    {
        LongestAlternatingSubArr().Solve(std::vector<int>({9,4,2,10,7,8,8,1,9}));
    }
    {
        LongestFibonacciSubseq().BruteForce(std::vector<int>({1,2,3,4,5,6,7,8}));
        LongestFibonacciSubseq().DP(std::vector<int>({1,2,3,4,5,6,7,8}));
    }
    {
        AllNumsInLeftSubArrLessEqualRight().Test(std::vector<int>({1,1,1,0,6,12}));
    }
    {
        CountSubArrWKDistinctEntries().Solve(std::vector<int>({1,2,1,2,3}), 2);
    }
    {
        CountSubsetsWMinMaxSumEqualK().TwoPtrsFromSortedArr(std::vector<int>({1,2,3,4,5}), 6);
    }
    {
        MaxSum2NonOvlpSubArrays().DP_SlideWindow(std::vector<int>({2,1,5,6,0,9,5,0,3,8}), 4, 3);
    }
    {
        LongestVowelsRemoveAtMost2Substrs().Solve("aaabbbaabbabaaababaaa");
        LongestVowelsRemoveAtMost2Substrs().Solve("bbaaaaabbaabb");
        LongestVowelsRemoveAtMost2Substrs().Solve("aaaa");
        LongestVowelsRemoveAtMost2Substrs().Solve("bbbb");
    }
    {
        MinSwapToGroup1From01Arr().SlideWindow(std::vector<int>({1,0,1,0,1,0,0,1,1,0,1}));
    }
    {
        CountSubstrSizeKWDistinctChars().SlideWindow(std::string("havefunonleetcode"), 5);
    }
    {
        CountSubArrWMaxInRange().SlideWindow(std::vector<int>({2,1,4,3}),2,3);
    }
    {
        MinConsecuKFlipIn01Arr().SlideWindow(std::vector<int>({0,0,0,1,0,1,1,0}),3);
    }

#endif
#ifdef _CompareString_
	/*Compare String*/
	RdCout ? redirect_cout::to_file("Out_CompareString.txt") : redirect_cout::to_cout();
	PrintH("Compare String");
	{
		EditDistance().Recur("abcd", "axc");
		EditDistance().Recur2("abcd", "axc");
		EditDistance().DP2D_Iterate("abcd", "axc");
		EditDistance().DP1D_Iterate("abcd", "axc");

		EditDistance().DP2D_Iterate("abxcdycba", "abcydcxba");
		EditDistance().DP2D_Iterate("abxcdycbaz", "zabcydcxba");
		EditDistance().DP2D_Iterate("Carthorse", "Orchestra");
		EditDistance().DP2D_Iterate("Saturday", "Sunday");
		EditDistance().DP2D_Iterate("kitten", "sitting");

		EditDistance().DP1D_Iterate("abxcdycba", "abcydcxba");
		EditDistance().DP1D_Iterate("abxcdycbaz", "zabcydcxba");
		EditDistance().DP1D_Iterate("Carthorse", "Orchestra");
		EditDistance().DP1D_Iterate("Saturday", "Sunday");
		EditDistance().DP1D_Iterate("kitten", "sitting");
	}
	{
		LevenshteinDistance ld;
		ld.insert("how are you doing");
		ld.traverse();
		std::cout << "LevenshteinDistance = " << ld.search("you allergic any medication") << std::endl;
	}
	{
		AnonymousLetter().Constructable_HashTable(std::string("abccaba"), std::string("mcnbopqcrstauvacwcxyazb"));
	}
	{
		CompareVersionNumbers().Solve(std::string("1.1.2.3"), std::string("1.1.2.3.0.0.1"));
	}
	{
		OneEditDistance().Solve(std::string("abcd"), std::string("abc"));
		OneEditDistance().Solve(std::string("abcd"), std::string("axcd"));
		OneEditDistance().Solve(std::string("xabc"), std::string("abc"));
		OneEditDistance().Solve(std::string("abcd"), std::string("abcd"));
		OneEditDistance().Solve(std::string("abcd"), std::string("axc"));
	}
	{
		MasterMindGame().Estimate(std::string("RGBY"), std::string("GGRR"));
		MasterMindGame().Estimate(std::string("RGGB"), std::string("YRGB"));
		MasterMindGame().BullsAndCows(std::string("1807"), std::string("7810"));
		MasterMindGame().BullsAndCows(std::string("1123"), std::string("0111"));
	}
	{
		IsomorphicStrings().Solve(std::string("egg"), std::string("add"));
		IsomorphicStrings().Solve(std::string("foo"), std::string("bar"));
		IsomorphicStrings().Solve(std::string("paper"), std::string("title"));
	}
	{
		UniqueWordAbbreviation uwa(std::vector<std::string>({ "deer", "door", "cake", "card" }));
		uwa.isUnique("dear");
		uwa.isUnique("cart");
		uwa.isUnique("cane");
		uwa.isUnique("make");
	}
	{
		MaxProductOfWordLength().ConvertToBitMap(std::vector<std::string>({ "abcw","baz","foo","bar","xtfn","abcdef" }));
		MaxProductOfWordLength().ConvertToBitMap(std::vector<std::string>({ "a", "ab", "abc", "d", "cd", "bcd", "abcd" }));
		MaxProductOfWordLength().ConvertToBitMap(std::vector<std::string>({ "a", "aa", "aaa", "aaaa" }));
	}
	{
		MinMaxRightLeftHandWord().Match(std::vector<std::string>({ "eagle", "cat", "dog", "fish", "lion", "bear", "lamb", "pig", "ox", "olm", "molly" }));
	}
	{
		CamelCaseNotationMatching().Linear(std::vector<std::string>({ "HelloMars", "HelloWorld", "HelloWorldMars", "HiHo" }), std::string("H"));
		CamelCaseNotationMatching().Linear(std::vector<std::string>({ "HelloMars", "HelloWorld", "HelloWorldMars", "HiHo" }), std::string("HW"));
		CamelCaseNotationMatching().Linear(std::vector<std::string>({ "HelloMars", "HelloWorld", "HelloWorldMars", "HiHo" }), std::string("WM"));
		CamelCaseNotationMatching().Linear(std::vector<std::string>({ "HelloMars", "HelloWorld", "HelloWorldMars", "HiHo" }), std::string("HWM"));
		CamelCaseNotationMatching().Linear(std::vector<std::string>({ "HelloMars", "HelloWorld", "HelloWorldMars", "HiHo" }), std::string("HH"));
		CamelCaseNotationMatching().Linear(std::vector<std::string>({ "HelloMars", "HelloWorld", "HelloWorldMars", "HiHo" }), std::string("M"));

		CamelCaseNotationMatching().Linear(std::vector<std::string>({ "HelloMars", "HelloWorld", "HelloWorldMars", "HiHo" }), std::string("He"));
		CamelCaseNotationMatching().Linear(std::vector<std::string>({ "HelloMars", "HelloWorld", "HelloWorldMars", "HiHo" }), std::string("Ho"));
		CamelCaseNotationMatching().Linear(std::vector<std::string>({ "HelloMars", "HelloWorld", "HelloWorldMars", "HiHo" }), std::string("HeWorM"));
		CamelCaseNotationMatching().Linear(std::vector<std::string>({ "HelloMars", "HelloWorld", "HelloWorldMars", "HiHo" }), std::string("HeWxM"));

		CamelCaseNotationMatching().Linear(std::vector<std::string>({ "WelcomeGeek", "WelcomeToGeeksForGeeks", "GeeksForGeeks" }), std::string("WTG"));
		CamelCaseNotationMatching().Linear(std::vector<std::string>({ "WelcomeGeek", "WelcomeToGeeksForGeeks", "GeeksForGeeks" }), std::string("GFG"));
		CamelCaseNotationMatching().Linear(std::vector<std::string>({ "WelcomeGeek", "WelcomeToGeeksForGeeks", "GeeksForGeeks" }), std::string("GG"));

		CamelCaseNotationMatching().Linear(std::vector<std::string>({ "WelcomeGeek", "WelcomeToGeeksForGeeks", "GeeksForGeeks" }), std::string("We"));
		CamelCaseNotationMatching().Linear(std::vector<std::string>({ "WelcomeGeek", "WelcomeToGeeksForGeeks", "GeeksForGeeks" }), std::string("WeGe"));
		CamelCaseNotationMatching().Linear(std::vector<std::string>({ "WelcomeGeek", "WelcomeToGeeksForGeeks", "GeeksForGeeks" }), std::string("Ge"));

		CamelCaseNotationMatching().Better(std::vector<std::string>({"FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"}), std::string("FB"));
	}
	{
		ClosestRepetition().Iterate_HashTable(std::vector<std::string>({ "All", "work", "and", "no", "play", "makes", "for", "no", "work", "no", "fun", "and", "no", "results" }));
	}
	{
		HighestAffinityPair().HashTable(std::vector<std::pair<std::string, std::string>>({ { "yahoo", "ap42" },{ "google", "ap42" },{ "twitter", "th1" },{ "google", "aa314" },{ "google", "aa314" },{ "google", "th1" },{ "twitter", "aa314" },{ "twitter", "ap42" },{ "yahoo", "aa314" }, }));
	}
	{
		MinDistBtw2WordsInFile().OneScan(std::vector<std::string>({ "ace", "tea", "and", "ad", "eat", "kk", "eat", "dan", "ate", "tea", "abc", "eat", "xyz" }), std::string("tea"), std::string("eat"));
		std::unordered_map<std::string, std::vector<int>> wordMap = MinDistBtw2WordsInFile().BuildWordMap(std::vector<std::string>({ "ace", "tea", "and", "ad", "eat", "kk", "eat", "dan", "ate", "tea", "abc", "eat", "xyz" }));
		MinDistBtw2WordsInFile().QueryFromWordMap(wordMap, std::string("tea"), std::string("eat"));
		MinDistBtw2WordsInFile().OneScan2(std::vector<std::string>({ "ace", "tea", "and", "ad", "eat", "kk", "eat", "dan", "ate", "tea", "abc", "eat", "xyz" }), std::string("eat"), std::string("eat"));

		MinDistToTgtChar().TwoScan(std::string("bloomberg"), 'b');
        MinDistToTgtChar().TwoScan(std::string("bloomberg"), 'a');
	}
    {
        SentenceSimilarity().Test(std::vector<std::string>({"great", "acting", "skills"}), std::vector<std::string>({"fine", "drama", "talent"}), std::vector<std::pair<std::string,std::string>>({{"great", "good"}, {"fine", "good"}, {"acting","drama"}, {"skills","talent"}}));
    }
    {
        LongestWordInDictThruDeleting().Solve(std::string("abpcplea"), std::vector<std::string>({"ale","apple","monkey","plea"}));
    }
    {
        LongestLadderWordInDict().UseTrie(std::vector<std::string>({"a", "banana", "app", "appl", "ap", "apply", "apple"}));
        LongestLadderWordInDict().SortHashSet(std::vector<std::string>({"a", "banana", "app", "appl", "ap", "apply", "apple"}));
    }
    {
        CompareStringsWBackspace().Test("a##C", "#a#C");
    }
    {
        CountUniqueEmailAddr().UseHashSet(std::vector<std::string>({"test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"}));
    }
    {
        ConvertSentenceToGoatLatin().Solve(std::string("The quick brown fox jumped over the lazy dog"));
    }
    {
        CompareStretchyWords().Count(std::string("heeellooo"), std::vector<std::string>({"hello","hi","helo"}));
        CompareStretchyWords().IsLongPressedName("leelee", "lleeelee");
    }
    {
        CountSubdomainVisits().UseHashMap(std::vector<std::string>({"900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"}));
    }
    {
        VowelSpellChecker().UseHashMaps(std::vector<std::string>({"KiTe","kite","hare","Hare"}), std::vector<std::string>({"kite","Kite","KiTe","Hare","HARE","Hear","hear","keti","keet","keto"}));
    }
    {
        FindTgtWordGivenMatchCountComp::Master m;
        FindTgtWordGivenMatchCountComp().Solve(std::vector<std::string>({"acckzz","ccbazz","eiowzz","abcczz"}), m);
    }
    {
        FindDuplicateFilesInSystem().UseHashMap(std::vector<std::string>({"root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"}));
    }

#endif
#ifdef _TextLines_
	/*Text Lines*/
	RdCout ? redirect_cout::to_file("Out_TextLines.txt") : redirect_cout::to_cout();
	PrintH("Text Lines");
	{
        TextJustification().Greedy_Break(std::vector<std::string>({ "This", "is", "an", "example", "of", "text", "justification." }), 4);
        TextJustification().Greedy_Break(std::vector<std::string>({ "Text", "justification", "is", "an", "example", "of", "this." }), 4);

        TextJustification().Greedy_Break(std::vector<std::string>({ "aaa", "bb", "cc", "ddddd", "eee", "f", "gg", "h", "i", "jjj" }), 2);
        TextJustification().Greedy_Break(std::vector<std::string>({ "Geeks", "for", "Geeks", "presents", "word", "wrap", "problem" }), 3);
        TextJustification().Greedy_Break(std::vector<std::string>({ "The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dogs." }), 4);
        TextJustification().Greedy_Break(std::vector<std::string>(
                { "I", "have", "inserted", "a", "large", "number", "of", "new", "examples", "from", "the", "papers", "for", "the", "Mathematical"
                        , "Tripos", "during", "the", "last", "twenty", "years,", "which", "should", "be", "useful", "to", "Cambridge", "students."
                }), 6);


		TextJustification().Greedy(std::vector<std::string>({ "This", "is", "an", "example", "of", "text", "justification." }), 16);
		TextJustification().Greedy(std::vector<std::string>({ "This", "is", "an", "example", "of", "text", "justification." }), 14);
		TextJustification().Greedy(std::vector<std::string>({ "Text", "justification", "is", "an", "example", "of", "this." }), 16);
		TextJustification().Greedy(std::vector<std::string>({ "Text", "justification", "is", "an", "example", "of", "this." }), 14);

		TextJustification().Greedy(std::vector<std::string>({ "aaa", "bb", "cc", "ddddd", "eee", "f", "gg", "h", "i", "jjj" }), 6);
		TextJustification().Greedy(std::vector<std::string>({ "Geeks", "for", "Geeks", "presents", "word", "wrap", "problem" }), 15);
		TextJustification().Greedy(std::vector<std::string>({ "The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dogs." }), 11);
		TextJustification().Greedy(std::vector<std::string>(
		{ "I", "have", "inserted", "a", "large", "number", "of", "new", "examples", "from", "the", "papers", "for", "the", "Mathematical"
		, "Tripos", "during", "the", "last", "twenty", "years,", "which", "should", "be", "useful", "to", "Cambridge", "students."
		}), 36);

		TextJustification().Greedy(std::vector<std::string>(
		{ "Permission", "is", "hereby", "granted,", "free", "of", "charge,", "to", "any", "person", "obtaining", "a", "copy", "of", "this"
		, "software", "and", "associated", "documentation", "files", "(the", "\"Software\"),", "to", "deal", "in", "the", "Software", "without"
		, "restriction,", "including", "without", "limitation", "the", "rights", "to", "use,", "copy,", "modify,", "merge,", "publish", "distribute,"
		, "sublicense,", "and/or", "sell", "copies", "of", "the", "Software,", "and", "to", "permit", "persons", "to", "whom", "the", "Software"
		, "is", "furnished", "to", "do", "so,", "subject", "to", "the", "following", "conditions:"
		}), 65);
	}
	{
		NeatPrintWordWrap().MinCostOnlyDP1D(std::vector<std::string>({ "This", "is", "an", "example", "of", "text", "justification." }), 16);
		NeatPrintWordWrap().MinCostOnlyDP1D(std::vector<std::string>({ "This", "is", "an", "example", "of", "text", "justification." }), 14);
		NeatPrintWordWrap().MinCostOnlyDP1D(std::vector<std::string>({ "Text", "justification", "is", "an", "example", "of", "this." }), 16);
		NeatPrintWordWrap().MinCostOnlyDP1D(std::vector<std::string>({ "Text", "justification", "is", "an", "example", "of", "this." }), 14);
		NeatPrintWordWrap().MinCostOnlyDP1D(std::vector<std::string>({ "aaa", "bb", "cc", "ddddd", "eee", "f", "gg", "h", "i", "jjj" }), 6);
		NeatPrintWordWrap().MinCostOnlyDP1D(std::vector<std::string>({ "Geeks", "for", "Geeks", "presents", "word", "wrap", "problem" }), 15);
		NeatPrintWordWrap().MinCostOnlyDP1D(std::vector<std::string>({ "The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dogs." }), 11);

		NeatPrintWordWrap().MinCost_DP1D(std::vector<std::string>({ "This", "is", "an", "example", "of", "text", "justification." }), 16);
		NeatPrintWordWrap().MinCost_DP1D(std::vector<std::string>({ "This", "is", "an", "example", "of", "text", "justification." }), 14);
		NeatPrintWordWrap().MinCost_DP1D(std::vector<std::string>({ "Text", "justification", "is", "an", "example", "of", "this." }), 16);
		NeatPrintWordWrap().MinCost_DP1D(std::vector<std::string>({ "Text", "justification", "is", "an", "example", "of", "this." }), 14);

		NeatPrintWordWrap().MinCost_DP1D(std::vector<std::string>({ "aaa", "bb", "cc", "ddddd", "eee", "f", "gg", "h", "i", "jjj" }), 6);
		NeatPrintWordWrap().MinCost_DP1D(std::vector<std::string>({ "Geeks", "for", "Geeks", "presents", "word", "wrap", "problem" }), 15);
		NeatPrintWordWrap().MinCost_DP1D(std::vector<std::string>({ "The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dogs." }), 11);
		NeatPrintWordWrap().MinCost_DP1D(std::vector<std::string>(
		{ "I", "have", "inserted", "a", "large", "number", "of", "new", "examples", "from", "the", "papers", "for", "the", "Mathematical"
		, "Tripos", "during", "the", "last", "twenty", "years,", "which", "should", "be", "useful", "to", "Cambridge", "students."
		}), 36);
		NeatPrintWordWrap().MinCost_DP1D(std::vector<std::string>(
		{ "I", "have", "inserted", "a", "large", "number", "of", "new", "examples", "from", "the", "papers", "for", "the", "Mathematical"
		, "Tripos", "during", "the", "last", "twenty", "years,", "which", "should", "be", "useful", "to", "Cambridge", "students."
		}), 14);
		NeatPrintWordWrap().MinCost_DP1D(std::vector<std::string>(
		{ "I", "have", "inserted", "a", "large", "number", "of", "new", "examples", "from", "the", "papers", "for", "the", "Mathematical"
		, "Tripos", "during", "the", "last", "twenty", "years,", "which", "should", "be", "useful", "to", "Cambridge", "students."
		}), 16);
		NeatPrintWordWrap().MinCost_DP1D(std::vector<std::string>(
		{ "I", "have", "inserted", "a", "large", "number", "of", "new", "examples", "from", "the", "papers", "for", "the", "Mathematical"
		, "Tripos", "during", "the", "last", "twenty", "years,", "which", "should", "be", "useful", "to", "Cambridge", "students."
		}), 19);
		NeatPrintWordWrap().MinCost_DP1D(std::vector<std::string>(
		{ "I", "have", "inserted", "a", "large", "number", "of", "new", "examples", "from", "the", "papers", "for", "the", "Mathematical"
		, "Tripos", "during", "the", "last", "twenty", "years,", "which", "should", "be", "useful", "to", "Cambridge", "students."
		}), 25);

		NeatPrintWordWrap().MinCost_DP1D(std::vector<std::string>(
		{ "Permission", "is", "hereby", "granted,", "free", "of", "charge,", "to", "any", "person", "obtaining", "a", "copy", "of", "this"
		, "software", "and", "associated", "documentation", "files", "(the", "\"Software\"),", "to", "deal", "in", "the", "Software", "without"
		, "restriction,", "including", "without", "limitation", "the", "rights", "to", "use,", "copy,", "modify,", "merge,", "publish", "distribute,"
		, "sublicense,", "and/or", "sell", "copies", "of", "the", "Software,", "and", "to", "permit", "persons", "to", "whom", "the", "Software"
		, "is", "furnished", "to", "do", "so,", "subject", "to", "the", "following", "conditions:"
		}), 65);


		//NeatPrintWordWrap2().MinCost_DP2D(std::vector<std::string>({ "This", "is", "an", "example", "of", "text", "justification." }), 16);
		//NeatPrintWordWrap2().MinCost_DP2D(std::vector<std::string>({ "This", "is", "an", "example", "of", "text", "justification." }), 14);
		//NeatPrintWordWrap2().MinCost_DP2D(std::vector<std::string>({ "Text", "justification", "is", "an", "example", "of", "this." }), 16);
		//NeatPrintWordWrap2().MinCost_DP2D(std::vector<std::string>({ "Text", "justification", "is", "an", "example", "of", "this." }), 14);

		//NeatPrintWordWrap2().MinCost_DP2D(std::vector<std::string>({ "aaa", "bb", "cc", "ddddd", "eee", "f", "gg", "h", "i", "jjj" }), 6);
		//NeatPrintWordWrap2().MinCost_DP2D(std::vector<std::string>({ "Geeks", "for", "Geeks", "presents", "word", "wrap", "problem" }), 15);
		//NeatPrintWordWrap2().MinCost_DP2D(std::vector<std::string>(
		//{ "I", "have", "inserted", "a", "large", "number", "of", "new", "examples", "from", "the", "papers", "for", "the", "Mathematical"
		//, "Tripos", "during", "the", "last", "twenty", "years,", "which", "should", "be", "useful", "to", "Cambridge", "students."
		//}), 36);
	}
	{
		UnixTailCommand().tail(std::string("UnixTailCommand_Test.xml"), 3);
	}
	{
		for (int i = 0; i < 5; ++i)
			ReadNCharsGivenRead4I(TestCase::RandStr(30)).Test(TestCase::RandNum(1, 35));
		for (int i = 0; i < 5; ++i)
			ReadNCharsGivenRead4II(TestCase::RandStr(30)).Test(TestCase::RandNum(1, 35));
	}
	{
		SentenceScreenFitting().DP(std::vector<std::string>({ "a","bcd","e" }), 3, 6);
		SentenceScreenFitting().FillFromBack(std::vector<std::string>({ "a","bcd","e" }), 3, 6);
		SentenceScreenFitting().DP(std::vector<std::string>({ "I","had","apple","pie" }), 4, 5);
		SentenceScreenFitting().FillFromBack(std::vector<std::string>({ "I","had","apple","pie" }), 4, 5);
	}
	{
		CountTheRepetitions().DP(std::string("acb"), 4, std::string("ab"), 2);
	}
    {
        RemoveComments().Solve(std::vector<std::string>({"/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"}));
        RemoveComments().Solve(std::vector<std::string>({"a/*comment", "line", "more_comment*/b"}));
    }

#endif
#ifdef _LinkedList_
	/*Linked List*/
	RdCout ? redirect_cout::to_file("Out_LinkedList.txt") : redirect_cout::to_cout();
	PrintH("Linked List");
	std::ostringstream llOss;
	{
		LinkedListCycle::ListNode * llcHead = new LinkedListCycle::ListNode(17);
		llcHead->next = new LinkedListCycle::ListNode(8);
		llcHead->next->next = new LinkedListCycle::ListNode(16);
		llcHead->next->next->next = new LinkedListCycle::ListNode(5);
		llcHead->next->next->next->next = new LinkedListCycle::ListNode(11);
		llcHead->next->next->next->next->next = new LinkedListCycle::ListNode(3);
		llcHead->next->next->next->next->next->next = new LinkedListCycle::ListNode(24);
		llcHead->next->next->next->next->next->next->next = new LinkedListCycle::ListNode(9);
		llcHead->next->next->next->next->next->next->next->next = llcHead->next->next->next;
		PrintLinkedList<LinkedListCycle::ListNode, std::ostringstream>(llcHead, llOss);
		llOss << "LinkedListCycle HasCycle: " << LinkedListCycle().HasCycle(llcHead) << ", CycleBegin: " << LinkedListCycle().GetCycleBegin(llcHead)->val << ", " << LinkedListCycle().GetCycleBegin_Correct(llcHead)->val << ", " << LinkedListCycle().GetCycleBegin_Brent(llcHead)->val << std::endl;
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		LinkedListCycle::DeleteLinkedList(llcHead);

		llcHead = new LinkedListCycle::ListNode(0);
		llcHead->next = new LinkedListCycle::ListNode(1);
		llcHead->next->next = new LinkedListCycle::ListNode(2);
		llcHead->next->next->next = new LinkedListCycle::ListNode(3);
		llcHead->next->next->next->next = new LinkedListCycle::ListNode(4);
		llcHead->next->next->next->next->next = new LinkedListCycle::ListNode(5);
		llcHead->next->next->next->next->next->next = new LinkedListCycle::ListNode(6);
		llcHead->next->next->next->next->next->next->next = new LinkedListCycle::ListNode(7);
		llcHead->next->next->next->next->next->next->next->next = new LinkedListCycle::ListNode(8);
		llcHead->next->next->next->next->next->next->next->next->next = new LinkedListCycle::ListNode(9);
		llcHead->next->next->next->next->next->next->next->next->next->next = new LinkedListCycle::ListNode(10);
		llcHead->next->next->next->next->next->next->next->next->next->next->next = new LinkedListCycle::ListNode(11);
		llcHead->next->next->next->next->next->next->next->next->next->next->next->next = new LinkedListCycle::ListNode(12);
		llcHead->next->next->next->next->next->next->next->next->next->next->next->next->next = new LinkedListCycle::ListNode(13);
		llcHead->next->next->next->next->next->next->next->next->next->next->next->next->next->next = new LinkedListCycle::ListNode(14);
		llcHead->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next = new LinkedListCycle::ListNode(15);
		llcHead->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next->next = llcHead->next->next->next->next->next->next;
		PrintLinkedList<LinkedListCycle::ListNode, std::ostringstream>(llcHead, llOss);
		llOss << "LinkedListCycle HasCycle: " << LinkedListCycle().HasCycle(llcHead) << ", CycleBegin: " << LinkedListCycle().GetCycleBegin(llcHead)->val << ", " << LinkedListCycle().GetCycleBegin_Correct(llcHead)->val << ", " << LinkedListCycle().GetCycleBegin_Brent(llcHead)->val << std::endl;
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		LinkedListCycle::DeleteLinkedList(llcHead);
	}
	{
		Merge2SortedLinkedLists::ListNode * m2sllHead = new Merge2SortedLinkedLists::ListNode(7);
		m2sllHead->next = new Merge2SortedLinkedLists::ListNode(13);
		m2sllHead->next->prev = m2sllHead;
		m2sllHead->next->next = new Merge2SortedLinkedLists::ListNode(16);
		m2sllHead->next->next->prev = m2sllHead->next;
		m2sllHead->next->next->next = new Merge2SortedLinkedLists::ListNode(18);
		m2sllHead->next->next->next->prev = m2sllHead->next->next;
		m2sllHead->next->next->next->next = new Merge2SortedLinkedLists::ListNode(24);
		m2sllHead->next->next->next->next->prev = m2sllHead->next->next->next;
		Merge2SortedLinkedLists::ListNode * m2sllHead2 = new Merge2SortedLinkedLists::ListNode(8);
		m2sllHead2->next = new Merge2SortedLinkedLists::ListNode(11);
		m2sllHead2->next->prev = m2sllHead2;
		m2sllHead2->next->next = new Merge2SortedLinkedLists::ListNode(15);
		m2sllHead2->next->next->prev = m2sllHead2->next;
		m2sllHead2->next->next->next = new Merge2SortedLinkedLists::ListNode(17);
		m2sllHead2->next->next->next->prev = m2sllHead2->next->next;
		m2sllHead2->next->next->next->next = new Merge2SortedLinkedLists::ListNode(37);
		m2sllHead2->next->next->next->next->prev = m2sllHead2->next->next->next;
		llOss << "Merge2SortedLinkedList:" << std::endl;
		PrintLinkedList<Merge2SortedLinkedLists::ListNode, std::ostringstream>(m2sllHead, llOss);
		PrintLinkedList<Merge2SortedLinkedLists::ListNode, std::ostringstream>(m2sllHead2, llOss);
		Merge2SortedLinkedLists::ListNode * m2sllHeadMerge = Merge2SortedLinkedLists().GO2(m2sllHead, m2sllHead2);
		PrintLinkedList<Merge2SortedLinkedLists::ListNode, std::ostringstream>(m2sllHeadMerge, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		Merge2SortedLinkedLists::DeleteLinkedList(m2sllHeadMerge);
	}
	{
		MergeKSortedLinkedLists::ListNode * mkslHead = new MergeKSortedLinkedLists::ListNode(7);
		mkslHead->next = new MergeKSortedLinkedLists::ListNode(13);
		mkslHead->next->next = new MergeKSortedLinkedLists::ListNode(16);
		mkslHead->next->next->next = new MergeKSortedLinkedLists::ListNode(18);
		mkslHead->next->next->next->next = new MergeKSortedLinkedLists::ListNode(24);
		MergeKSortedLinkedLists::ListNode * mkslHead2 = new MergeKSortedLinkedLists::ListNode(8);
		mkslHead2->next = new MergeKSortedLinkedLists::ListNode(11);
		mkslHead2->next->next = new MergeKSortedLinkedLists::ListNode(15);
		mkslHead2->next->next->next = new MergeKSortedLinkedLists::ListNode(17);
		mkslHead2->next->next->next->next = new MergeKSortedLinkedLists::ListNode(37);
		MergeKSortedLinkedLists::ListNode * mkslHead3 = new MergeKSortedLinkedLists::ListNode(5);
		mkslHead3->next = new MergeKSortedLinkedLists::ListNode(12);
		mkslHead3->next->next = new MergeKSortedLinkedLists::ListNode(14);
		mkslHead3->next->next->next = new MergeKSortedLinkedLists::ListNode(23);
		mkslHead3->next->next->next->next = new MergeKSortedLinkedLists::ListNode(25);
		llOss << "MergeKSortedLinkedList:" << std::endl;
		PrintLinkedList<MergeKSortedLinkedLists::ListNode, std::ostringstream>(mkslHead, llOss);
		PrintLinkedList<MergeKSortedLinkedLists::ListNode, std::ostringstream>(mkslHead2, llOss);
		PrintLinkedList<MergeKSortedLinkedLists::ListNode, std::ostringstream>(mkslHead3, llOss);
		MergeKSortedLinkedLists::ListNode * mkslHeadMerge = MergeKSortedLinkedLists().MinHeap(std::vector<MergeKSortedLinkedLists::ListNode*>({ mkslHead, mkslHead2, mkslHead3 }));
		PrintLinkedList<MergeKSortedLinkedLists::ListNode, std::ostringstream>(mkslHeadMerge, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		MergeKSortedLinkedLists::DeleteLinkedList(mkslHeadMerge);
	}
	{
		PartitionLinkedList::ListNode * pllHead = new PartitionLinkedList::ListNode(7);
		pllHead->next = new PartitionLinkedList::ListNode(3);
		pllHead->next->next = new PartitionLinkedList::ListNode(8);
		pllHead->next->next->next = new PartitionLinkedList::ListNode(6);
		pllHead->next->next->next->next = new PartitionLinkedList::ListNode(10);
		pllHead->next->next->next->next->next = new PartitionLinkedList::ListNode(5);
		pllHead->next->next->next->next->next->next = new PartitionLinkedList::ListNode(4);
		pllHead->next->next->next->next->next->next->next = new PartitionLinkedList::ListNode(6);
		pllHead->next->next->next->next->next->next->next->next = new PartitionLinkedList::ListNode(5);
		pllHead->next->next->next->next->next->next->next->next->next = new PartitionLinkedList::ListNode(6);
		llOss << "PartitionLinkedList for 6:" << std::endl;
		PrintLinkedList<PartitionLinkedList::ListNode, std::ostringstream>(pllHead, llOss);
		PartitionLinkedList::ListNode * pllHeadPartition = PartitionLinkedList().Partition(pllHead, 6);
		PrintLinkedList<PartitionLinkedList::ListNode, std::ostringstream>(pllHeadPartition, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		PartitionLinkedList::DeleteLinkedList(pllHeadPartition);

		pllHead = new PartitionLinkedList::ListNode(7);
		pllHead->next = new PartitionLinkedList::ListNode(3);
		pllHead->next->next = new PartitionLinkedList::ListNode(8);
		pllHead->next->next->next = new PartitionLinkedList::ListNode(6);
		pllHead->next->next->next->next = new PartitionLinkedList::ListNode(10);
		pllHead->next->next->next->next->next = new PartitionLinkedList::ListNode(5);
		pllHead->next->next->next->next->next->next = new PartitionLinkedList::ListNode(4);
		pllHead->next->next->next->next->next->next->next = new PartitionLinkedList::ListNode(6);
		pllHead->next->next->next->next->next->next->next->next = new PartitionLinkedList::ListNode(5);
		pllHead->next->next->next->next->next->next->next->next->next = new PartitionLinkedList::ListNode(6);
		llOss << "PartitionLinkedList 3way for 6:" << std::endl;
		PrintLinkedList<PartitionLinkedList::ListNode, std::ostringstream>(pllHead, llOss);
		pllHeadPartition = PartitionLinkedList().Partition_3way(pllHead, 6);
		PrintLinkedList<PartitionLinkedList::ListNode, std::ostringstream>(pllHeadPartition, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		PartitionLinkedList::DeleteLinkedList(pllHeadPartition);
	}
	{
		RemoveDuplicatesSortedLinkedList::ListNode * rdsllHead = new RemoveDuplicatesSortedLinkedList::ListNode(1);
		rdsllHead->next = new RemoveDuplicatesSortedLinkedList::ListNode(2);
		rdsllHead->next->next = new RemoveDuplicatesSortedLinkedList::ListNode(3);
		rdsllHead->next->next->next = new RemoveDuplicatesSortedLinkedList::ListNode(3);
		rdsllHead->next->next->next->next = new RemoveDuplicatesSortedLinkedList::ListNode(4);
		rdsllHead->next->next->next->next->next = new RemoveDuplicatesSortedLinkedList::ListNode(4);
		rdsllHead->next->next->next->next->next->next = new RemoveDuplicatesSortedLinkedList::ListNode(5);
		RemoveDuplicatesSortedLinkedList::ListNode * rdsllHead2 = new RemoveDuplicatesSortedLinkedList::ListNode(1);
		rdsllHead2->next = new RemoveDuplicatesSortedLinkedList::ListNode(1);
		rdsllHead2->next->next = new RemoveDuplicatesSortedLinkedList::ListNode(1);
		rdsllHead2->next->next->next = new RemoveDuplicatesSortedLinkedList::ListNode(1);
		rdsllHead2->next->next->next->next = new RemoveDuplicatesSortedLinkedList::ListNode(1);
		rdsllHead2->next->next->next->next->next = new RemoveDuplicatesSortedLinkedList::ListNode(2);
		rdsllHead2->next->next->next->next->next->next = new RemoveDuplicatesSortedLinkedList::ListNode(2);
		llOss << "RemoveDuplicateSortedLinkedList KeepOneDup and DontKeepDup:" << std::endl;
		PrintLinkedList<RemoveDuplicatesSortedLinkedList::ListNode, std::ostringstream>(rdsllHead, llOss);
		RemoveDuplicatesSortedLinkedList::ListNode * rdsllHeadKeepOne = RemoveDuplicatesSortedLinkedList().KeepOneDup(rdsllHead);
		PrintLinkedList<RemoveDuplicatesSortedLinkedList::ListNode, std::ostringstream>(rdsllHeadKeepOne, llOss);
		PrintLinkedList<RemoveDuplicatesSortedLinkedList::ListNode, std::ostringstream>(rdsllHead2, llOss);
		RemoveDuplicatesSortedLinkedList::ListNode * rdsllHeadDontKeep = RemoveDuplicatesSortedLinkedList().DontKeepAnyDup(rdsllHead2);
		PrintLinkedList<RemoveDuplicatesSortedLinkedList::ListNode, std::ostringstream>(rdsllHeadDontKeep, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		RemoveDuplicatesSortedLinkedList::DeleteLinkedList(rdsllHeadKeepOne);
		RemoveDuplicatesSortedLinkedList::DeleteLinkedList(rdsllHeadDontKeep);
	}
	{
		RemoveDupUnsortedLinkedList::ListNode * rdullHead = new RemoveDupUnsortedLinkedList::ListNode(7);
		rdullHead->next = new RemoveDupUnsortedLinkedList::ListNode(8);
		rdullHead->next->next = new RemoveDupUnsortedLinkedList::ListNode(5);
		rdullHead->next->next->next = new RemoveDupUnsortedLinkedList::ListNode(16);
		rdullHead->next->next->next->next = new RemoveDupUnsortedLinkedList::ListNode(13);
		rdullHead->next->next->next->next->next = new RemoveDupUnsortedLinkedList::ListNode(8);
		rdullHead->next->next->next->next->next->next = new RemoveDupUnsortedLinkedList::ListNode(7);
		rdullHead->next->next->next->next->next->next->next = new RemoveDupUnsortedLinkedList::ListNode(16);
		rdullHead->next->next->next->next->next->next->next->next = new RemoveDupUnsortedLinkedList::ListNode(3);
		RemoveDupUnsortedLinkedList::ListNode * rdullHead2 = new RemoveDupUnsortedLinkedList::ListNode(7);
		rdullHead2->next = new RemoveDupUnsortedLinkedList::ListNode(8);
		rdullHead2->next->next = new RemoveDupUnsortedLinkedList::ListNode(5);
		rdullHead2->next->next->next = new RemoveDupUnsortedLinkedList::ListNode(16);
		rdullHead2->next->next->next->next = new RemoveDupUnsortedLinkedList::ListNode(13);
		rdullHead2->next->next->next->next->next = new RemoveDupUnsortedLinkedList::ListNode(8);
		rdullHead2->next->next->next->next->next->next = new RemoveDupUnsortedLinkedList::ListNode(7);
		rdullHead2->next->next->next->next->next->next->next = new RemoveDupUnsortedLinkedList::ListNode(16);
		rdullHead2->next->next->next->next->next->next->next->next = new RemoveDupUnsortedLinkedList::ListNode(3);
		std::cout << "RemoveDupUnsortedLinkedList HashTable and ConstSpace:" << std::endl;
		PrintLinkedList<RemoveDupUnsortedLinkedList::ListNode, std::ostringstream>(rdullHead, llOss);
		RemoveDupUnsortedLinkedList::ListNode * rdullHeadHashTable = RemoveDupUnsortedLinkedList().HashTable(rdullHead);
		PrintLinkedList<RemoveDupUnsortedLinkedList::ListNode, std::ostringstream>(rdullHeadHashTable, llOss);
		PrintLinkedList<RemoveDupUnsortedLinkedList::ListNode, std::ostringstream>(rdullHead2, llOss);
		RemoveDupUnsortedLinkedList::ListNode * rdullHeadConstSpace = RemoveDupUnsortedLinkedList().ConstSpace(rdullHead2);
		PrintLinkedList<RemoveDupUnsortedLinkedList::ListNode, std::ostringstream>(rdullHeadConstSpace, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		RemoveDupUnsortedLinkedList::DeleteLinkedList(rdullHeadHashTable);
		RemoveDupUnsortedLinkedList::DeleteLinkedList(rdullHeadConstSpace);
	}
	{
		RemoveKthNodeFromEndLinkedList::ListNode * rnnfeHead = new RemoveKthNodeFromEndLinkedList::ListNode(1);
		rnnfeHead->next = new RemoveKthNodeFromEndLinkedList::ListNode(2);
		rnnfeHead->next->next = new RemoveKthNodeFromEndLinkedList::ListNode(3);
		rnnfeHead->next->next->next = new RemoveKthNodeFromEndLinkedList::ListNode(4);
		rnnfeHead->next->next->next->next = new RemoveKthNodeFromEndLinkedList::ListNode(5);
		llOss << "RemoveKthNodeFromEndLinkedList for 3:" << std::endl;
		PrintLinkedList<RemoveKthNodeFromEndLinkedList::ListNode, std::ostringstream>(rnnfeHead, llOss);
		RemoveKthNodeFromEndLinkedList::ListNode * rnnfeHeadRemove = RemoveKthNodeFromEndLinkedList().GO(rnnfeHead, 3);
		PrintLinkedList<RemoveKthNodeFromEndLinkedList::ListNode, std::ostringstream>(rnnfeHeadRemove, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		RemoveKthNodeFromEndLinkedList::DeleteLinkedList(rnnfeHeadRemove);
	}
	{
		ReverseLinkedList::ListNode * rvllHead = new ReverseLinkedList::ListNode(1);
		rvllHead->next = new ReverseLinkedList::ListNode(2);
		rvllHead->next->next = new ReverseLinkedList::ListNode(3);
		rvllHead->next->next->next = new ReverseLinkedList::ListNode(4);
		rvllHead->next->next->next->next = new ReverseLinkedList::ListNode(5);
		rvllHead->next->next->next->next->next = new ReverseLinkedList::ListNode(6);
		ReverseLinkedList::ListNode * rvllHead1 = new ReverseLinkedList::ListNode(1);
		rvllHead1->next = new ReverseLinkedList::ListNode(2);
		rvllHead1->next->next = new ReverseLinkedList::ListNode(3);
		rvllHead1->next->next->next = new ReverseLinkedList::ListNode(4);
		rvllHead1->next->next->next->next = new ReverseLinkedList::ListNode(5);
		rvllHead1->next->next->next->next->next = new ReverseLinkedList::ListNode(6);
		ReverseLinkedList::ListNode * rvllHead2 = new ReverseLinkedList::ListNode(1);
		rvllHead2->next = new ReverseLinkedList::ListNode(2);
		rvllHead2->next->next = new ReverseLinkedList::ListNode(3);
		rvllHead2->next->next->next = new ReverseLinkedList::ListNode(4);
		rvllHead2->next->next->next->next = new ReverseLinkedList::ListNode(5);
		rvllHead2->next->next->next->next->next = new ReverseLinkedList::ListNode(6);
		ReverseLinkedList::ListNode * rvllHead3 = new ReverseLinkedList::ListNode(1);
		rvllHead3->next = new ReverseLinkedList::ListNode(2);
		rvllHead3->next->next = new ReverseLinkedList::ListNode(3);
		rvllHead3->next->next->next = new ReverseLinkedList::ListNode(4);
		rvllHead3->next->next->next->next = new ReverseLinkedList::ListNode(5);
		rvllHead3->next->next->next->next->next = new ReverseLinkedList::ListNode(6);
		llOss << "ReverseLinkedList Iterate, Iterate2, Recur, Between:" << std::endl;

		PrintLinkedList<ReverseLinkedList::ListNode, std::ostringstream>(rvllHead, llOss);
		ReverseLinkedList::ListNode * rvllHeadReverse = ReverseLinkedList().Reverse_Iterate(rvllHead);
		PrintLinkedList<ReverseLinkedList::ListNode, std::ostringstream>(rvllHeadReverse, llOss);

		PrintLinkedList<ReverseLinkedList::ListNode, std::ostringstream>(rvllHead1, llOss);
		ReverseLinkedList::ListNode * rvllHeadReverse1 = ReverseLinkedList().Reverse_Iterate2(rvllHead1);
		PrintLinkedList<ReverseLinkedList::ListNode, std::ostringstream>(rvllHeadReverse1, llOss);

		PrintLinkedList<ReverseLinkedList::ListNode, std::ostringstream>(rvllHead2, llOss);
		ReverseLinkedList::ListNode * rvllHeadReverseRecur = ReverseLinkedList().Reverse_Recur(rvllHead2);
		PrintLinkedList<ReverseLinkedList::ListNode, std::ostringstream>(rvllHeadReverseRecur, llOss);

		PrintLinkedList<ReverseLinkedList::ListNode, std::ostringstream>(rvllHead3, llOss);
		ReverseLinkedList::ListNode * rvllHeadReverseBtw = ReverseLinkedList().ReverseBetween(rvllHead3, 2, 4);
		PrintLinkedList<ReverseLinkedList::ListNode, std::ostringstream>(rvllHeadReverseBtw, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		ReverseLinkedList::DeleteLinkedList(rvllHeadReverse);
		ReverseLinkedList::DeleteLinkedList(rvllHeadReverse1);
		ReverseLinkedList::DeleteLinkedList(rvllHeadReverseRecur);
		ReverseLinkedList::DeleteLinkedList(rvllHeadReverseBtw);
	}
	{
		ReverseNodesInKGroupLinkedList::ListNode * rnikgHead = new ReverseNodesInKGroupLinkedList::ListNode(1);
		rnikgHead->next = new ReverseNodesInKGroupLinkedList::ListNode(2);
		rnikgHead->next->next = new ReverseNodesInKGroupLinkedList::ListNode(3);
		rnikgHead->next->next->next = new ReverseNodesInKGroupLinkedList::ListNode(4);
		rnikgHead->next->next->next->next = new ReverseNodesInKGroupLinkedList::ListNode(5);
		rnikgHead->next->next->next->next->next = new ReverseNodesInKGroupLinkedList::ListNode(6);
		ReverseNodesInKGroupLinkedList::ListNode * rnikgHead2 = new ReverseNodesInKGroupLinkedList::ListNode(1);
		rnikgHead2->next = new ReverseNodesInKGroupLinkedList::ListNode(2);
		rnikgHead2->next->next = new ReverseNodesInKGroupLinkedList::ListNode(3);
		rnikgHead2->next->next->next = new ReverseNodesInKGroupLinkedList::ListNode(4);
		rnikgHead2->next->next->next->next = new ReverseNodesInKGroupLinkedList::ListNode(5);
		rnikgHead2->next->next->next->next->next = new ReverseNodesInKGroupLinkedList::ListNode(6);
		llOss << "ReverseNodesInKGroupLinkedList Iterate for 2 and 4:" << std::endl;
		PrintLinkedList<ReverseNodesInKGroupLinkedList::ListNode, std::ostringstream>(rnikgHead, llOss);
		ReverseNodesInKGroupLinkedList::ListNode * rnikgHeadIterate = ReverseNodesInKGroupLinkedList().Iterate(rnikgHead, 2);
		PrintLinkedList<ReverseNodesInKGroupLinkedList::ListNode, std::ostringstream>(rnikgHeadIterate, llOss);
		PrintLinkedList<ReverseNodesInKGroupLinkedList::ListNode, std::ostringstream>(rnikgHead2, llOss);
		ReverseNodesInKGroupLinkedList::ListNode * rnikgHeadIterate2 = ReverseNodesInKGroupLinkedList().Iterate(rnikgHead2, 4);
		PrintLinkedList<ReverseNodesInKGroupLinkedList::ListNode, std::ostringstream>(rnikgHeadIterate2, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		ReverseNodesInKGroupLinkedList::DeleteLinkedList(rnikgHeadIterate);
		ReverseNodesInKGroupLinkedList::DeleteLinkedList(rnikgHeadIterate2);
	}
	{
		RotateLinkedList::ListNode * rtllHead = new RotateLinkedList::ListNode(1);
		rtllHead->next = new RotateLinkedList::ListNode(2);
		rtllHead->next->next = new RotateLinkedList::ListNode(3);
		rtllHead->next->next->next = new RotateLinkedList::ListNode(4);
		rtllHead->next->next->next->next = new RotateLinkedList::ListNode(5);
		rtllHead->next->next->next->next->next = new RotateLinkedList::ListNode(6);
		llOss << "RotateLinkedList for 2:" << std::endl;
		PrintLinkedList<RotateLinkedList::ListNode, std::ostringstream>(rtllHead, llOss);
		RotateLinkedList::ListNode * rtllHeadRotate = RotateLinkedList().RotateRight(rtllHead, 2);
		PrintLinkedList<RotateLinkedList::ListNode, std::ostringstream>(rtllHeadRotate, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		RotateLinkedList::DeleteLinkedList(rtllHeadRotate);
	}
	{
		SortLinkedList::ListNode * sllHead = new SortLinkedList::ListNode(7);
		sllHead->next = new SortLinkedList::ListNode(6);
		sllHead->next->next = new SortLinkedList::ListNode(8);
		sllHead->next->next->next = new SortLinkedList::ListNode(4);
		sllHead->next->next->next->next = new SortLinkedList::ListNode(3);
		sllHead->next->next->next->next->next = new SortLinkedList::ListNode(2);
		SortLinkedList::ListNode * sllHead2 = new SortLinkedList::ListNode(7);
		sllHead2->next = new SortLinkedList::ListNode(6);
		sllHead2->next->next = new SortLinkedList::ListNode(8);
		sllHead2->next->next->next = new SortLinkedList::ListNode(4);
		sllHead2->next->next->next->next = new SortLinkedList::ListNode(3);
		sllHead2->next->next->next->next->next = new SortLinkedList::ListNode(2);
		llOss << "SortLinkedList Merge and Insertion Sort:" << std::endl;
		PrintLinkedList<SortLinkedList::ListNode, std::ostringstream>(sllHead, llOss);
		SortLinkedList::ListNode * sllHeadMerge = SortLinkedList().MergeSort(sllHead);
		PrintLinkedList<SortLinkedList::ListNode, std::ostringstream>(sllHeadMerge, llOss);
		PrintLinkedList<SortLinkedList::ListNode, std::ostringstream>(sllHead2, llOss);
		SortLinkedList::ListNode * sllHeadInsertion = SortLinkedList().InsertionSort(sllHead2);
		PrintLinkedList<SortLinkedList::ListNode, std::ostringstream>(sllHeadInsertion, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		SortLinkedList::DeleteLinkedList(sllHeadMerge);
		SortLinkedList::DeleteLinkedList(sllHeadInsertion);
	}
	{
		SwapNodesInPairsLinkedList::ListNode * snipHead = new SwapNodesInPairsLinkedList::ListNode(1);
		snipHead->next = new SwapNodesInPairsLinkedList::ListNode(2);
		snipHead->next->next = new SwapNodesInPairsLinkedList::ListNode(3);
		snipHead->next->next->next = new SwapNodesInPairsLinkedList::ListNode(4);
		snipHead->next->next->next->next = new SwapNodesInPairsLinkedList::ListNode(5);
		snipHead->next->next->next->next->next = new SwapNodesInPairsLinkedList::ListNode(6);
		SwapNodesInPairsLinkedList::ListNode * snipHead2 = new SwapNodesInPairsLinkedList::ListNode(1);
		snipHead2->next = new SwapNodesInPairsLinkedList::ListNode(2);
		snipHead2->next->next = new SwapNodesInPairsLinkedList::ListNode(3);
		snipHead2->next->next->next = new SwapNodesInPairsLinkedList::ListNode(4);
		snipHead2->next->next->next->next = new SwapNodesInPairsLinkedList::ListNode(5);
		snipHead2->next->next->next->next->next = new SwapNodesInPairsLinkedList::ListNode(6);
		llOss << "SwapNodesInPairsLinkedList Recur and Iterate:" << std::endl;
		PrintLinkedList<SwapNodesInPairsLinkedList::ListNode, std::ostringstream>(snipHead, llOss);
		SwapNodesInPairsLinkedList::ListNode * snipHeadRecur = SwapNodesInPairsLinkedList().SwapRecur(snipHead);
		PrintLinkedList<SwapNodesInPairsLinkedList::ListNode, std::ostringstream>(snipHeadRecur, llOss);
		PrintLinkedList<SwapNodesInPairsLinkedList::ListNode, std::ostringstream>(snipHead2, llOss);
		SwapNodesInPairsLinkedList::ListNode * snipHeadIterate = SwapNodesInPairsLinkedList().SwapIterate(snipHead2);
		PrintLinkedList<SwapNodesInPairsLinkedList::ListNode, std::ostringstream>(snipHeadIterate, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		SwapNodesInPairsLinkedList::DeleteLinkedList(snipHeadRecur);
		SwapNodesInPairsLinkedList::DeleteLinkedList(snipHeadIterate);
	}
	{
		CopyRandomLinkedList::RandomListNode * crllHead = new CopyRandomLinkedList::RandomListNode(1);
		crllHead->next = new CopyRandomLinkedList::RandomListNode(2);
		crllHead->next->next = new CopyRandomLinkedList::RandomListNode(3);
		crllHead->next->next->next = new CopyRandomLinkedList::RandomListNode(4);
		crllHead->next->next->next->next = new CopyRandomLinkedList::RandomListNode(5);
		crllHead->next->next->next->next->next = new CopyRandomLinkedList::RandomListNode(6);
		crllHead->random = crllHead->next->next->next->next;
		crllHead->next->random = crllHead->next;
		crllHead->next->next->random = crllHead->next->next->next;
		crllHead->next->next->next->random = crllHead->next->next;
		crllHead->next->next->next->next->random = crllHead->next->next->next->next->next;
		crllHead->next->next->next->next->next->random = crllHead;
		CopyRandomLinkedList::RandomListNode * crllHead2 = new CopyRandomLinkedList::RandomListNode(1);
		crllHead2->next = new CopyRandomLinkedList::RandomListNode(2);
		crllHead2->next->next = new CopyRandomLinkedList::RandomListNode(3);
		crllHead2->next->next->next = new CopyRandomLinkedList::RandomListNode(4);
		crllHead2->next->next->next->next = new CopyRandomLinkedList::RandomListNode(5);
		crllHead2->next->next->next->next->next = new CopyRandomLinkedList::RandomListNode(6);
		crllHead2->random = crllHead2->next->next->next->next;
		crllHead2->next->random = crllHead2->next;
		crllHead2->next->next->random = crllHead2->next->next->next;
		crllHead2->next->next->next->random = crllHead2->next->next;
		crllHead2->next->next->next->next->random = crllHead2->next->next->next->next->next;
		crllHead2->next->next->next->next->next->random = crllHead2;
		llOss << "CopyRandomLinkedList HashTable and ConstSpace:" << std::endl;
		CopyRandomLinkedList::Print(crllHead, llOss);
		CopyRandomLinkedList::RandomListNode * crllHeadHashTable = CopyRandomLinkedList().HashTable(crllHead);
		CopyRandomLinkedList::Print(crllHeadHashTable, llOss);
		CopyRandomLinkedList::Print(crllHead2, llOss);
		CopyRandomLinkedList::RandomListNode * crllHeadConstSpace = CopyRandomLinkedList().ConstSpace(crllHead2);
		CopyRandomLinkedList::Print(crllHeadConstSpace, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		CopyRandomLinkedList::DeleteLinkedList(crllHead);
		CopyRandomLinkedList::DeleteLinkedList(crllHead2);
		CopyRandomLinkedList::DeleteLinkedList(crllHeadHashTable);
		CopyRandomLinkedList::DeleteLinkedList(crllHeadConstSpace);
	}
	{
		FoldLinkedList::ListNode * fllHead = new FoldLinkedList::ListNode(1);
		fllHead->next = new FoldLinkedList::ListNode(2);
		fllHead->next->next = new FoldLinkedList::ListNode(3);
		fllHead->next->next->next = new FoldLinkedList::ListNode(4);
		fllHead->next->next->next->next = new FoldLinkedList::ListNode(5);
		fllHead->next->next->next->next->next = new FoldLinkedList::ListNode(6);
		fllHead->next->next->next->next->next->next = new FoldLinkedList::ListNode(7);
		fllHead->next->next->next->next->next->next->next = new FoldLinkedList::ListNode(8);
		fllHead->next->next->next->next->next->next->next->next = new FoldLinkedList::ListNode(9);
		fllHead->next->next->next->next->next->next->next->next->next = new FoldLinkedList::ListNode(10);
		fllHead->next->next->next->next->next->next->next->next->next->next = new FoldLinkedList::ListNode(11);
		llOss << "FoldLinkedList Recur:" << std::endl;
		PrintLinkedList<FoldLinkedList::ListNode, std::ostringstream>(fllHead, llOss);
		fllHead = FoldLinkedList().Solve_Recur(fllHead);
		PrintLinkedList<FoldLinkedList::ListNode, std::ostringstream>(fllHead, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		FoldLinkedList::DeleteLinkedList(fllHead);

		FoldLinkedList::ListNode * fllHead2 = new FoldLinkedList::ListNode(1);
		fllHead2->next = new FoldLinkedList::ListNode(2);
		fllHead2->next->next = new FoldLinkedList::ListNode(3);
		fllHead2->next->next->next = new FoldLinkedList::ListNode(4);
		fllHead2->next->next->next->next = new FoldLinkedList::ListNode(5);
		fllHead2->next->next->next->next->next = new FoldLinkedList::ListNode(6);
		fllHead2->next->next->next->next->next->next = new FoldLinkedList::ListNode(7);
		fllHead2->next->next->next->next->next->next->next = new FoldLinkedList::ListNode(8);
		fllHead2->next->next->next->next->next->next->next->next = new FoldLinkedList::ListNode(9);
		fllHead2->next->next->next->next->next->next->next->next->next = new FoldLinkedList::ListNode(10);
		llOss << "FoldLinkedList Recur:" << std::endl;
		PrintLinkedList<FoldLinkedList::ListNode, std::ostringstream>(fllHead2, llOss);
		fllHead2 = FoldLinkedList().Solve_Recur(fllHead2);
		PrintLinkedList<FoldLinkedList::ListNode, std::ostringstream>(fllHead2, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		FoldLinkedList::DeleteLinkedList(fllHead2);

		FoldLinkedList::ListNode * fllHead3 = new FoldLinkedList::ListNode(1);
		fllHead3->next = new FoldLinkedList::ListNode(2);
		fllHead3->next->next = new FoldLinkedList::ListNode(3);
		fllHead3->next->next->next = new FoldLinkedList::ListNode(4);
		fllHead3->next->next->next->next = new FoldLinkedList::ListNode(5);
		fllHead3->next->next->next->next->next = new FoldLinkedList::ListNode(6);
		fllHead3->next->next->next->next->next->next = new FoldLinkedList::ListNode(7);
		fllHead3->next->next->next->next->next->next->next = new FoldLinkedList::ListNode(8);
		fllHead3->next->next->next->next->next->next->next->next = new FoldLinkedList::ListNode(9);
		fllHead3->next->next->next->next->next->next->next->next->next = new FoldLinkedList::ListNode(10);
		fllHead3->next->next->next->next->next->next->next->next->next->next = new FoldLinkedList::ListNode(11);
		llOss << "FoldLinkedList Reverse 2nd Half and Merge:" << std::endl;
		PrintLinkedList<FoldLinkedList::ListNode, std::ostringstream>(fllHead3, llOss);
		fllHead3 = FoldLinkedList().Solve_Reverse2ndHalf_Merge(fllHead3);
		PrintLinkedList<FoldLinkedList::ListNode, std::ostringstream>(fllHead3, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		FoldLinkedList::DeleteLinkedList(fllHead3);

		FoldLinkedList::ListNode * fllHead4 = new FoldLinkedList::ListNode(1);
		fllHead4->next = new FoldLinkedList::ListNode(2);
		fllHead4->next->next = new FoldLinkedList::ListNode(3);
		fllHead4->next->next->next = new FoldLinkedList::ListNode(4);
		fllHead4->next->next->next->next = new FoldLinkedList::ListNode(5);
		fllHead4->next->next->next->next->next = new FoldLinkedList::ListNode(6);
		fllHead4->next->next->next->next->next->next = new FoldLinkedList::ListNode(7);
		fllHead4->next->next->next->next->next->next->next = new FoldLinkedList::ListNode(8);
		fllHead4->next->next->next->next->next->next->next->next = new FoldLinkedList::ListNode(9);
		fllHead4->next->next->next->next->next->next->next->next->next = new FoldLinkedList::ListNode(10);
		llOss << "FoldLinkedList Reverse 2nd Half and Merge:" << std::endl;
		PrintLinkedList<FoldLinkedList::ListNode, std::ostringstream>(fllHead4, llOss);
		fllHead4 = FoldLinkedList().Solve_Reverse2ndHalf_Merge(fllHead4);
		PrintLinkedList<FoldLinkedList::ListNode, std::ostringstream>(fllHead4, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		FoldLinkedList::DeleteLinkedList(fllHead4);

		FoldLinkedList::ListNode * fllHead5 = new FoldLinkedList::ListNode(1);
		fllHead5->next = new FoldLinkedList::ListNode(2);
		fllHead5->next->next = new FoldLinkedList::ListNode(3);
		fllHead5->next->next->next = new FoldLinkedList::ListNode(4);
		fllHead5->next->next->next->next = new FoldLinkedList::ListNode(5);
		llOss << "FoldLinkedList Reverse 2nd Half and Merge:" << std::endl;
		PrintLinkedList<FoldLinkedList::ListNode, std::ostringstream>(fllHead5, llOss);
		fllHead3 = FoldLinkedList().Solve_Reverse2ndHalf_Merge(fllHead5);
		PrintLinkedList<FoldLinkedList::ListNode, std::ostringstream>(fllHead5, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		FoldLinkedList::DeleteLinkedList(fllHead5);

		FoldLinkedList::ListNode * fllHead6 = new FoldLinkedList::ListNode(1);
		fllHead6->next = new FoldLinkedList::ListNode(2);
		fllHead6->next->next = new FoldLinkedList::ListNode(3);
		fllHead6->next->next->next = new FoldLinkedList::ListNode(4);
		fllHead6->next->next->next->next = new FoldLinkedList::ListNode(5);
		fllHead6->next->next->next->next->next = new FoldLinkedList::ListNode(6);
		llOss << "FoldLinkedList Reverse 2nd Half and Merge:" << std::endl;
		PrintLinkedList<FoldLinkedList::ListNode, std::ostringstream>(fllHead6, llOss);
		fllHead4 = FoldLinkedList().Solve_Reverse2ndHalf_Merge(fllHead6);
		PrintLinkedList<FoldLinkedList::ListNode, std::ostringstream>(fllHead6, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		FoldLinkedList::DeleteLinkedList(fllHead6);

		FoldLinkedList::ListNode * fllHead7 = new FoldLinkedList::ListNode(1);
		fllHead7->next = new FoldLinkedList::ListNode(2);
		fllHead7->next->next = new FoldLinkedList::ListNode(3);
		fllHead7->next->next->next = new FoldLinkedList::ListNode(4);
		fllHead7->next->next->next->next = new FoldLinkedList::ListNode(5);
		llOss << "FoldLinkedList RandomAccessCache:" << std::endl;
		PrintLinkedList<FoldLinkedList::ListNode, std::ostringstream>(fllHead7, llOss);
		fllHead3 = FoldLinkedList().RandomAccessCache(fllHead7);
		PrintLinkedList<FoldLinkedList::ListNode, std::ostringstream>(fllHead7, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		FoldLinkedList::DeleteLinkedList(fllHead7);

		FoldLinkedList::ListNode * fllHead8 = new FoldLinkedList::ListNode(1);
		fllHead8->next = new FoldLinkedList::ListNode(2);
		fllHead8->next->next = new FoldLinkedList::ListNode(3);
		fllHead8->next->next->next = new FoldLinkedList::ListNode(4);
		fllHead8->next->next->next->next = new FoldLinkedList::ListNode(5);
		fllHead8->next->next->next->next->next = new FoldLinkedList::ListNode(6);
		llOss << "FoldLinkedList RandomAccessCache:" << std::endl;
		PrintLinkedList<FoldLinkedList::ListNode, std::ostringstream>(fllHead8, llOss);
		fllHead4 = FoldLinkedList().RandomAccessCache(fllHead8);
		PrintLinkedList<FoldLinkedList::ListNode, std::ostringstream>(fllHead8, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		FoldLinkedList::DeleteLinkedList(fllHead8);
	}
	{
		YIntersectionLinkedList::ListNode * head1 = new YIntersectionLinkedList::ListNode(1);
		head1->next = new YIntersectionLinkedList::ListNode(2);
		head1->next->next = new YIntersectionLinkedList::ListNode(3);
		head1->next->next->next = new YIntersectionLinkedList::ListNode(4);
		head1->next->next->next->next = new YIntersectionLinkedList::ListNode(5);
		head1->next->next->next->next->next = new YIntersectionLinkedList::ListNode(6);
		head1->next->next->next->next->next->next = new YIntersectionLinkedList::ListNode(7);
		head1->next->next->next->next->next->next->next = new YIntersectionLinkedList::ListNode(8);
		YIntersectionLinkedList::ListNode * head2 = new YIntersectionLinkedList::ListNode(11);
		head2->next = new YIntersectionLinkedList::ListNode(12);
		head2->next->next = new YIntersectionLinkedList::ListNode(13);
		head2->next->next->next = new YIntersectionLinkedList::ListNode(14);
		head2->next->next->next->next = head1->next->next->next->next;
		YIntersectionLinkedList::ListNode * intersection = 
			YIntersectionLinkedList().FindIntersectionNode(head1, head2);
		YIntersectionLinkedList::DeleteLinkedList(head1, head2, intersection);

		head1 = new YIntersectionLinkedList::ListNode(1);
		head1->next = new YIntersectionLinkedList::ListNode(2);
		head1->next->next = new YIntersectionLinkedList::ListNode(3);
		head1->next->next->next = new YIntersectionLinkedList::ListNode(4);
		head1->next->next->next->next = new YIntersectionLinkedList::ListNode(5);
		head1->next->next->next->next->next = new YIntersectionLinkedList::ListNode(6);
		head1->next->next->next->next->next->next = new YIntersectionLinkedList::ListNode(7);
		head1->next->next->next->next->next->next->next = new YIntersectionLinkedList::ListNode(8);
		head1->next->next->next->next->next->next->next->next = new YIntersectionLinkedList::ListNode(9);
		head2 = new YIntersectionLinkedList::ListNode(11);
		head2->next = new YIntersectionLinkedList::ListNode(12);
		head2->next->next = new YIntersectionLinkedList::ListNode(13);
		head2->next->next->next = new YIntersectionLinkedList::ListNode(14);
		head2->next->next->next->next = head1->next->next->next->next;
		head1->next->next->next->next->next->next->next->next->next = head2->next->next;
		YIntersectionLinkedList().FindIntersectionNode_WCycles(head1, head2);
		YIntersectionLinkedList::DeleteLinkedList(head1, head2);
	}
	{
		JosephusProblem().GetSurvivorIdxRecur(5, 2);
		JosephusProblem().GetSurvivorIdxRecur2(5, 2);
		JosephusProblem().GetSurvivorIdxIterate(5, 2);
		JosephusProblem::ListNode * head1 = new JosephusProblem::ListNode(1);
		head1->next = new JosephusProblem::ListNode(2);
		head1->next->next = new JosephusProblem::ListNode(3);
		head1->next->next->next = new JosephusProblem::ListNode(4);
		head1->next->next->next->next = new JosephusProblem::ListNode(5);
		head1->next->next->next->next->next = head1;
		llOss << "JosephusProblem GetLastNodeIterate for K = 2:" << std::endl;
		PrintLinkedList<JosephusProblem::ListNode, std::ostringstream>(head1, llOss);
		head1 = JosephusProblem().GetLastNodeIterate(head1, 2);
		PrintLinkedList<JosephusProblem::ListNode, std::ostringstream>(head1, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		JosephusProblem::DeleteLinkedList(head1);

		JosephusProblem().GetSurvivorIdxRecur(8, 5);
		JosephusProblem().GetSurvivorIdxRecur2(8, 5);
		JosephusProblem().GetSurvivorIdxIterate(8, 5);
		head1 = new JosephusProblem::ListNode(1);
		head1->next = new JosephusProblem::ListNode(2);
		head1->next->next = new JosephusProblem::ListNode(3);
		head1->next->next->next = new JosephusProblem::ListNode(4);
		head1->next->next->next->next = new JosephusProblem::ListNode(5);
		head1->next->next->next->next->next = new JosephusProblem::ListNode(6);
		head1->next->next->next->next->next->next = new JosephusProblem::ListNode(7);
		head1->next->next->next->next->next->next->next = new JosephusProblem::ListNode(8);
		head1->next->next->next->next->next->next->next->next = head1;
		llOss << "JosephusProblem GetLastNodeIterate for K = 5:" << std::endl;
		PrintLinkedList<JosephusProblem::ListNode, std::ostringstream>(head1, llOss);
		head1 = JosephusProblem().GetLastNodeIterate(head1, 5);
		PrintLinkedList<JosephusProblem::ListNode, std::ostringstream>(head1, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		JosephusProblem::DeleteLinkedList(head1);
	}
	{
		EliminateLeftRightOddNumsGame().Recur(9);
	}
	{
		std::list<int> L({ 1, 2, 3, 4, 5, 6, 7, 8, 9 });
		std::list<int>::const_iterator i = L.begin();
		std::list<int>::const_iterator i1 = i;
		std::list<int>::const_iterator i2 = ++i;
		std::list<int>::const_iterator i3 = ++i;
		std::list<int>::const_iterator i4 = ++i;
		std::list<int>::const_iterator i5 = ++i;
		std::list<int>::const_iterator i6 = ++i;
		std::list<int>::const_iterator i7 = ++i;
		std::list<int>::const_iterator i8 = ++i;
		std::list<int>::const_iterator i9 = ++i;
		std::vector<std::list<int>::const_iterator> V({i8, i9, i7, i3, i5, i2, i1});
		CountBlockOfAdjNodesLinkedList().Solve(L, V);
		std::vector<std::list<int>::const_iterator> V2({ i8, i9, i7, i3, i5, i2, i7, i4, i2, i1, i6 });
		CountBlockOfAdjNodesLinkedList().Solve(L, V2);
	}
	{
		EvenOddMergeLinkedList::ListNode * h = new EvenOddMergeLinkedList::ListNode(0);
		h->next = new EvenOddMergeLinkedList::ListNode(1);
		h->next->next = new EvenOddMergeLinkedList::ListNode(2);
		h->next->next->next = new EvenOddMergeLinkedList::ListNode(3);
		h->next->next->next->next = new EvenOddMergeLinkedList::ListNode(4);
		h->next->next->next->next->next = new EvenOddMergeLinkedList::ListNode(5);
		h->next->next->next->next->next->next = new EvenOddMergeLinkedList::ListNode(6);
		h->next->next->next->next->next->next->next = new EvenOddMergeLinkedList::ListNode(7);
		llOss << "EvenOddMergeLinkedList Iterate:" << std::endl;
		PrintLinkedList<EvenOddMergeLinkedList::ListNode, std::ostringstream>(h, llOss);
		EvenOddMergeLinkedList().Solve_Iterate(h);
		PrintLinkedList<EvenOddMergeLinkedList::ListNode, std::ostringstream>(h, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		EvenOddMergeLinkedList::DeleteLinkedList(h);

		h = new EvenOddMergeLinkedList::ListNode(0);
		h->next = new EvenOddMergeLinkedList::ListNode(1);
		h->next->next = new EvenOddMergeLinkedList::ListNode(2);
		h->next->next->next = new EvenOddMergeLinkedList::ListNode(3);
		h->next->next->next->next = new EvenOddMergeLinkedList::ListNode(4);
		h->next->next->next->next->next = new EvenOddMergeLinkedList::ListNode(5);
		h->next->next->next->next->next->next = new EvenOddMergeLinkedList::ListNode(6);
		h->next->next->next->next->next->next->next = new EvenOddMergeLinkedList::ListNode(7);
		h->next->next->next->next->next->next->next->next = new EvenOddMergeLinkedList::ListNode(8);
		llOss << "EvenOddMergeLinkedList Iterate:" << std::endl;
		PrintLinkedList<EvenOddMergeLinkedList::ListNode, std::ostringstream>(h, llOss);
		EvenOddMergeLinkedList().Solve_Iterate(h);
		PrintLinkedList<EvenOddMergeLinkedList::ListNode, std::ostringstream>(h, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		EvenOddMergeLinkedList::DeleteLinkedList(h);
	}
	{
		MedianOfSortedCircularLinkedList::ListNode * h = new MedianOfSortedCircularLinkedList::ListNode(1);
		h->next = new MedianOfSortedCircularLinkedList::ListNode(1);
		h->next->next = new MedianOfSortedCircularLinkedList::ListNode(1);
		h->next->next->next = new MedianOfSortedCircularLinkedList::ListNode(3);
		h->next->next->next->next = new MedianOfSortedCircularLinkedList::ListNode(5);
		h->next->next->next->next->next = new MedianOfSortedCircularLinkedList::ListNode(6);
		h->next->next->next->next->next->next = new MedianOfSortedCircularLinkedList::ListNode(7);
		h->next->next->next->next->next->next->next = new MedianOfSortedCircularLinkedList::ListNode(7);
		h->next->next->next->next->next->next->next->next = new MedianOfSortedCircularLinkedList::ListNode(8);
		h->next->next->next->next->next->next->next->next->next = h;
		llOss << "MedianOfSortedCircularLinkedList:" << std::endl;
		PrintLinkedList<MedianOfSortedCircularLinkedList::ListNode, std::ostringstream>(h, llOss);
		double res = MedianOfSortedCircularLinkedList().Find(h->next->next->next->next->next->next->next);
		llOss << res << std::endl;
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		MedianOfSortedCircularLinkedList::DeleteLinkedList(h);
	}
	{
		JumpFirstOrderPostingsLinkedList::RandomListNode * head = new JumpFirstOrderPostingsLinkedList::RandomListNode(1);
		head->next = new JumpFirstOrderPostingsLinkedList::RandomListNode(2);
		head->next->next = new JumpFirstOrderPostingsLinkedList::RandomListNode(3);
		head->next->next->next = new JumpFirstOrderPostingsLinkedList::RandomListNode(4);
		head->next->next->next->next = new JumpFirstOrderPostingsLinkedList::RandomListNode(5);
		head->next->next->next->next->next = new JumpFirstOrderPostingsLinkedList::RandomListNode(6);
		head->random = head->next->next->next->next;
		head->next->random = head->next;
		head->next->next->random = head->next->next->next;
		head->next->next->next->random = head->next->next;
		head->next->next->next->next->random = head->next->next->next->next->next;
		head->next->next->next->next->next->random = head;
		JumpFirstOrderPostingsLinkedList::RandomListNode * head2 = new JumpFirstOrderPostingsLinkedList::RandomListNode(1);
		head2->next = new JumpFirstOrderPostingsLinkedList::RandomListNode(2);
		head2->next->next = new JumpFirstOrderPostingsLinkedList::RandomListNode(3);
		head2->next->next->next = new JumpFirstOrderPostingsLinkedList::RandomListNode(4);
		head2->next->next->next->next = new JumpFirstOrderPostingsLinkedList::RandomListNode(5);
		head2->next->next->next->next->next = new JumpFirstOrderPostingsLinkedList::RandomListNode(6);
		head2->random = head2->next->next->next->next;
		head2->next->random = head2->next;
		head2->next->next->random = head2->next->next->next;
		head2->next->next->next->random = head2->next->next;
		head2->next->next->next->next->random = head2->next->next->next->next->next;
		head2->next->next->next->next->next->random = head2;
		JumpFirstOrderPostingsLinkedList::Print(head, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		JumpFirstOrderPostingsLinkedList().DFSRecur_HashTable(head);
		JumpFirstOrderPostingsLinkedList::Print(head2, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		JumpFirstOrderPostingsLinkedList().Iterate_HashTable_Stack(head);
		JumpFirstOrderPostingsLinkedList::DeleteLinkedList(head);
		JumpFirstOrderPostingsLinkedList::DeleteLinkedList(head2);
	}
	{
		RemoveNodesWGivenValLinkedList::ListNode * head = new RemoveNodesWGivenValLinkedList::ListNode(1);
		head->next = new RemoveNodesWGivenValLinkedList::ListNode(2);
		head->next->next = new RemoveNodesWGivenValLinkedList::ListNode(6);
		head->next->next->next = new RemoveNodesWGivenValLinkedList::ListNode(3);
		head->next->next->next->next = new RemoveNodesWGivenValLinkedList::ListNode(4);
		head->next->next->next->next->next = new RemoveNodesWGivenValLinkedList::ListNode(5);
		head->next->next->next->next->next->next = new RemoveNodesWGivenValLinkedList::ListNode(6);
		PrintLinkedList<RemoveNodesWGivenValLinkedList::ListNode, std::ostringstream>(head, llOss);
		llOss << "RemoveNodesWGivenValLinkedList for 6:" << std::endl;
		RemoveNodesWGivenValLinkedList().Iterate(head, 6);
		PrintLinkedList<RemoveNodesWGivenValLinkedList::ListNode, std::ostringstream>(head, llOss);
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		RemoveNodesWGivenValLinkedList::DeleteLinkedList(head);
	}
	{
		PalindromeLinkedList::ListNode * head = new PalindromeLinkedList::ListNode(1);
		head->next = new PalindromeLinkedList::ListNode(2);
		head->next->next = new PalindromeLinkedList::ListNode(3);
		head->next->next->next = new PalindromeLinkedList::ListNode(4);
		head->next->next->next->next = new PalindromeLinkedList::ListNode(5);
		head->next->next->next->next->next = new PalindromeLinkedList::ListNode(4);
		head->next->next->next->next->next->next = new PalindromeLinkedList::ListNode(3);
		head->next->next->next->next->next->next->next = new PalindromeLinkedList::ListNode(2);
		head->next->next->next->next->next->next->next->next = new PalindromeLinkedList::ListNode(1);
		PrintLinkedList<PalindromeLinkedList::ListNode, std::ostringstream>(head, llOss);
		bool res = PalindromeLinkedList().Solve_Recur(head);
		llOss << "PalindromeLinkedList Recur for the above linked list: " << res << std::endl;
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		PalindromeLinkedList::DeleteLinkedList(head);

		head = new PalindromeLinkedList::ListNode(1);
		head->next = new PalindromeLinkedList::ListNode(2);
		head->next->next = new PalindromeLinkedList::ListNode(3);
		head->next->next->next = new PalindromeLinkedList::ListNode(4);
		head->next->next->next->next = new PalindromeLinkedList::ListNode(4);
		head->next->next->next->next->next = new PalindromeLinkedList::ListNode(6);
		head->next->next->next->next->next->next = new PalindromeLinkedList::ListNode(2);
		head->next->next->next->next->next->next->next = new PalindromeLinkedList::ListNode(1);
		PrintLinkedList<PalindromeLinkedList::ListNode, std::ostringstream>(head, llOss);
		res = PalindromeLinkedList().Solve_Recur(head);
		llOss << "PalindromeLinkedList Recur for the above linked list: " << res << std::endl;
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		PalindromeLinkedList::DeleteLinkedList(head);

		head = new PalindromeLinkedList::ListNode(1);
		head->next = new PalindromeLinkedList::ListNode(2);
		head->next->next = new PalindromeLinkedList::ListNode(3);
		head->next->next->next = new PalindromeLinkedList::ListNode(4);
		head->next->next->next->next = new PalindromeLinkedList::ListNode(5);
		head->next->next->next->next->next = new PalindromeLinkedList::ListNode(4);
		head->next->next->next->next->next->next = new PalindromeLinkedList::ListNode(3);
		head->next->next->next->next->next->next->next = new PalindromeLinkedList::ListNode(2);
		head->next->next->next->next->next->next->next->next = new PalindromeLinkedList::ListNode(1);
		PrintLinkedList<PalindromeLinkedList::ListNode, std::ostringstream>(head, llOss);
		res = PalindromeLinkedList().Solve_Reverse2ndHalf_Compare(head);
		llOss << "PalindromeLinkedList Reverse2ndHalf_Compare for the above linked list: " << res << std::endl;
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		PalindromeLinkedList::DeleteLinkedList(head);

		head = new PalindromeLinkedList::ListNode(1);
		head->next = new PalindromeLinkedList::ListNode(2);
		head->next->next = new PalindromeLinkedList::ListNode(3);
		head->next->next->next = new PalindromeLinkedList::ListNode(4);
		head->next->next->next->next = new PalindromeLinkedList::ListNode(5);
		head->next->next->next->next->next = new PalindromeLinkedList::ListNode(3);
		head->next->next->next->next->next->next = new PalindromeLinkedList::ListNode(2);
		head->next->next->next->next->next->next->next = new PalindromeLinkedList::ListNode(1);
		PrintLinkedList<PalindromeLinkedList::ListNode, std::ostringstream>(head, llOss);
		res = PalindromeLinkedList().Solve_Reverse2ndHalf_Compare(head);
		llOss << "PalindromeLinkedList Reverse2ndHalf_Compare for the above linked list: " << res << std::endl;
		std::cout << llOss.str() << std::endl;
		llOss.str(std::string());
		PalindromeLinkedList::DeleteLinkedList(head);
	}
    {
        SplitNodesInKGroupLinkedList::ListNode * head = new SplitNodesInKGroupLinkedList::ListNode(1);
        head->next = new SplitNodesInKGroupLinkedList::ListNode(2);
        head->next->next = new SplitNodesInKGroupLinkedList::ListNode(3);
        head->next->next->next = new SplitNodesInKGroupLinkedList::ListNode(4);
        head->next->next->next->next = new SplitNodesInKGroupLinkedList::ListNode(5);
        head->next->next->next->next->next = new SplitNodesInKGroupLinkedList::ListNode(6);
        head->next->next->next->next->next->next = new SplitNodesInKGroupLinkedList::ListNode(7);
        head->next->next->next->next->next->next->next = new SplitNodesInKGroupLinkedList::ListNode(8);
        head->next->next->next->next->next->next->next->next = new SplitNodesInKGroupLinkedList::ListNode(9);
        head->next->next->next->next->next->next->next->next->next = new SplitNodesInKGroupLinkedList::ListNode(10);
        PrintLinkedList<SplitNodesInKGroupLinkedList::ListNode, std::ostringstream>(head, llOss);
        std::vector<SplitNodesInKGroupLinkedList::ListNode*> res = SplitNodesInKGroupLinkedList().TwoScan(head, 3);
        llOss << "SplitNodesInKGroupLinkedList TwoScan for above linked list: " << std::endl;
        for (auto & h : res)
            PrintLinkedList<SplitNodesInKGroupLinkedList::ListNode, std::ostringstream>(h, llOss);
        std::cout << llOss.str() << std::endl;
        llOss.str(std::string());
        for (auto & h : res)
            SplitNodesInKGroupLinkedList::DeleteLinkedList(h);
    }
    {
        FlattenMultilevelLinkedList::ListNode * r = new FlattenMultilevelLinkedList::ListNode(1);
        r->next = new FlattenMultilevelLinkedList::ListNode(2);
        r->next->next = new FlattenMultilevelLinkedList::ListNode(3);
        r->next->next->next = new FlattenMultilevelLinkedList::ListNode(4);
        r->next->down = new FlattenMultilevelLinkedList::ListNode(7);
        r->next->down->next = new FlattenMultilevelLinkedList::ListNode(8);
        r->next->down->next->next = new FlattenMultilevelLinkedList::ListNode(10);
        r->next->down->next->next->next = new FlattenMultilevelLinkedList::ListNode(12);
        r->next->down->down = new FlattenMultilevelLinkedList::ListNode(9);
        r->next->down->down->down = new FlattenMultilevelLinkedList::ListNode(14);
        r->next->down->down->down->down = new FlattenMultilevelLinkedList::ListNode(15);
        r->next->down->down->down->down->next = new FlattenMultilevelLinkedList::ListNode(23);
        r->next->down->down->down->down->next->down = new FlattenMultilevelLinkedList::ListNode(24);
        r->next->down->next->down = new FlattenMultilevelLinkedList::ListNode(16);
        r->next->down->next->down->down = new FlattenMultilevelLinkedList::ListNode(17);
        r->next->down->next->down->down->next = new FlattenMultilevelLinkedList::ListNode(18);
        r->next->down->next->down->down->next->next = new FlattenMultilevelLinkedList::ListNode(19);
        r->next->down->next->down->down->next->next->next = new FlattenMultilevelLinkedList::ListNode(20);
        r->next->down->next->down->down->next->next->next->down = new FlattenMultilevelLinkedList::ListNode(21);
        r->next->down->next->next->down = new FlattenMultilevelLinkedList::ListNode(11);
        r = FlattenMultilevelLinkedList().DFS(r);
        llOss << "FlattenMultilevelLinkedList DFS:" << std::endl;
        PrintLinkedList<FlattenMultilevelLinkedList::ListNode, std::ostringstream>(r, llOss);
        std::cout << llOss.str() << std::endl;
        llOss.str(std::string());

        FlattenMultilevelLinkedList::ListNode * s = new FlattenMultilevelLinkedList::ListNode(1);
        s->next = new FlattenMultilevelLinkedList::ListNode(2);
        s->next->next = new FlattenMultilevelLinkedList::ListNode(3);
        s->next->next->next = new FlattenMultilevelLinkedList::ListNode(4);
        s->next->down = new FlattenMultilevelLinkedList::ListNode(7);
        s->next->down->next = new FlattenMultilevelLinkedList::ListNode(8);
        s->next->down->next->next = new FlattenMultilevelLinkedList::ListNode(10);
        s->next->down->next->next->next = new FlattenMultilevelLinkedList::ListNode(12);
        s->next->down->down = new FlattenMultilevelLinkedList::ListNode(9);
        s->next->down->down->down = new FlattenMultilevelLinkedList::ListNode(14);
        s->next->down->down->down->down = new FlattenMultilevelLinkedList::ListNode(15);
        s->next->down->down->down->down->next = new FlattenMultilevelLinkedList::ListNode(23);
        s->next->down->down->down->down->next->down = new FlattenMultilevelLinkedList::ListNode(24);
        s->next->down->next->down = new FlattenMultilevelLinkedList::ListNode(16);
        s->next->down->next->down->down = new FlattenMultilevelLinkedList::ListNode(17);
        s->next->down->next->down->down->next = new FlattenMultilevelLinkedList::ListNode(18);
        s->next->down->next->down->down->next->next = new FlattenMultilevelLinkedList::ListNode(19);
        s->next->down->next->down->down->next->next->next = new FlattenMultilevelLinkedList::ListNode(20);
        s->next->down->next->down->down->next->next->next->down = new FlattenMultilevelLinkedList::ListNode(21);
        s->next->down->next->next->down = new FlattenMultilevelLinkedList::ListNode(11);
        s = FlattenMultilevelLinkedList().BFS(s);
        llOss << "FlattenMultilevelLinkedList BFS:" << std::endl;
        PrintLinkedList<FlattenMultilevelLinkedList::ListNode, std::ostringstream>(s, llOss);
        std::cout << llOss.str() << std::endl;
        llOss.str(std::string());

        FlattenMultilevelLinkedList::ListNode * t = new FlattenMultilevelLinkedList::ListNode(10);
        t->down = new FlattenMultilevelLinkedList::ListNode(4);
        t->down->next = new FlattenMultilevelLinkedList::ListNode(20);
        t->down->next->down = new FlattenMultilevelLinkedList::ListNode(2);
        t->down->next->next = new FlattenMultilevelLinkedList::ListNode(13);
        t->down->next->next->down = new FlattenMultilevelLinkedList::ListNode(16);
        t->down->next->next->down->down = new FlattenMultilevelLinkedList::ListNode(3);
        t->down->next->next->next = new FlattenMultilevelLinkedList::ListNode(17);
        t->down->next->next->next->down = new FlattenMultilevelLinkedList::ListNode(9);
        t->down->next->next->next->down->down = new FlattenMultilevelLinkedList::ListNode(19);
        t->down->next->next->next->down->down->next = new FlattenMultilevelLinkedList::ListNode(15);
        t->down->next->next->next->down->next = new FlattenMultilevelLinkedList::ListNode(8);
        t->down->next->next->next->next = new FlattenMultilevelLinkedList::ListNode(6);
        t->next = new FlattenMultilevelLinkedList::ListNode(5);
        t->next->next = new FlattenMultilevelLinkedList::ListNode(12);
        t->next->next->next = new FlattenMultilevelLinkedList::ListNode(7);
        t->next->next->next->next = new FlattenMultilevelLinkedList::ListNode(11);
        t->next->next->next->down = t->down->next->next->next;
        t->down->next->next->next->next->next = t->down->next->next->next->down->down->next;
        t->down->next->next->next->down->next->next = t->next->next->next->next;
        t = FlattenMultilevelLinkedList().DFS(t);
        llOss << "FlattenMultilevelLinkedList DFS:" << std::endl;
        PrintLinkedList<FlattenMultilevelLinkedList::ListNode, std::ostringstream>(t, llOss);
        std::cout << llOss.str() << std::endl;
        llOss.str(std::string());

        FlattenMultilevelLinkedList::ListNode * u = new FlattenMultilevelLinkedList::ListNode(10);
        u->down = new FlattenMultilevelLinkedList::ListNode(4);
        u->down->next = new FlattenMultilevelLinkedList::ListNode(20);
        u->down->next->down = new FlattenMultilevelLinkedList::ListNode(2);
        u->down->next->next = new FlattenMultilevelLinkedList::ListNode(13);
        u->down->next->next->down = new FlattenMultilevelLinkedList::ListNode(16);
        u->down->next->next->down->down = new FlattenMultilevelLinkedList::ListNode(3);
        u->down->next->next->next = new FlattenMultilevelLinkedList::ListNode(17);
        u->down->next->next->next->down = new FlattenMultilevelLinkedList::ListNode(9);
        u->down->next->next->next->down->down = new FlattenMultilevelLinkedList::ListNode(19);
        u->down->next->next->next->down->down->next = new FlattenMultilevelLinkedList::ListNode(15);
        u->down->next->next->next->down->next = new FlattenMultilevelLinkedList::ListNode(8);
        u->down->next->next->next->next = new FlattenMultilevelLinkedList::ListNode(6);
        u->next = new FlattenMultilevelLinkedList::ListNode(5);
        u->next->next = new FlattenMultilevelLinkedList::ListNode(12);
        u->next->next->next = new FlattenMultilevelLinkedList::ListNode(7);
        u->next->next->next->next = new FlattenMultilevelLinkedList::ListNode(11);
        u->next->next->next->down = u->down->next->next->next;
        u->down->next->next->next->next->next = u->down->next->next->next->down->down->next;
        u->down->next->next->next->down->next->next = u->next->next->next->next;
        u = FlattenMultilevelLinkedList().BFS(u);
        llOss << "FlattenMultilevelLinkedList BFS:" << std::endl;
        PrintLinkedList<FlattenMultilevelLinkedList::ListNode, std::ostringstream>(u, llOss);
        std::cout << llOss.str() << std::endl;
        llOss.str(std::string());
    }
    {
        TraverseMultilevelLinkedList::ListNode * r = new TraverseMultilevelLinkedList::ListNode(1);
        r->next = new TraverseMultilevelLinkedList::ListNode(2);
        r->next->next = new TraverseMultilevelLinkedList::ListNode(3);
        r->next->next->next = new TraverseMultilevelLinkedList::ListNode(4);
        r->next->down = new TraverseMultilevelLinkedList::ListNode(7);
        r->next->down->next = new TraverseMultilevelLinkedList::ListNode(8);
        r->next->down->next->next = new TraverseMultilevelLinkedList::ListNode(10);
        r->next->down->next->next->next = new TraverseMultilevelLinkedList::ListNode(12);
        r->next->down->down = new TraverseMultilevelLinkedList::ListNode(9);
        r->next->down->down->down = new TraverseMultilevelLinkedList::ListNode(14);
        r->next->down->down->down->down = new TraverseMultilevelLinkedList::ListNode(15);
        r->next->down->down->down->down->next = new TraverseMultilevelLinkedList::ListNode(23);
        r->next->down->down->down->down->next->down = new TraverseMultilevelLinkedList::ListNode(24);
        r->next->down->next->down = new TraverseMultilevelLinkedList::ListNode(16);
        r->next->down->next->down->down = new TraverseMultilevelLinkedList::ListNode(17);
        r->next->down->next->down->down->next = new TraverseMultilevelLinkedList::ListNode(18);
        r->next->down->next->down->down->next->next = new TraverseMultilevelLinkedList::ListNode(19);
        r->next->down->next->down->down->next->next->next = new TraverseMultilevelLinkedList::ListNode(20);
        r->next->down->next->down->down->next->next->next->down = new TraverseMultilevelLinkedList::ListNode(21);
        r->next->down->next->next->down = new TraverseMultilevelLinkedList::ListNode(11);
        TraverseMultilevelLinkedList().Levelorder(r);
        TraverseMultilevelLinkedList().Verticalorder(r);
        TraverseMultilevelLinkedList().PreorderNext(r);
        TraverseMultilevelLinkedList().PreorderDown(r);

        TraverseMultilevelLinkedList::ListNode * t = new TraverseMultilevelLinkedList::ListNode(10);
        t->down = new TraverseMultilevelLinkedList::ListNode(4);
        t->down->next = new TraverseMultilevelLinkedList::ListNode(20);
        t->down->next->down = new TraverseMultilevelLinkedList::ListNode(2);
        t->down->next->next = new TraverseMultilevelLinkedList::ListNode(13);
        t->down->next->next->down = new TraverseMultilevelLinkedList::ListNode(16);
        t->down->next->next->down->down = new TraverseMultilevelLinkedList::ListNode(3);
        t->down->next->next->next = new TraverseMultilevelLinkedList::ListNode(17);
        t->down->next->next->next->down = new TraverseMultilevelLinkedList::ListNode(9);
        t->down->next->next->next->down->down = new TraverseMultilevelLinkedList::ListNode(19);
        t->down->next->next->next->down->down->next = new TraverseMultilevelLinkedList::ListNode(15);
        t->down->next->next->next->down->next = new TraverseMultilevelLinkedList::ListNode(8);
        t->down->next->next->next->next = new TraverseMultilevelLinkedList::ListNode(6);
        t->next = new TraverseMultilevelLinkedList::ListNode(5);
        t->next->next = new TraverseMultilevelLinkedList::ListNode(12);
        t->next->next->next = new TraverseMultilevelLinkedList::ListNode(7);
        t->next->next->next->next = new TraverseMultilevelLinkedList::ListNode(11);
        t->next->next->next->down = t->down->next->next->next;
        t->down->next->next->next->next->next = t->down->next->next->next->down->down->next;
        t->down->next->next->next->down->next->next = t->next->next->next->next;
        TraverseMultilevelLinkedList().Levelorder(t);
        TraverseMultilevelLinkedList().Verticalorder(t);
        TraverseMultilevelLinkedList().PreorderNext(t);
        TraverseMultilevelLinkedList().PreorderDown(t);

    }
    {
        SkipList l(3, 0.5);
        l.Print();
        l.Insert(13);
        l.Insert(9);
        l.Insert(7);
        l.Insert(6);
        l.Insert(12);
        l.Insert(19);
        l.Insert(17);
        l.Insert(2);
        l.Insert(4);
        l.Insert(0);
        l.Insert(10);
        l.Search(19);
        l.Remove(2);
        l.Search(10);
        l.Remove(12);
        l.Remove(6);
        l.Remove(10);
        l.Remove(13);
        l.Insert(8);
    }
    {
        NextGreaterNodeInLinkedList::ListNode * h = new NextGreaterNodeInLinkedList::ListNode(1);
        h->next = new NextGreaterNodeInLinkedList::ListNode(7);
        h->next->next = new NextGreaterNodeInLinkedList::ListNode(5);
        h->next->next->next = new NextGreaterNodeInLinkedList::ListNode(1);
        h->next->next->next->next = new NextGreaterNodeInLinkedList::ListNode(9);
        h->next->next->next->next->next = new NextGreaterNodeInLinkedList::ListNode(2);
        h->next->next->next->next->next->next = new NextGreaterNodeInLinkedList::ListNode(5);
        h->next->next->next->next->next->next->next = new NextGreaterNodeInLinkedList::ListNode(1);
        PrintLinkedList<NextGreaterNodeInLinkedList::ListNode, std::ostringstream>(h, llOss);
        std::cout << llOss.str() << std::endl;
        NextGreaterNodeInLinkedList().UseStack(h);
        NextGreaterNodeInLinkedList::DeleteLinkedList(h);
        llOss.str(std::string());
    }
    {
        PrintLinkedListInReverse::ListNode * h = new PrintLinkedListInReverse::ListNode(1);
        h->next = new PrintLinkedListInReverse::ListNode(2);
        h->next->next = new PrintLinkedListInReverse::ListNode(3);
        h->next->next->next = new PrintLinkedListInReverse::ListNode(4);
        PrintLinkedList<PrintLinkedListInReverse::ListNode, std::ostringstream>(h, llOss);
        std::cout << llOss.str() << std::endl; llOss.str(std::string());
        PrintLinkedListInReverse().DivideConquer(h);
        h->next->next->next->next = new PrintLinkedListInReverse::ListNode(5);
        PrintLinkedList<PrintLinkedListInReverse::ListNode, std::ostringstream>(h, llOss);
        std::cout << llOss.str() << std::endl; llOss.str(std::string());
        PrintLinkedListInReverse().DivideConquer(h);
    }

#endif
#ifdef _2DGrid_
	/*2D Grid*/
	RdCout ? redirect_cout::to_file("Out_2DGrid.txt") : redirect_cout::to_cout();
	PrintH("2D Grid");
	{
		std::vector<std::vector<char>> maxRectangleGrid(
		{
			{ '0', '1', '1', '1', '0', '0', '0' },
			{ '0', '1', '1', '1', '0', '1', '1' },
			{ '1', '1', '0', '0', '0', '1', '1' },
			{ '1', '1', '1', '1', '1', '1', '0' },
			{ '0', '1', '1', '1', '1', '1', '0' },
			{ '0', '0', '1', '1', '1', '1', '0' },
			{ '0', '0', '0', '1', '1', '0', '0' }
		});
		MaxRectangle().Histogram(maxRectangleGrid);
		MaxRectangle().BruteForce(maxRectangleGrid);
		MaxRectangle().DP2D_SquareSubmatrix(maxRectangleGrid);

		std::vector<std::vector<char>> maxRectangleGrid2(
		{
			{ '1', '1', '1', '0', '0', '0', '0', '0', '0', '0' },
			{ '1', '1', '1', '1', '1', '0', '0', '0', '0', '0' },
			{ '1', '1', '1', '0', '1', '0', '0', '0', '0', '0' },
			{ '0', '1', '0', '1', '1', '1', '1', '1', '1', '1' },
			{ '1', '1', '1', '1', '1', '0', '0', '1', '0', '1' },
			{ '1', '0', '0', '1', '0', '0', '0', '1', '0', '1' },
			{ '1', '0', '0', '1', '1', '0', '0', '1', '0', '1' },
			{ '1', '1', '1', '1', '1', '1', '1', '1', '0', '1' },
			{ '0', '0', '0', '1', '0', '0', '0', '0', '0', '1' },
			{ '0', '0', '0', '1', '1', '1', '1', '1', '1', '1' },
		});
		MaxRectangle().DP2D_SquareSubmatrix(maxRectangleGrid2);
	}
	{
		MaxSubSquareBorder().BruteForce(std::vector<std::vector<int>>(
		{
			{ 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 },
			{ 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 },
			{ 1, 1, 1, 0, 1, 0, 0, 0, 0, 0 },
			{ 0, 1, 0, 1, 1, 1, 1, 1, 1, 1 },
			{ 1, 1, 1, 1, 1, 0, 0, 1, 0, 1 },
			{ 1, 0, 0, 1, 0, 0, 0, 1, 0, 1 },
			{ 1, 0, 0, 1, 1, 0, 0, 1, 0, 1 },
			{ 1, 1, 1, 1, 1, 1, 1, 1, 0, 1 },
			{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 1 },
			{ 0, 0, 0, 1, 1, 1, 1, 1, 1, 1 },
		}));
		MaxSubSquareBorder().Preprocess(std::vector<std::vector<int>>(
		{
			{ 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 },
			{ 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 },
			{ 1, 1, 1, 0, 1, 0, 0, 0, 0, 0 },
			{ 0, 1, 0, 1, 1, 1, 1, 1, 1, 1 },
			{ 1, 1, 1, 1, 1, 0, 0, 1, 0, 1 },
			{ 1, 0, 0, 1, 0, 0, 0, 1, 0, 1 },
			{ 1, 0, 0, 1, 1, 0, 0, 1, 0, 1 },
			{ 1, 1, 1, 1, 1, 1, 1, 1, 0, 1 },
			{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 1 },
			{ 0, 0, 0, 1, 1, 1, 1, 1, 1, 1 },
		}));
	}
	{
		std::vector<std::vector<char>> surroundedRegionsGrid(
		{
			{ 'X', 'X', 'X', 'X' },
			{ 'X', 'O', 'O', 'X' },
			{ 'X', 'O', 'X', 'O' },
			{ 'O', 'X', 'O', 'X' },
			{ 'O', 'O', 'X', 'O' },
		}
		);
		std::vector<std::vector<char>> surroundedRegionsGrid2(surroundedRegionsGrid);
		SurroundedRegions().FlipAll_BFS(surroundedRegionsGrid);
		SurroundedRegions().FlipAll_DFS(surroundedRegionsGrid2);
	}
	{
		std::vector<std::vector<int>> setMatrixZerosGrid(
		{
			{ 1, 0, 3, 7 },
			{ 9, 0, 1, 2 },
			{ 3, 8, 4, 5 },
			{ 7, 8, 6, 9 }
		}
		);
		std::vector<std::vector<int>> setMatrixZerosGrid2(setMatrixZerosGrid);
		SetColRowZerosInMatrix().SetZeros_LinearSpace(setMatrixZerosGrid);
		SetColRowZerosInMatrix().SetZeros_ConstantSpace(setMatrixZerosGrid2);
	}
	{
		std::vector<std::vector<int>> minPathSumGrid(
		{
			{ 1, 7, 3, 7 },
			{ 9, 6, 1, 2 },
			{ 3, 8, 4, 5 }
		}
		);
		MinPathSum().DP_2D(minPathSumGrid);
		MinPathSum().DP_1D(minPathSumGrid);

        MinPathSum().BFS_GeneralCase_WNegativeNums(minPathSumGrid, {0,0}, {2,3});
        MinPathSum().BFS_GeneralCase_WNegativeNums(std::vector<std::vector<int>>(
                {
                        {  1,  7,  4,  7,  3 },
                        { 99, 87, 99, 12,  2 },
                        {  3,  2, 77,  5,  1 },
                        { 77,  1, 76,  5, 62 },
                        {  3,  4,  3,  5,  8 },
                }), {2,0}, {0,0});
        MinPathSum().BFS_GeneralCase_WNegativeNums(std::vector<std::vector<int>>(
                {
                        {  1,  1, 99,  1,  1,  1 },
                        { 99,  1, 99,  1, 99,  1 },
                        {  1,  1,  1, 99,  1,  1 },
                        {  1, 99, 99,  1,  1,  1 },
                        {  1,  1, 99,  1, 99,  1 },
                        {  1,  1,  1,  1, 99,  1 },
                }), {0,0}, {5,5});
        MinPathSum().BFS_GeneralCase_WNegativeNums(std::vector<std::vector<int>>(
                {
                        {  1,  1, 99,  1,  1,  1 },
                        { 99,  1, 99, -6, 99,  1 },
                        {  1,  1,  1, 99,  0, -2 },
                        {  1, 99, 99,  1,  1,  1 },
                        {  1,  1, 99,  1, 99,  1 },
                        {  1,  1,  1,  1, 99,  1 },
                }), {0,0}, {5,5});
	}
	{
		std::vector<std::vector<int>> triangleGrid(
		{
			{ 2 },
			{ 3, 4 },
			{ 6, 5, 7 },
			{ 4, 1, 8, 3 }
		}
		);
		MinPathSumInTriangle().DP_2D(triangleGrid);
		MinPathSumInTriangle().DP_1D(triangleGrid);
	}
	{
		UniquePath().FindAll_Recur(4, 3);
		UniquePath().DP2D_Recur(4, 3);
		UniquePath().DP_2D(4, 3);
		UniquePath().DP_1D(4, 3);
		UniquePath().Math(4, 3);
		std::vector<std::vector<int>> uniquePathGridObstacle(
		{
			{ 0, 0, 0, 0 },
			{ 0, 0, 1, 0 },
			{ 0, 0, 0, 0 }
		}
		);
		UniquePath().DP_2D_wObstacle(uniquePathGridObstacle);
		UniquePath().DP_1D_wObstacle(uniquePathGridObstacle);

		UniquePath().CountAll_DFS(std::vector<std::vector<int>>(
		        {
                        {1,0,0,0},
                        {0,0,0,0},
                        {0,0,0,2}
		        }));
        UniquePath().CountAll_DFS_Memo(std::vector<std::vector<int>>(
                {
                        {1,0,0,0},
                        {0,0,0,0},
                        {0,0,0,2}
                }));
	}
	{
		char wordSearchRow0[] = { 'A', 'B', 'C', 'E' };
		char wordSearchRow1[] = { 'S', 'F', 'C', 'S' };
		char wordSearchRow2[] = { 'A', 'D', 'E', 'E' };
		std::vector<std::vector<char>> wordSearchBoard;
		wordSearchBoard.push_back(std::vector<char>(wordSearchRow0, wordSearchRow0 + sizeof(wordSearchRow0) / sizeof(char)));
		wordSearchBoard.push_back(std::vector<char>(wordSearchRow1, wordSearchRow1 + sizeof(wordSearchRow1) / sizeof(char)));
		wordSearchBoard.push_back(std::vector<char>(wordSearchRow2, wordSearchRow2 + sizeof(wordSearchRow2) / sizeof(char)));
		std::vector<std::vector<char>> wordSearchBoard2 = wordSearchBoard;
		WordSearch().DFS_LinearSpace(wordSearchBoard, "ABCCED");
		WordSearch().DFS_LinearSpace(wordSearchBoard, "SEE");
		WordSearch().DFS_LinearSpace(wordSearchBoard, "ABCB");
		WordSearch().DFS_ConstSpace(wordSearchBoard2, "ABCCED");
		WordSearch().DFS_ConstSpace(wordSearchBoard2, "SEE");
		WordSearch().DFS_ConstSpace(wordSearchBoard2, "ABCB");
	}
	{
		WordSearch2().DFS_ConstSpace_Trie(std::vector<std::vector<char>>(
		{
			{ 'o', 'a', 'a', 'n' },
			{ 'e', 't', 'a', 'e' },
			{ 'i', 'h', 'k', 'r' },
			{ 'i', 'f', 'l', 'v' },
		}), std::vector<std::string>({ "oath", "pea", "eat", "rain" }));
	}
	{
		std::vector<std::vector<char>> sudokuBoard;
		char sudoku0[] = { '5', '3', '.', '.', '7', '.', '.', '.', '.' };
		char sudoku1[] = { '6', '.', '.', '1', '9', '5', '.', '.', '.' };
		char sudoku2[] = { '.', '9', '8', '.', '.', '.', '.', '6', '.' };
		char sudoku3[] = { '8', '.', '.', '.', '6', '.', '.', '.', '3' };
		char sudoku4[] = { '4', '.', '.', '8', '.', '3', '.', '.', '1' };
		char sudoku5[] = { '7', '.', '.', '.', '2', '.', '.', '.', '6' };
		char sudoku6[] = { '.', '6', '.', '.', '.', '.', '2', '8', '.' };
		char sudoku7[] = { '.', '.', '.', '4', '1', '9', '.', '.', '5' };
		char sudoku8[] = { '.', '.', '.', '.', '8', '.', '.', '7', '9' };
		sudokuBoard.push_back(std::vector<char>(sudoku0, sudoku0 + sizeof(sudoku0) / sizeof(char)));
		sudokuBoard.push_back(std::vector<char>(sudoku1, sudoku1 + sizeof(sudoku1) / sizeof(char)));
		sudokuBoard.push_back(std::vector<char>(sudoku2, sudoku2 + sizeof(sudoku2) / sizeof(char)));
		sudokuBoard.push_back(std::vector<char>(sudoku3, sudoku3 + sizeof(sudoku3) / sizeof(char)));
		sudokuBoard.push_back(std::vector<char>(sudoku4, sudoku4 + sizeof(sudoku4) / sizeof(char)));
		sudokuBoard.push_back(std::vector<char>(sudoku5, sudoku5 + sizeof(sudoku5) / sizeof(char)));
		sudokuBoard.push_back(std::vector<char>(sudoku6, sudoku6 + sizeof(sudoku6) / sizeof(char)));
		sudokuBoard.push_back(std::vector<char>(sudoku7, sudoku7 + sizeof(sudoku7) / sizeof(char)));
		sudokuBoard.push_back(std::vector<char>(sudoku8, sudoku8 + sizeof(sudoku8) / sizeof(char)));
		ValidSudoku().GO(sudokuBoard);
		SudokuSolver().Solve(sudokuBoard);
		SudokuSolver().BacktrackRecur(std::vector<std::vector<char>>(
		{
			{ '5', '3', '.', '.', '7', '.', '.', '.', '.' },
			{ '6', '.', '.', '1', '9', '5', '.', '.', '.' },
			{ '.', '9', '8', '.', '.', '.', '.', '6', '.' },
			{ '8', '.', '.', '.', '6', '.', '.', '.', '3' },
			{ '4', '.', '.', '8', '.', '3', '.', '.', '1' },
			{ '7', '.', '.', '.', '2', '.', '.', '.', '6' },
			{ '.', '6', '.', '.', '.', '.', '2', '8', '.' },
			{ '.', '.', '.', '4', '1', '9', '.', '.', '5' },
			{ '.', '.', '.', '.', '8', '.', '.', '7', '9' }
		}));
	}
	{
		std::vector<std::vector<int>> rotateImageGrid(
		{
			{ 11, 12, 13, 14, 15 },
			{ 21, 22, 23, 24, 25 },
			{ 31, 32, 33, 34, 35 },
			{ 41, 42, 43, 44, 45 },
			{ 51, 52, 53, 54, 55 }
		});
		RotateImage().Clockwise_Iterate(rotateImageGrid);

		Debug::Print2D<int>()(rotateImageGrid, false);
		RotateImage ri(rotateImageGrid);
		std::vector<int> res;
		for (int i = 0; i < 5; ++i)
			for (int j = 0; j < 5; ++j)
				res.push_back(ri.Read(i, j));
		std::cout << "Read the above matrix rotated 90: " << Debug::ToStr1D<int>()(res) << std::endl;

		RotateImage().Clockwise_Iterate(std::vector<std::vector<int>>(
		{
			{ 11, 12, 13, 14, 15, 16 },
			{ 21, 22, 23, 24, 25, 26 },
			{ 31, 32, 33, 34, 35, 36 },
			{ 41, 42, 43, 44, 45, 46 },
			{ 51, 52, 53, 54, 55, 56 },
			{ 61, 62, 63, 64, 65, 66 },
		}));
		RotateImage().Clockwise_Iterate(std::vector<std::vector<int>>(
		{
			{ 11, 12, 13, 14, 15, 16, 17 },
			{ 21, 22, 23, 24, 25, 26, 27 },
			{ 31, 32, 33, 34, 35, 36, 37 },
			{ 41, 42, 43, 44, 45, 46, 47 },
			{ 51, 52, 53, 54, 55, 56, 57 },
			{ 61, 62, 63, 64, 65, 66, 67 },
			{ 71, 72, 73, 74, 75, 76, 77 },
		}));
	}
	{
		std::vector<std::vector<int>> rotateImageGrid(
		{
			{ 11, 12, 13, 14, 15 },
			{ 21, 22, 23, 24, 25 },
			{ 31, 32, 33, 34, 35 },
			{ 41, 42, 43, 44, 45 },
			{ 51, 52, 53, 54, 55 },
			{ 61, 62, 63, 64, 65 },
		});
		RotateMatrix180().Rotate(rotateImageGrid);
		RotateMatrix180().IsSame(std::vector<std::vector<int>>(
		{
			{ 11, 12, 13, 14, 15 },
			{ 21, 22, 23, 24, 25 },
			{ 31, 32, 33, 32, 31 },
			{ 25, 24, 23, 22, 21 },
			{ 15, 14, 13, 12, 11 },
		}));
	}
	{
		std::vector<std::vector<int>> spiralMatrixGrid(
		{
			{ 11, 12, 13, 14, 15 },
			{ 21, 22, 23, 24, 25 },
			{ 31, 32, 33, 34, 35 },
			{ 41, 42, 43, 44, 45 }
		});
		SpiralMatrix().Iterate(spiralMatrixGrid);
		SpiralMatrix().Recur(spiralMatrixGrid);
		std::vector<std::vector<int>> spiralMatrixGrid2(
		{
			{ 11, 12, 13, 14 },
			{ 21, 22, 23, 24 },
			{ 31, 32, 33, 34 },
			{ 41, 42, 43, 44 },
			{ 51, 52, 53, 54 }
		});
		SpiralMatrix().Iterate(spiralMatrixGrid2);
		SpiralMatrix().Recur(spiralMatrixGrid2);

		SpiralMatrix().Generate(5);

		SpiralMatrix().Clockwise_RDLU_Path(1,4,0,0);
	}
	{
		PascalTriangle().Generate(6);
		PascalTriangle().Generate2(6);
		PascalTriangle().GetRow(6);

		FillPyramidGlasses().GetVolume(4, 4, 5.0f);
		FillPyramidGlasses().GetVolume(5, 5, 32.0f);
	}
	{
        for (int i = 1; i < 7; ++i) {
            NQueens().Solve1(i);
            NQueens().Solve2(i);
            NQueens().TotalQueens1(i);
            NQueens().TotalQueens2(i);
        }
	}
	{
		IterateMatrixDiagonal().Solve_NxN(std::vector<std::vector<int>>(
		{
			{ 11, 12, 13, 14 },
			{ 21, 22, 23, 24 },
			{ 31, 32, 33, 34 },
			{ 41, 42, 43, 44 }
		}));
		IterateMatrixDiagonal().Solve_NxM(std::vector<std::vector<int>>(
		{
			{ 11, 12, 13, 14, 15 },
			{ 21, 22, 23, 24, 25 },
			{ 31, 32, 33, 34, 35 },
			{ 41, 42, 43, 44, 45 }
		}));
		IterateMatrixDiagonal().Solve_NxM(std::vector<std::vector<int>>(
		{
			{ 11, 12, 13, 14, 15, 16 },
			{ 21, 22, 23, 24, 25, 26 }
		}));
		IterateMatrixDiagonal().Solve_NxM(std::vector<std::vector<int>>(
		{
			{ 11, 12, 13, 14, 15, 16 }
		}));
		IterateMatrixDiagonal().Solve_NxM(std::vector<std::vector<int>>(
		{
			{ 11, 12 },
			{ 21, 22 },
			{ 31, 32 },
			{ 41, 42 },
			{ 51, 52 },
			{ 61, 62 }
		}));
		IterateMatrixDiagonal().Solve_NxM(std::vector<std::vector<int>>(
		{
			{ 11 },
			{ 21 },
			{ 31 },
			{ 41 },
			{ 51 },
			{ 61 }
		}));

		IterateMatrixDiagonal().ReverseDiag_NxM(std::vector<std::vector<int>>(
		{
			{ 11, 12, 13, 14, 15 },
			{ 21, 22, 23, 24, 25 },
			{ 31, 32, 33, 34, 35 },
			{ 41, 42, 43, 44, 45 }
		}));
		IterateMatrixDiagonal().ReverseDiag_NxM(std::vector<std::vector<int>>(
		{
			{ 11, 12, 13, 14, 15, 16 },
			{ 21, 22, 23, 24, 25, 26 }
		}));
		IterateMatrixDiagonal().ReverseDiag_NxM(std::vector<std::vector<int>>(
		{
			{ 11, 12, 13, 14, 15, 16 }
		}));
		IterateMatrixDiagonal().ReverseDiag_NxM(std::vector<std::vector<int>>(
		{
			{ 11, 12 },
			{ 21, 22 },
			{ 31, 32 },
			{ 41, 42 },
			{ 51, 52 },
			{ 61, 62 }
		}));
		IterateMatrixDiagonal().ReverseDiag_NxM(std::vector<std::vector<int>>(
		{
			{ 11 },
			{ 21 },
			{ 31 },
			{ 41 },
			{ 51 },
			{ 61 }
		}));
	}
	{
		AllDistinctSubAreasInMatrix().FindAll_DFS(std::vector<std::vector<int>>(
		{
			{ 0, 0, 1, 1, 0, 0, 0, 0, 0, 0 },
			{ 0, 1, 1, 1, 1, 0, 1, 1, 1, 0 },
			{ 0, 1, 0, 0, 1, 0, 1, 0, 0, 0 },
			{ 0, 1, 0, 1, 1, 0, 1, 1, 1, 1 },
			{ 0, 1, 1, 1, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 1, 1, 0, 0, 1, 0 },
			{ 0, 0, 0, 0, 0, 1, 1, 1, 1, 0 }
		}));
		AllDistinctSubAreasInMatrix().FindAll_BFS(std::vector<std::vector<int>>(
		{
			{ 0, 0, 1, 1, 0, 0, 0, 0, 0, 0 },
			{ 0, 1, 1, 1, 1, 0, 1, 1, 1, 0 },
			{ 0, 1, 0, 0, 1, 0, 1, 0, 0, 0 },
			{ 0, 1, 0, 1, 1, 0, 1, 1, 1, 1 },
			{ 0, 1, 1, 1, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 1, 1, 0, 0, 1, 0 },
			{ 0, 0, 0, 0, 0, 1, 1, 1, 1, 0 }
		}));
	}
	{
		NumberOfIslandsInMatrix().Count_DFS(std::vector<std::vector<char>>(
		{
			{ '1', '1', '1', '1', '0' },
			{ '1', '1', '0', '1', '0' },
			{ '1', '1', '0', '0', '0' },
			{ '0', '0', '0', '0', '0' },
		}));
		NumberOfIslandsInMatrix().Count_DFS(std::vector<std::vector<char>>(
		{
			{ '1', '1', '0', '0', '0' },
			{ '1', '1', '0', '0', '0' },
			{ '0', '0', '1', '0', '0' },
			{ '0', '0', '0', '1', '1' },
		}));

		NumberOfIslandsInMatrixII().GetCount_ConvertTo1DUnionFind(3, 3, std::vector<std::pair<int, int>>({ { 0,0 },{ 0,1 },{ 1,2 },{ 2,1 } }));

		NumberOfDistinctIslandsInMatrix().Count_DFSHashMap(std::vector<std::vector<int>>(
		{
			{ 1,1,0,1,1 },
			{ 1,0,0,0,0 },
			{ 0,0,0,0,1 },
			{ 1,1,0,1,1 },
		}));
		NumberOfDistinctIslandsInMatrix().Count_DFSHashMap(std::vector<std::vector<int>>(
		{
			{ 1, 1, 0, 0, 0, 0, 0, },
			{ 0, 1, 1, 1, 0, 0, 0, },
			{ 0, 0, 1, 0, 0, 0, 0, },
			{ 0, 0, 0, 0, 0, 0, 0, },
			{ 0, 1, 1, 0, 0, 0, 0, },
			{ 0, 0, 1, 1, 1, 0, 0, },
			{ 0, 0, 0, 1, 0, 0, 0, },
		}));
	}
	{
		ProbToStepInsideMatrix().SolveDFS(5, 3, 2, 2);
	}
	{
		AllShortestPathsInMatrix().BFS(std::vector<std::vector<char>>(
		{
			{ '.', '.', '.', '.', '.', '.', '.' },
			{ '.', '.', '.', '.', '.', 'S', '.' },
			{ '.', '.', '.', '.', '.', '.', '.' },
			{ '.', '.', 'S', '.', '.', '.', '.' },
			{ '.', '.', '.', '.', '.', '.', '.' },
			{ '.', '.', '.', '.', '.', '.', '.' },
		}));
		AllShortestPathsInMatrix().BFS(std::vector<std::vector<char>>(
		{
			{ '#', 'S', '#', '#', '#', '#', '#', '#', '.', '#' },
			{ '.', '.', '.', '.', '.', '.', '#', '.', '.', '#' },
			{ '.', '#', '.', '#', '#', '.', '#', '#', '.', '#' },
			{ '.', '#', '.', '.', '.', '.', '.', '.', '.', '.' },
			{ '#', '#', '.', '#', '#', '.', '#', '#', '#', '#' },
			{ '.', '.', '.', '.', '#', '.', '.', '.', '.', '#' },
			{ '.', '#', '#', '#', '#', '#', '#', '#', '.', '#' },
			{ '.', '.', '.', '.', '#', '.', '.', '.', '.', '.' },
			{ '.', '#', '#', '#', '#', '.', '#', '#', '#', '.' },
			{ '.', '.', '.', '.', '#', '.', '.', '.', '.', '#' },
		}));
	}
	{
		SearchAMaze().DFSRecur(std::vector<std::vector<char>>(
		{
			{ '#', '.', '#', '#', '#', '#', '#', '#', '.', '#' },
			{ '.', '.', '.', '.', '.', '.', '#', '.', '.', '#' },
			{ '.', '#', '.', '#', '#', '.', '#', '#', '.', '#' },
			{ '.', '#', '.', '.', '.', '.', '.', '.', '.', '.' },
			{ '#', '#', '.', '#', '#', '.', '#', '#', '#', '#' },
			{ '.', '.', '.', '.', '#', '.', '.', '.', '.', '#' },
			{ '.', '#', '#', '#', '#', '#', '#', '#', '.', '#' },
			{ '.', '.', '.', '.', '#', '.', '.', '.', '.', '.' },
			{ '.', '#', '#', '#', '#', '.', '#', '#', '#', '.' },
			{ '.', '.', '.', '.', '#', '.', '.', '.', '.', '#' },
		}), { 0, 1 }, { 9, 8 });
	}
	{
		/*	x
		y		  0  1  2  3  4  5  6  7  8  9
			0	{ 0, 1, 0, 0, 1, 0, 0, 1, 0, 0 },
			1	{ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
			2	{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 1 },
			3	{ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
			4	{ 0, 0, 1, 0, 0, 1, 0, 0, 0, 1 },
			5	{ 0, 0, 0, 1, 1, 0, 0, 0, 0, 0 },
			6	{ 0, 1, 0, 0, 0, 0, 0, 1, 0, 0 },
			7	{ 0, 0, 0, 0, 0, 0, 1, 1, 0, 0 },
		*/
		MaxPointsOnALine().Count_HashMap(std::vector<MaxPointsOnALine::Point>(
		{
			MaxPointsOnALine::Point(0, 1), MaxPointsOnALine::Point(0, 4), MaxPointsOnALine::Point(0, 7),
			MaxPointsOnALine::Point(1, 5),
			MaxPointsOnALine::Point(2, 3), MaxPointsOnALine::Point(2, 9),
			MaxPointsOnALine::Point(3, 7),
			MaxPointsOnALine::Point(4, 2), MaxPointsOnALine::Point(4, 5), MaxPointsOnALine::Point(4, 9),
			MaxPointsOnALine::Point(5, 3), MaxPointsOnALine::Point(5, 4),
			MaxPointsOnALine::Point(6, 1), MaxPointsOnALine::Point(6, 7),
			MaxPointsOnALine::Point(7, 6), MaxPointsOnALine::Point(7, 7)
		}));
		MaxPointsOnALine().FindLine_HashMap(std::vector<MaxPointsOnALine::Point>(
		{
			MaxPointsOnALine::Point(0, 1), MaxPointsOnALine::Point(0, 4), MaxPointsOnALine::Point(0, 7),
			MaxPointsOnALine::Point(1, 5),
			MaxPointsOnALine::Point(2, 3), MaxPointsOnALine::Point(2, 9),
			MaxPointsOnALine::Point(3, 7),
			MaxPointsOnALine::Point(4, 2), MaxPointsOnALine::Point(4, 5), MaxPointsOnALine::Point(4, 9),
			MaxPointsOnALine::Point(5, 3), MaxPointsOnALine::Point(5, 4),
			MaxPointsOnALine::Point(6, 1), MaxPointsOnALine::Point(6, 7),
			MaxPointsOnALine::Point(7, 6), MaxPointsOnALine::Point(7, 7)
		}));
	}
	{
		TwoClosestPoints().DivideConquerRecur(std::vector<std::pair<int, int>>(
		{
			{ 2, 3 }, { 12, 30 }, { 40, 50 }, { 5, 1 }, { 12, 10 }, { 3, 4 }
		}));
	}
	{
		TicTacToeGame t(3);
		t.move(0, 0, 1);
		t.move(0, 2, 2);
		t.move(2, 2, 1);
		t.move(1, 1, 2);
		t.move(2, 0, 1);
		t.move(1, 0, 2);
		t.move(2, 1, 1);

		TicTacToeGame().Board3x3_HashTable(std::vector<std::vector<char>>(
		{
			{ 'O', 'O', 'X' },
			{ 'O', 'X', 'X' },
			{ 'X', '.', 'O' },
		}));
		TicTacToeGame().Board3x3(std::vector<std::vector<char>>(
		{
			{ 'O', 'O', 'X' },
			{ 'O', 'X', 'X' },
			{ 'X', '.', 'O' },
		}));
		TicTacToeGame().BoardNxN(std::vector<std::vector<char>>(
		{
			{ 'O', 'O', 'X' },
			{ 'O', 'X', 'X' },
			{ 'X', '.', 'O' },
		}));
	}
	{
		MaxSubMatrixSum().BruteForce(std::vector<std::vector<int>>(
		{
			{ 1, 2, -1, -4, -20 },
			{ -8, -3, 4, 2, 1 },
			{ 3, 8, 10, 1, 3 },
			{ -4, -1, 1, 7, -6 }
		}));
		MaxSubMatrixSum().UseKandane(std::vector<std::vector<int>>(
		{
			{ 1, 2, -1, -4, -20 },
			{ -8, -3, 4, 2, 1 },
			{ 3, 8, 10, 1, 3 },
			{ -4, -1, 1, 7, -6 }
		}));
	}
	{
		PaintAllSameColorPixels().DFSRecur(std::vector<std::vector<int>>(
		{
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
			{ 0, 0, 0, 1, 1, 1, 1, 0, 0, 0 },
			{ 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 },
			{ 1, 0, 1, 1, 1, 1, 1, 1, 0, 0 },
			{ 1, 0, 1, 1, 1, 1, 1, 1, 0, 0 },
			{ 0, 0, 1, 1, 0, 0, 1, 0, 0, 0 },
			{ 0, 0, 1, 0, 0, 0, 1, 1, 0, 0 },
			{ 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 },
		}), 4, 4, 7);
		PaintAllSameColorPixels().BFSIterate(std::vector<std::vector<int>>(
		{
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
			{ 0, 0, 0, 1, 1, 1, 1, 0, 0, 0 },
			{ 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 },
			{ 1, 0, 1, 1, 1, 1, 1, 1, 0, 0 },
			{ 1, 0, 1, 1, 1, 1, 1, 1, 0, 0 },
			{ 0, 0, 1, 1, 0, 0, 1, 0, 0, 0 },
			{ 0, 0, 1, 0, 0, 0, 1, 1, 0, 0 },
			{ 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 },
		}), 4, 4, 7);
	}
	{
		LongestIncrAdjConsecuNumSeqInMatrix().DFS_DP2D(std::vector<std::vector<int>>(
		{
			{ 20, 13, 12, 11, 10 },
			{ 21, 14,  6,  5,  4 },
			{ 22, 15,  7, 16,  3 },
			{ 23,  9,  8, 17,  2 },
			{ 24, 25, 19, 18,  1 },
		}));
	}
	{
		KeyPressSeqInMatrix().Solve(std::string("size"));
		KeyPressSeqInMatrix().Solve(std::string("zdzoz"));
	}
	{
		KeyPressCombinationsInMatrix().DFS_Recur(std::vector<std::vector<char>>(
		{
			{ '1', '2', '3' },
			{ '4', '5', '6' },
			{ '7', '8', '9' },
			{ '*', '0', '#' },
		}), 3);
		KeyPressCombinationsInMatrix().DP3D(std::vector<std::vector<char>>(
		{
			{ '1', '2', '3' },
			{ '4', '5', '6' },
			{ '7', '8', '9' },
			{ '*', '0', '#' },
		}), 3);
	}
	{
		TileChessboardWDominos().Count_Recur(std::vector<std::vector<int>>(
		{
			{0, 0, 0},
			{0, 1, 0},
			{0, 0, 0}
		}));
		TileChessboardWDominos().Count_Recur(std::vector<std::vector<int>>(
		{
			{ 0, 0, 0, 0 },
			{ 0, 0, 0, 0 },
			{ 0, 0, 0, 0 },
			{ 0, 0, 0, 0 },
		}));
		TileChessboardWDominos().Count_Recur(std::vector<std::vector<int>>(
		{
			{ 0, 0 },
			{ 0, 0 },
			{ 0, 0 },
			{ 0, 0 },
		}));
		TileChessboardWDominos().Count_Recur(std::vector<std::vector<int>>(
		{
			{0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0},
		}));
		TileChessboardWDominos().FibonacciRecur_2xn(4);
		TileChessboardWDominos().FibonacciRecur_2xn(7);
		TileChessboardWDominos().ClimbStairRecur_2xn(4);
		TileChessboardWDominos().ClimbStairRecur_2xn(7);
	}
	{
		AllSubSquareSumsInMatrix().FindAll_Preprocess(std::vector<std::vector<int>>(
		{
			{ 1, 1, 1, 1, 1 },
			{ 2, 2, 2, 2, 2 },
			{ 3, 3, 3, 3, 3 },
			{ 4, 4, 4, 4, 4 },
			{ 5, 5, 5, 5, 5 },
		}), 3);
	}
	{
		IntersectRectangle().UnionArea(-3, 0, 3, 4, 0, -1, 9, 2);
		IntersectRectangle().Find(1, 4, 8, 16, 5, 1, 16, 8);
	}
	{
		DungeonGame().DP2D(std::vector<std::vector<int>>(
		{
			{-2, -3, 3},
			{-5, -10, 1},
			{10, 30, -5},
		}));
	}
	{
		MaxSubMatrixSumNoGreaterThanK().TwoD_BruteForcePrefixSums(std::vector<std::vector<int>>(
		{
			{ 1, 0, 1 },
			{ 0, -2, 3 }
		}), 2);
		MaxSubMatrixSumNoGreaterThanK().TwoD_SortedPrefixSums(std::vector<std::vector<int>>(
		{
			{ 1, 0, 1 },
			{ 0, -2, 3 }
		}), 2);
	}
	{
		std::vector<std::vector<int>> v(
		{
			{ 1, 2 },
			{ },
			{ },
			{ 3 },
			{ 4, 5, 6 },
			{ }
		});
		Flatten2DVector f(v);
		while (f.hasNext())
			f.next();
	}
	{

	}
	{
		std::vector<std::vector<int>> life(
		{
			{ 1,0,0,0,1,0,0,0 },
			{ 0,0,0,1,0,0,1,1 },
			{ 0,0,1,0,1,0,1,0 },
			{ 0,0,0,1,0,0,0,0 },
			{ 1,0,0,0,1,0,0,1 },
			{ 0,1,1,0,0,0,0,1 },
			{ 0,0,1,1,0,0,1,0 },
		});
		GameOfLife().UseExtraSpace(life);
		std::vector<std::vector<int>> life2(
		{
			{ 1,0,0,0,1,0,0,0 },
			{ 0,0,0,1,0,0,1,1 },
			{ 0,0,1,0,1,0,1,0 },
			{ 0,0,0,1,0,0,0,0 },
			{ 1,0,0,0,1,0,0,1 },
			{ 0,1,1,0,0,0,0,1 },
			{ 0,0,1,1,0,0,1,0 },
		});
		GameOfLife().InPlace(life2);
	}
	{
		std::vector<std::vector<int>> board(
		{
			{ 0,0,1,0 },
			{ 0,1,1,0 },
			{ 0,1,0,0 },
		});
		SmallestRectEnclosingBlackPixels().BruteForce(board, 0, 2);
		SmallestRectEnclosingBlackPixels().DFS(board, 0, 2);
		SmallestRectEnclosingBlackPixels().BinarySearch(board, 0, 2);

		std::vector<std::vector<int>> board2(
		{
			{ 0,0,0,0,0,0,0,0 },
			{ 0,0,1,1,1,1,1,0 },
			{ 1,1,1,0,0,0,1,0 },
			{ 0,0,1,0,1,0,1,0 },
			{ 0,1,1,1,1,0,1,0 },
			{ 0,1,0,1,1,0,0,0 },
			{ 0,1,0,0,1,1,0,0 },
			{ 0,1,0,0,0,1,0,0 },
			{ 0,0,0,0,0,0,0,0 },
		});
		SmallestRectEnclosingBlackPixels().BruteForce(board2, 2, 2);
		SmallestRectEnclosingBlackPixels().DFS(board2, 2, 2);
		SmallestRectEnclosingBlackPixels().BinarySearch(board2, 2, 2);
	}
	{
		BestMeetingPoint().MinTotalDist(std::vector<std::vector<int>>(
		{
			{ 1,0,0,0,1 },
			{ 0,0,0,0,0 },
			{ 0,0,1,0,0 },
		}));

		BestMeetingPoint().MinTotalDist(std::vector<std::vector<int>>(
		{
			{ 1,0,0,0,0,1,1 },
			{ 0,0,0,1,0,0,0 },
			{ 0,0,0,0,0,0,1 },
			{ 0,1,1,0,0,0,0 },
			{ 0,0,0,0,0,1,0 },
			{ 0,1,0,0,1,0,0 },
		}));
	}
	{
		std::vector<std::vector<int>> A1(
		{
			{ 1,0,0 },
			{ -1,0,3 },
		});
		std::vector<std::vector<int>> B1(
		{
			{ 7,0,0 },
			{ 0,0,0 },
			{ 0,0,1 },
		});
		SparseMatrixMultiplication().Normal(A1, B1);
		SparseMatrixMultiplication().Naive(A1, B1);
		SparseMatrixMultiplication().SaveBinHashMap(A1, B1);

        SparseMatrixMultiplication().SparseArrayDotProduct_HashMap(std::vector<int>({ 1,2,0,0,5,0,0,0,4,0,0,3 }), std::vector<int>({ 1,0,0,2,0,0,0,0,4,0,2,3 }));
		SparseMatrixMultiplication().SparseArrayDotProduct_ModifiedMergeTwoSortedArrays(std::vector<int>({ 1,2,0,0,5,0,0,0,4,0,0,3 }), std::vector<int>({ 1,0,0,2,0,0,0,0,4,0,2,3 }));
	}
	{
		ShortestDistFromAllBuildings().BFS(std::vector<std::vector<int>>(
		{
			{ 1,0,2,0,1 },
			{ 0,0,0,0,0 },
			{ 0,0,1,0,0 },
		}));
		ShortestDistFromAllBuildings().BFS(std::vector<std::vector<int>>(
		{
			{ 2,1,2,2,1,0,1 },
			{ 1,0,2,0,0,0,1 },
			{ 1,0,2,0,2,0,1 },
			{ 2,0,1,0,2,1,2 },
			{ 2,0,0,0,2,2,0 },
			{ 2,2,1,0,0,0,1 },
		}));
	}
	{
		SelfCrossing().check(std::vector<int>({ 1,5,5,3,6 }));
		SelfCrossing().check(std::vector<int>({ 1,2,3,4,6,2,3 }));
		SelfCrossing().check(std::vector<int>({ 1,3,4,3,3 }));
	}
	{
		DesignSnakeGame g(3, 2, std::vector<std::pair<int, int>>({ { 1,2 },{ 0,1 } }));
		g.move("R");
		g.move("D");
		g.move("R");
		g.move("U");
		g.move("L");
		g.move("L");
		g.move("D");
		g.move("D");
	}
	{
		AndroidUnlockPatterns().CountNumPatterns(1, 1);
		AndroidUnlockPatterns().CountNumPatterns(2, 2);
		AndroidUnlockPatterns().CountNumPatterns(2, 3);
		AndroidUnlockPatterns().CountNumPatterns(3, 3);
		AndroidUnlockPatterns().CountNumPatterns(4, 4);
		AndroidUnlockPatterns().CountNumPatterns(3, 4);
	}
	{
		LineReflection().isReflected(std::vector<std::pair<int, int>>({ { 1,1 },{ -1,1 } }));
		LineReflection().isReflected(std::vector<std::pair<int, int>>({ { 1,1 },{ -1,-1 } }));
	}
	{
		BombEnemy().MaxKilledEnemies(std::vector<std::vector<char>>(
		{
			{ '0','E','0','0' },
			{ 'E','0','W','E' },
			{ '0','E','0','0' },
		}));
		BombEnemy().MaxKilledEnemies(std::vector<std::vector<char>>(
		{
			{ '0','E','W','E','E','E','0','E' },
			{ 'E','0','0','0','E','W','E','0' },
			{ '0','E','W','E','0','E','0','E' },
			{ 'W','0','E','0','E','0','W','W' },
			{ 'E','E','E','W','W','W','E','E' },
			{ 'E','E','E','0','E','0','E','0' },
			{ 'E','0','W','E','E','0','0','E' },
		}));
	}
	{
		NonStoppingMaze().HasPath_BFS(std::vector<std::vector<int>>(
		{
			{ 0, 0, 1, 0, 0 },
			{ 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 1, 0 },
			{ 1, 1, 0, 1, 1 },
			{ 0, 0, 0, 0, 0 }
		}), std::vector<int>({ 0,4 }), std::vector<int>({ 4,4 }));
		NonStoppingMaze().ShortestDist_BFS(std::vector<std::vector<int>>(
		{
			{ 0, 0, 1, 0, 0 },
			{ 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 1, 0 },
			{ 1, 1, 0, 1, 1 },
			{ 0, 0, 0, 0, 0 }
		}), std::vector<int>({ 0,4 }), std::vector<int>({ 4,4 }));
		NonStoppingMaze().ShortestWayToHole_BFS(std::vector<std::vector<int>>(
		{
			{ 0, 0, 0, 0, 0 },
			{ 1, 1, 0, 0, 1 },
			{ 0, 0, 0, 0, 0 },
			{ 0, 1, 0, 0, 1 },
			{ 0, 1, 0, 0, 0 }
		}), std::vector<int>({ 4,3 }), std::vector<int>({ 0,1 }));
	}
    {
        MinStepsInMaze().BFS_MinHeap(std::vector<std::vector<int>>(
                {
                        { 0, 0, 1, 0, 0, 0 },
                        { 1, 0, 1, 0, 1, 0 },
                        { 0, 0, 0, 1, 0, 0 },
                        { 0, 1, 1, 0, 0, 0 },
                        { 0, 0, 1, 0, 1, 0 },
                        { 0, 0, 0, 0, 1, 0 },
                }), std::vector<int>({ 0,0 }), std::vector<int>({ 5,5 }));
        MinStepsInMaze().BFS_Queue(std::vector<std::vector<int>>(
                {
                        { 0, 0, 1, 0, 0, 0 },
                        { 1, 0, 1, 0, 1, 0 },
                        { 0, 0, 0, 1, 0, 0 },
                        { 0, 1, 1, 0, 0, 0 },
                        { 0, 0, 1, 0, 1, 0 },
                        { 0, 0, 0, 0, 1, 0 },
                }), std::vector<int>({ 0,0 }), std::vector<int>({ 5,5 }));

        
        MinStepsInMazeLeftToRight().BFS_Queue(std::vector<std::vector<int>>(
                {
                        { 0, 1, 1, 0, 1, 1 },
                        { 1, 1, 0, 0, 0, 0 },
                        { 1, 0, 0, 1, 1, 0 },
                        { 0, 1, 0, 0, 0, 1 },
                        { 0, 0, 1, 0, 1, 0 },
                        { 0, 0, 0, 0, 0, 1 },
                }));
    }
	{
		LonelyPixel().CountLonelyB(std::vector<std::vector<char>>(
		{
			{ 'W', 'W', 'B' },
			{ 'W', 'B', 'W' },
			{ 'B', 'W', 'W' }
		}));
		LonelyPixel().CountLonelyB(std::vector<std::vector<char>>(
		{
			{ 'W', 'B', 'W', 'B', 'B', 'W' },
			{ 'W', 'B', 'W', 'B', 'B', 'W' },
			{ 'W', 'B', 'W', 'B', 'B', 'W' },
			{ 'W', 'W', 'B', 'W', 'B', 'W' }
		}), 3);
	}
	{
		BattleshipsInABoard().CountUpperLeftCorners(std::vector<std::vector<char>>(
		{
			{ 'X','.','.' ,'X' },
			{ '.','.','.' ,'X' },
			{ '.','.','.' ,'X' },
		}));
	}
	{
		IslandPerimeter().Count(std::vector<std::vector<int>>(
		{
			{ 0,1,0,0 },
			{ 1,1,1,0 },
			{ 0,1,0,0 },
			{ 1,1,0,0 }
		}));
	}
	{
		PerfectRectangle().IsRectangleCover(std::vector<std::vector<int>>(
		{
			{ 1,1,3,3 },
			{ 3,1,4,2 },
			{ 3,2,4,4 },
			{ 1,3,2,4 },
			{ 2,3,3,4 }
		}));
	}
	{
		Minesweeper().UpdateBoard(std::vector<std::vector<char>>(
		{
			{ 'E', 'E', 'E', 'E', 'E' },
			{ 'E', 'E', 'M', 'E', 'E' },
			{ 'E', 'E', 'E', 'E', 'E' },
			{ 'E', 'E', 'E', 'E', 'E' }
		}), std::vector<int>({ 3,0 }));
	}
	{
		PacificAtlanticWaterFlow().Recur(std::vector<std::vector<int>>(
		{
			{ 1,2,2,3,5 },
			{ 3,2,3,4,4 },
			{ 2,4,5,3,1 },
			{ 6,7,1,4,5 },
			{ 5,1,1,2,4 },
		}));
	}
	{
		WordSquare().Valid(std::vector<std::string>(
		{ "abcd",
		  "bnrt",
		  "crm",
		  "dt" }));
		WordSquare().Valid(std::vector<std::string>(
		{ "abcd",
		  "befd",
		  "cf",
		  "dda" }));

		WordSquare().FindAllCombinationPermutation_AllowRepeat(std::vector<std::string>(
		{
			"area",
			"lead",
			"wall",
			"lady",
			"ball"
		}));
		WordSquare().FindAllCombinationPermutation_AllowRepeat_Trie(std::vector<std::string>(
		{
			"area",
			"lead",
			"wall",
			"lady",
			"ball"
		}));

		WordSquare().FindAllCombinationPermutation_AllowRepeat(std::vector<std::string>(
		{
			"abat",
			"baba",
			"atan",
			"atal"
		}));
		WordSquare().FindAllCombinationPermutation_AllowRepeat_Trie(std::vector<std::string>(
		{
			"abat",
			"baba",
			"atan",
			"atal"
		}));
	}
	{
		MinDistTo0In01Matrix().BFS(std::vector<std::vector<int>>(
		{
			{ 0, 0, 0 },
			{ 0, 1, 0 },
			{ 1, 1, 1 },
		}));
		MinDistTo0In01Matrix().DP(std::vector<std::vector<int>>(
		{
			{ 0, 0, 0 },
			{ 0, 1, 0 },
			{ 1, 1, 1 },
		}));
	}
	{
		BrickWall().HashMap(std::vector<std::vector<int>>(
		{
			{ 1,2,2,1 },
			{ 3,1,2 },
			{ 1,3,2 },
			{ 2,4 },
			{ 3,1,2 },
			{ 1,3,1,1 }
		}));
	}
	{
		NumOfBoomerangs().HashMap(std::vector<std::pair<int, int>>({ { 0,0 },{ 1,0 },{ 2,0 } }));
	}
	{
		MostSquareDimensionXY().Test();
	}
    {
        for (int i = 1; i <= 8; ++i)
        {
            CountSquaresIn2DGrid().BruteForce(i);
            CountSquaresIn2DGrid().LinearTime(i);
            CountSquaresIn2DGrid().Formula_SumOfSquares(i);
        }
    }
    {
        ReshapeMatrix().Reshape(std::vector<std::vector<int>>(
                {
                        {11,12},
                        {21,22},
                        {31,32},
                }), 2, 3);
        ReshapeMatrix().Transpose(std::vector<std::vector<int>>(
                {
                        {11,12},
                        {21,22},
                        {31,32},
                }));
    }
    {
        MinPathCutTreeIncrOrder().UseBFS(std::vector<std::vector<int>>(
                {
                        {54581641,64080174,24346381,69107959},
                        {86374198,61363882,68783324,79706116},
                        {668150,92178815,89819108,94701471},
                        {83920491,22724204,46281641,47531096},
                        {89078499,18904913,25462145,60813308}
                }));
    }
    {
        LargestPlusSignIn2DGrid().BruteForce(5, std::vector<std::vector<int>>({{4,2}}));
        LargestPlusSignIn2DGrid().DP2D(5, std::vector<std::vector<int>>({{4,2}}));
    }
    {
        CountCornerRectanglesIn2DGrid().BruteForce(std::vector<std::vector<int>>(
                {
                        {1,0,0,1,0},
                        {0,0,1,0,1},
                        {0,0,0,1,0},
                        {1,0,1,0,1},
                }));
        CountCornerRectanglesIn2DGrid().Better(std::vector<std::vector<int>>(
                {
                        {1,0,0,1,0},
                        {0,0,1,0,1},
                        {0,0,0,1,0},
                        {1,0,1,0,1},
                }));
    }
    {
        for (int move = 1; move < 6; ++move)
        {
            LMoveIdxSeqCombinationInMatrix().DP(move);
            LMoveIdxSeqCombinationInMatrix().Recur(move);
        }

        KnightDialer().DP(1);
        KnightDialer().DP(2);
        KnightDialer().Recur(1);
        KnightDialer().Recur(2);
    }
    {
        FindMinCol1In01Matrix().LinearSearchFromUpperRightCorner(std::vector<std::vector<int>>(
                {
                        {0,0,1,1,1},
                        {0,1,1,1,1},
                        {0,0,1,1,1},
                        {0,0,0,0,0},
                }));
        FindMinCol1In01Matrix().LinearSearchFromUpperRightCorner(std::vector<std::vector<int>>(
                {
                        {0,0,0,0,1},
                        {0,1,1,1,1},
                        {0,0,1,1,1},
                        {1,1,1,1,1},
                }));
    }
    {
        SquirrelCollectNutsToTree().MinDist(5, 7, {2,2}, {4,4}, {{3,0},{2,5}});
    }
    {
        VerticalPrintWBalancedColumnLen().Solve(std::vector<std::string>({"a","b","c","d","e","f","g","h","i","j"}), 3);
        VerticalPrintWBalancedColumnLen().Solve(std::vector<std::string>({"a","bb","cc","d","e","f","gg","hhh","i","j"}), 3);

        VerticalPrintWBalancedColumnLen().Solve(std::vector<std::string>({"a","b","ccccccc","dd","e","ffffffff","gg","h","i","j"}), 3);
        VerticalPrintWBalancedColumnLen().Solve(std::vector<std::string>({"a","b","ccccccc","dd","e","ffffffff","gg","h","i","j"}), 4);
        VerticalPrintWBalancedColumnLen().Solve(std::vector<std::string>({"a","b","ccccccc","dd","e","ffffffff","gg","h","i","j"}), 5);
    }
    {
        MaxIncrKeepSkyline().Linear(std::vector<std::vector<int>>(
                {
                        {3,0,8,4},
                        {2,4,5,7},
                        {9,2,6,3},
                        {0,3,1,0}
                }));
    }
    {
        FindDuplicateRowsInBinaryMatrix().UseTrie(std::vector<std::vector<int>>(
                {
                        {1,1,0,1,0,1},
                        {0,0,1,0,0,1},
                        {1,0,1,1,0,0},
                        {1,1,0,1,0,1},
                        {0,0,1,0,0,1},
                        {0,0,1,0,0,1},
                }
        ));
    }
    {
        Count1sIn2dMatrixWithHasAPI().Count(std::vector<std::vector<int>>(
                {
                        {1,1,1,0,0,0,1},
                        {1,0,0,1,0,0,1},
                        {0,1,0,0,1,0,0},
                        {0,1,0,0,1,0,1},
                        {0,1,1,0,0,1,0},
                        {1,0,1,1,1,0,0},
                }));
        //for (int i = 0; i < 10; ++i)
        //    Count1sIn2dMatrixWithHasAPI().Count(TestCase::RandMatrix(TestCase::RandNum(1,7), TestCase::RandNum(1,7),0,1));
    }
    {
        for (int i = 9; i < 10; ++i)
            UniquePathInTriangle().DP2D(i);
    }
    {
        LargestIslandAtMost1FlipInMatrix().BruteForceBFS(std::vector<std::vector<int>>(
                {
                        {1,0},
                        {0,1}
                }));
        LargestIslandAtMost1FlipInMatrix().UnionFind(std::vector<std::vector<int>>(
                {
                        {1,0},
                        {0,1}
                }));
    }
    {
        DetermineIfPointLieInsideTriangle().CheckAreaSum(0, 0, 20, 0, 10, 30, 10, 15);
    }
    {
        Find3PointsFormLargestTriangle().BruteForce(std::vector<std::vector<int>>({{0,0},{0,1},{1,0},{0,2},{2,0}}));
    }
    {
        std::vector<std::vector<char>> board(
                {
                        { ' ','X','X','O','O' },
                        { 'X','O','O','X','X' },
                        { 'O','X','O','O','X' },
                        { 'X','X','X','X','O' },
                        { 'X','X','X','O','X' },
                        { ' ','O',' ','X',' ' },
                });
        RemoveSurroundedPiecesInMatrix().BFS(board);
    }
    {
        Find4PointsFormRectangle_MinArea().AxisAligned_xToYsHashMap(std::vector<std::vector<int>>({{1,1},{1,3},{3,1},{3,3},{4,1},{4,3}}));
        Find4PointsFormRectangle_MinArea().AxisAligned_CheckDiagonalPairs(std::vector<std::vector<int>>({{1,1},{1,3},{3,1},{3,3},{4,1},{4,3}}));
        Find4PointsFormRectangle_MinArea().NonAxisAligned_CheckDiagonalPairs(std::vector<std::vector<int>>({{1,2},{2,1},{1,0},{0,1}}));
    }
    {
        ReachingPoints2D().Recur(3,7,64,27);
    }
    {
        //OrthogonalRectangleIntersection().SweepLine(std::vector<std::vector<int>>({{0,2,0,2},{1,2,0,3},{1,3,0,1}}));

        OrthogonalRectangleIntersection2().BruteForce(std::vector<std::vector<int>>({{0,0,2,2},{1,0,2,3},{1,0,3,1}}));
        OrthogonalRectangleIntersection2().SweepLine(std::vector<std::vector<int>>({{0,0,2,2},{1,0,2,3},{1,0,3,1}}));
    }
    {
        MinMovesInSnakeLadderBoard().BFS(std::vector<std::vector<int>>(
                {
                        {-1,-1,-1,-1,-1,-1},
                        {-1,-1,-1,-1,-1,-1},
                        {-1,-1,-1,-1,-1,-1},
                        {-1,35,-1,-1,13,-1},
                        {-1,-1,-1,-1,-1,-1},
                        {-1,15,-1,-1,-1,-1}
                }));
    }
    {
        CandyCrush().Solve(std::vector<std::vector<int>>(
                {
                        {110,5,112,113,114},
                        {210,211,5,213,214},
                        {310,311,3,313,314},
                        {410,411,412,5,414},
                        {5,1,512,3,3},
                        {610,4,1,613,614},
                        {710,1,2,713,714},
                        {810,1,2,1,1},
                        {1,1,2,2,2},
                        {4,1,4,4,1014}
                }));
    }
    {
        CountMagic3x3SquareInGrid().BruteForce(std::vector<std::vector<int>>(
                {
                        {4,3,8,4},
                        {9,5,1,9},
                        {2,7,6,2}
                }));
    }
    {
        PourWater().Solve(std::vector<int>({2,1,1,2,1,2,2}), 4, 3);
    }
    {
        ShortestBridgeBtw2Islands().DFSplusBFS(std::vector<std::vector<int>>(
                {
                        {1,1,1,1,1},
                        {1,0,0,0,1},
                        {1,0,1,0,1},
                        {1,0,0,0,1},
                        {1,1,1,1,1}
                }));
        ShortestBridgeBtw2Islands().DFSplus2DirBFS(std::vector<std::vector<int>>(
                {
                        {1,1,1,1,1},
                        {1,0,0,0,1},
                        {1,0,1,0,1},
                        {1,0,0,0,1},
                        {1,1,1,1,1}
                }));
    }
    {
        RoundTripMaxPickupIn2DMatrix().DP3D(std::vector<std::vector<int>>(
                {
                        {0, 1, -1},
                        {1, 0, -1},
                        {1, 1,  1}
                }));
    }
    {
        MaxStonesRemovedWSameRowOrCol().DFS(std::vector<std::vector<int>>({{0,0},{0,1},{1,0},{1,2},{2,1},{2,2}}));
        MaxStonesRemovedWSameRowOrCol().UnionFind(std::vector<std::vector<int>>({{0,0},{0,1},{1,0},{1,2},{2,1},{2,2}}));
    }
    {
        MinimizeMaxNumInPath2DGrid().BFS_MinHeap(std::vector<std::vector<int>>(
                {
                        {0,1,2,3,4},
                        {24,23,22,21,5},
                        {12,13,14,15,16},
                        {11,17,18,19,20},
                        {10,9,8,7,6}
                }));
        MinimizeMaxNumInPath2DGrid().BinarySearch_BFS(std::vector<std::vector<int>>(
                {
                        {0,1,2,3,4},
                        {24,23,22,21,5},
                        {12,13,14,15,16},
                        {11,17,18,19,20},
                        {10,9,8,7,6}
                }));
    }
    {
        StackTrianglesToPyramid().DFS(std::string("XYZ"), std::vector<std::string>({"XYD", "YZE", "DEA", "FFF"}));
    }
    {
        CountRegionsCutBySlashes2DGrid().DFS(std::vector<std::string>(
                {
                    "/\\",
                    "\\/"
                }));
        CountRegionsCutBySlashes2DGrid().UnionFind(std::vector<std::string>(
                {
                        "/\\",
                        "\\/"
                }));
    }
    {
        EscapeInLarge2DMazeWithBlocks().IsEscapePossible(std::vector<std::vector<int>>({{0,1},{1,0}}), std::vector<int>({0,0}), std::vector<int>({0,2}));
    }
    {
        CountSubMatrixWSumEqualK().UsePrefixSumMap(std::vector<std::vector<int>>({
            {0,1,0},
            {1,1,1},
            {0,1,0}
        }), 0);
    }
    {
        MaxSumPathInMatrix().DFS(std::vector<std::vector<int>>(
                {
                        {0,6,0},
                        {5,8,7},
                        {0,9,0}
                }));
    }
    {
        MinKnightMoveInfinite2DGrid().AStarSearch(5,5);
        MinKnightMoveInfinite2DGrid().BidirectionalBFS(5,5);
    }


#endif
#ifdef _BinaryTree_
	/*Binary Tree*/
	RdCout ? redirect_cout::to_file("Out_BinaryTree.txt") : redirect_cout::to_cout();
	PrintH("Binary Tree");
	std::ostringstream bstOss;
	{
		BalancedBinaryTree::TreeNode * bbtRoot = new BalancedBinaryTree::TreeNode(1);
		bbtRoot->left = new BalancedBinaryTree::TreeNode(2);
		bbtRoot->right = new BalancedBinaryTree::TreeNode(2);
		bbtRoot->left->left = new BalancedBinaryTree::TreeNode(3);
		bbtRoot->left->right = new BalancedBinaryTree::TreeNode(3);
		bbtRoot->right->left = new BalancedBinaryTree::TreeNode(3);
		bbtRoot->right->right = new BalancedBinaryTree::TreeNode(3);
		bbtRoot->left->left->left = new BalancedBinaryTree::TreeNode(4);
		bbtRoot->left->left->right = new BalancedBinaryTree::TreeNode(4);
		bbtRoot->left->right->left = new BalancedBinaryTree::TreeNode(4);
		bbtRoot->left->right->right = new BalancedBinaryTree::TreeNode(4);
		bbtRoot->right->left->left = new BalancedBinaryTree::TreeNode(4);
		bbtRoot->right->left->right = new BalancedBinaryTree::TreeNode(4);
		bbtRoot->left->left->left->left = new BalancedBinaryTree::TreeNode(5);
		bbtRoot->left->left->left->right = new BalancedBinaryTree::TreeNode(5);
		PrintBinaryTree<BalancedBinaryTree::TreeNode, std::ostringstream>(bbtRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		BalancedBinaryTree().TopDown_PreOrder(bbtRoot);
		BalancedBinaryTree().BottomUp_PostOrder(bbtRoot);
		BalancedBinaryTree::DeleteTree(bbtRoot);
	}
	{
		CompleteBinaryTree::TreeNode * cbt = new CompleteBinaryTree::TreeNode(0);
		cbt->left = new CompleteBinaryTree::TreeNode(1);
		cbt->left->left = new CompleteBinaryTree::TreeNode(3);
		cbt->left->right = new CompleteBinaryTree::TreeNode(4);
		cbt->right = new CompleteBinaryTree::TreeNode(2);
		cbt->right->right = new CompleteBinaryTree::TreeNode(6);
		PrintBinaryTree<CompleteBinaryTree::TreeNode, std::ostringstream>(cbt, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		CompleteBinaryTree().ValidRecur(cbt);
		CompleteBinaryTree().LargestCompleteSubtreeSizeRecur(cbt);
		CompleteBinaryTree::DeleteTree(cbt);

		cbt = new CompleteBinaryTree::TreeNode(0);
		cbt->left = new CompleteBinaryTree::TreeNode(1);
		cbt->left->left = new CompleteBinaryTree::TreeNode(3);
		cbt->right = new CompleteBinaryTree::TreeNode(2);
		PrintBinaryTree<CompleteBinaryTree::TreeNode, std::ostringstream>(cbt, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		CompleteBinaryTree().ValidRecur(cbt);
		CompleteBinaryTree().LargestCompleteSubtreeSizeRecur(cbt);
		CompleteBinaryTree().EfficientCountNodesRecur(cbt);
		CompleteBinaryTree::DeleteTree(cbt);
	}
	{
		ValidBinarySearchTree::TreeNode * vbtRoot = new ValidBinarySearchTree::TreeNode(9);
		vbtRoot->left = new ValidBinarySearchTree::TreeNode(5);
		vbtRoot->left->left = new ValidBinarySearchTree::TreeNode(3);
		vbtRoot->left->left->left = new ValidBinarySearchTree::TreeNode(1);
		vbtRoot->left->left->right = new ValidBinarySearchTree::TreeNode(4);
		vbtRoot->left->right = new ValidBinarySearchTree::TreeNode(7);
		vbtRoot->left->right->left = new ValidBinarySearchTree::TreeNode(6);
		vbtRoot->left->right->right = new ValidBinarySearchTree::TreeNode(8);
		vbtRoot->right = new ValidBinarySearchTree::TreeNode(14);
		vbtRoot->right->left = new ValidBinarySearchTree::TreeNode(12);
		vbtRoot->right->left->left = new ValidBinarySearchTree::TreeNode(11);
		vbtRoot->right->left->right = new ValidBinarySearchTree::TreeNode(13);
		vbtRoot->right->right = new ValidBinarySearchTree::TreeNode(17);
		vbtRoot->right->right->left = new ValidBinarySearchTree::TreeNode(16);
		vbtRoot->right->right->right = new ValidBinarySearchTree::TreeNode(18);
		PrintBinaryTree<ValidBinarySearchTree::TreeNode, std::ostringstream>(vbtRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ValidBinarySearchTree().PreorderRecur(vbtRoot);
		ValidBinarySearchTree().IteratePreorderStack(vbtRoot);
		ValidBinarySearchTree().InorderRecurWPrev(vbtRoot);
		ValidBinarySearchTree().IterateInorderStack(vbtRoot);
		ValidBinarySearchTree().Iterate_Threaded(vbtRoot);
		ValidBinarySearchTree().TopDown_BFS_Queue(vbtRoot);

		vbtRoot->right->left->left->val = 37;
		PrintBinaryTree<ValidBinarySearchTree::TreeNode, std::ostringstream>(vbtRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ValidBinarySearchTree().PreorderRecur(vbtRoot);
		ValidBinarySearchTree().IteratePreorderStack(vbtRoot);
		ValidBinarySearchTree().InorderRecurWPrev(vbtRoot);
		ValidBinarySearchTree().IterateInorderStack(vbtRoot);
		ValidBinarySearchTree().Iterate_Threaded(vbtRoot);
		ValidBinarySearchTree().TopDown_BFS_Queue(vbtRoot);
		ValidBinarySearchTree::DeleteTree(vbtRoot);
	}
	{
		SymmetricBinaryTree::TreeNode * symbtRoot = new SymmetricBinaryTree::TreeNode(1);
		symbtRoot->left = new SymmetricBinaryTree::TreeNode(2);
		symbtRoot->left->left = new SymmetricBinaryTree::TreeNode(3);
		symbtRoot->left->right = new SymmetricBinaryTree::TreeNode(4);
		symbtRoot->right = new SymmetricBinaryTree::TreeNode(2);
		symbtRoot->right->left = new SymmetricBinaryTree::TreeNode(4);
		symbtRoot->right->right = new SymmetricBinaryTree::TreeNode(3);
		PrintBinaryTree<SymmetricBinaryTree::TreeNode, std::ostringstream>(symbtRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		SymmetricBinaryTree().DFS(symbtRoot);
		SymmetricBinaryTree().BFS(symbtRoot);
		SymmetricBinaryTree::DeleteTree(symbtRoot);
	}
	{
		SameBinaryTree::TreeNode * sbtRoot = new SameBinaryTree::TreeNode(1);
		sbtRoot->left = new SameBinaryTree::TreeNode(2);
		sbtRoot->right = new SameBinaryTree::TreeNode(5);
		sbtRoot->left->left = new SameBinaryTree::TreeNode(7);
		sbtRoot->left->right = new SameBinaryTree::TreeNode(8);
		sbtRoot->right->left = new SameBinaryTree::TreeNode(17);
		sbtRoot->right->right = new SameBinaryTree::TreeNode(18);
		SameBinaryTree::TreeNode * sbtRoot2 = new SameBinaryTree::TreeNode(1);
		sbtRoot2->left = new SameBinaryTree::TreeNode(2);
		sbtRoot2->right = new SameBinaryTree::TreeNode(5);
		sbtRoot2->left->left = new SameBinaryTree::TreeNode(7);
		sbtRoot2->left->right = new SameBinaryTree::TreeNode(8);
		sbtRoot2->right->left = new SameBinaryTree::TreeNode(17);
		sbtRoot2->right->right = new SameBinaryTree::TreeNode(18);
		PrintBinaryTree<SameBinaryTree::TreeNode, std::ostringstream>(sbtRoot, bstOss);
		PrintBinaryTree<SameBinaryTree::TreeNode, std::ostringstream>(sbtRoot2, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		SameBinaryTree().DFS(sbtRoot, sbtRoot2);
		SameBinaryTree().BFS(sbtRoot, sbtRoot2);
		SameBinaryTree().ContainTree(sbtRoot, sbtRoot2->right);
		SameBinaryTree::DeleteTree(sbtRoot);
		SameBinaryTree::DeleteTree(sbtRoot2);
	}
	{
		BinaryTreePreOrderTraversal::TreeNode * btprtRoot = new BinaryTreePreOrderTraversal::TreeNode(1);
		btprtRoot->right = new BinaryTreePreOrderTraversal::TreeNode(2);
		btprtRoot->right->parent = btprtRoot;
		btprtRoot->right->left = new BinaryTreePreOrderTraversal::TreeNode(3);
		btprtRoot->right->left->parent = btprtRoot->right;
		PrintBinaryTree<BinaryTreePreOrderTraversal::TreeNode, std::ostringstream>(btprtRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		BinaryTreePreOrderTraversal().Iterate_Stack(btprtRoot);
		BinaryTreePreOrderTraversal().Iterate_Stack2(btprtRoot);
		BinaryTreePreOrderTraversal().Iterate_Stack_Generic(btprtRoot);
		BinaryTreePreOrderTraversal().Iterate_WParentPtr(btprtRoot);
		BinaryTreePreOrderTraversal::DeleteTree(btprtRoot);

		BinaryTreePreOrderTraversal::TreeNode * btprtRoot2 = new BinaryTreePreOrderTraversal::TreeNode(7);
		btprtRoot2->left = new BinaryTreePreOrderTraversal::TreeNode(3);
		btprtRoot2->left->parent = btprtRoot2;
		btprtRoot2->left->left = new BinaryTreePreOrderTraversal::TreeNode(1);
		btprtRoot2->left->left->parent = btprtRoot2->left;
		btprtRoot2->left->left->left = new BinaryTreePreOrderTraversal::TreeNode(0);
		btprtRoot2->left->left->left->parent = btprtRoot2->left->left;
		btprtRoot2->left->left->right = new BinaryTreePreOrderTraversal::TreeNode(2);
		btprtRoot2->left->left->right->parent = btprtRoot2->left->left;
		btprtRoot2->left->right = new BinaryTreePreOrderTraversal::TreeNode(5);
		btprtRoot2->left->right->parent = btprtRoot2->left;
		btprtRoot2->left->right->left = new BinaryTreePreOrderTraversal::TreeNode(4);
		btprtRoot2->left->right->left->parent = btprtRoot2->left->right;
		btprtRoot2->left->right->right = new BinaryTreePreOrderTraversal::TreeNode(6);
		btprtRoot2->left->right->right->parent = btprtRoot2->left->right;
		btprtRoot2->right = new BinaryTreePreOrderTraversal::TreeNode(11);
		btprtRoot2->right->parent = btprtRoot2;
		btprtRoot2->right->left = new BinaryTreePreOrderTraversal::TreeNode(9);
		btprtRoot2->right->left->parent = btprtRoot2->right;
		btprtRoot2->right->left->left = new BinaryTreePreOrderTraversal::TreeNode(8);
		btprtRoot2->right->left->left->parent = btprtRoot2->right->left;
		btprtRoot2->right->left->right = new BinaryTreePreOrderTraversal::TreeNode(10);
		btprtRoot2->right->left->right->parent = btprtRoot2->right->left;
		btprtRoot2->right->right = new BinaryTreePreOrderTraversal::TreeNode(13);
		btprtRoot2->right->right->parent = btprtRoot2->right;
		btprtRoot2->right->right->left = new BinaryTreePreOrderTraversal::TreeNode(12);
		btprtRoot2->right->right->left->parent = btprtRoot2->right->right;
		btprtRoot2->right->right->right = new BinaryTreePreOrderTraversal::TreeNode(14);
		btprtRoot2->right->right->right->parent = btprtRoot2->right->right;
		PrintBinaryTree<BinaryTreePreOrderTraversal::TreeNode, std::ostringstream>(btprtRoot2, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		BinaryTreePreOrderTraversal().Iterate_Stack(btprtRoot2);
		BinaryTreePreOrderTraversal().Iterate_Stack2(btprtRoot2);
		BinaryTreePreOrderTraversal().Iterate_Stack_Generic(btprtRoot2);
		BinaryTreePreOrderTraversal().Iterate_WParentPtr(btprtRoot2);
		BinaryTreePreOrderTraversal::DeleteTree(btprtRoot2);
	}
	{
		BinaryTreeInOrderTraversal::TreeNode * btitRoot = new BinaryTreeInOrderTraversal::TreeNode(1);
		btitRoot->right = new BinaryTreeInOrderTraversal::TreeNode(2);
		btitRoot->right->parent = btitRoot;
		btitRoot->right->left = new BinaryTreeInOrderTraversal::TreeNode(3);
		btitRoot->right->left->parent = btitRoot->right;
		PrintBinaryTree<BinaryTreeInOrderTraversal::TreeNode, std::ostringstream>(btitRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		BinaryTreeInOrderTraversal().Iterate_Stack(btitRoot);
		BinaryTreeInOrderTraversal().Iterate_Stack2(btitRoot);
		BinaryTreeInOrderTraversal().Iterate_Threaded(btitRoot);
		BinaryTreeInOrderTraversal().Iterate_WParentPtr(btitRoot);
		BinaryTreeInOrderTraversal::DeleteTree(btitRoot);

		BinaryTreeInOrderTraversal::TreeNode * btitRoot2 = new BinaryTreeInOrderTraversal::TreeNode(7);
		btitRoot2->left = new BinaryTreeInOrderTraversal::TreeNode(3);
		btitRoot2->left->parent = btitRoot2;
		btitRoot2->left->left = new BinaryTreeInOrderTraversal::TreeNode(1);
		btitRoot2->left->left->parent = btitRoot2->left;
		btitRoot2->left->left->left = new BinaryTreeInOrderTraversal::TreeNode(0);
		btitRoot2->left->left->left->parent = btitRoot2->left->left;
		btitRoot2->left->left->right = new BinaryTreeInOrderTraversal::TreeNode(2);
		btitRoot2->left->left->right->parent = btitRoot2->left->left;
		btitRoot2->left->right = new BinaryTreeInOrderTraversal::TreeNode(5);
		btitRoot2->left->right->parent = btitRoot2->left;
		btitRoot2->left->right->left = new BinaryTreeInOrderTraversal::TreeNode(4);
		btitRoot2->left->right->left->parent = btitRoot2->left->right;
		btitRoot2->left->right->right = new BinaryTreeInOrderTraversal::TreeNode(6);
		btitRoot2->left->right->right->parent = btitRoot2->left->right;
		btitRoot2->right = new BinaryTreeInOrderTraversal::TreeNode(11);
		btitRoot2->right->parent = btitRoot2;
		btitRoot2->right->left = new BinaryTreeInOrderTraversal::TreeNode(9);
		btitRoot2->right->left->parent = btitRoot2->right;
		btitRoot2->right->left->left = new BinaryTreeInOrderTraversal::TreeNode(8);
		btitRoot2->right->left->left->parent = btitRoot2->right->left;
		btitRoot2->right->left->right = new BinaryTreeInOrderTraversal::TreeNode(10);
		btitRoot2->right->left->right->parent = btitRoot2->right->left;
		btitRoot2->right->right = new BinaryTreeInOrderTraversal::TreeNode(13);
		btitRoot2->right->right->parent = btitRoot2->right;
		btitRoot2->right->right->left = new BinaryTreeInOrderTraversal::TreeNode(12);
		btitRoot2->right->right->left->parent = btitRoot2->right->right;
		btitRoot2->right->right->right = new BinaryTreeInOrderTraversal::TreeNode(14);
		btitRoot2->right->right->right->parent = btitRoot2->right->right;
		PrintBinaryTree<BinaryTreeInOrderTraversal::TreeNode, std::ostringstream>(btitRoot2, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		BinaryTreeInOrderTraversal().Iterate_Stack(btitRoot2);
		BinaryTreeInOrderTraversal().Iterate_Stack2(btitRoot2);
		BinaryTreeInOrderTraversal().Iterate_Threaded(btitRoot2);
		BinaryTreeInOrderTraversal().Iterate_WParentPtr(btitRoot2);
		BinaryTreeInOrderTraversal::DeleteTree(btitRoot2);
	}
	{
		BinaryTreePostOrderTraversal::TreeNode * btpotRoot = new BinaryTreePostOrderTraversal::TreeNode(1);
		btpotRoot->right = new BinaryTreePostOrderTraversal::TreeNode(2);
		btpotRoot->right->parent = btpotRoot;
		btpotRoot->right->left = new BinaryTreePostOrderTraversal::TreeNode(3);
		btpotRoot->right->left->parent = btpotRoot->right;
		PrintBinaryTree<BinaryTreePostOrderTraversal::TreeNode, std::ostringstream>(btpotRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		BinaryTreePostOrderTraversal().Iterate_Stack(btpotRoot);
		BinaryTreePostOrderTraversal().Iterate_Stack2(btpotRoot);
		BinaryTreePostOrderTraversal().Iterate_Stack3(btpotRoot);
		BinaryTreePostOrderTraversal().Iterate_Stack_Generic(btpotRoot);
		BinaryTreePostOrderTraversal().Iterate_Stack_PrevNodePtr(btpotRoot);
		BinaryTreePostOrderTraversal().Iterate_WParentPtr(btpotRoot);
		BinaryTreePostOrderTraversal::DeleteTree(btpotRoot);

		BinaryTreePostOrderTraversal::TreeNode * btpotRoot2 = new BinaryTreePostOrderTraversal::TreeNode(7);
		btpotRoot2->left = new BinaryTreePostOrderTraversal::TreeNode(3);
		btpotRoot2->left->parent = btpotRoot2;
		btpotRoot2->left->left = new BinaryTreePostOrderTraversal::TreeNode(1);
		btpotRoot2->left->left->parent = btpotRoot2->left;
		btpotRoot2->left->left->left = new BinaryTreePostOrderTraversal::TreeNode(0);
		btpotRoot2->left->left->left->parent = btpotRoot2->left->left;
		btpotRoot2->left->left->right = new BinaryTreePostOrderTraversal::TreeNode(2);
		btpotRoot2->left->left->right->parent = btpotRoot2->left->left;
		btpotRoot2->left->right = new BinaryTreePostOrderTraversal::TreeNode(5);
		btpotRoot2->left->right->parent = btpotRoot2->left;
		btpotRoot2->left->right->left = new BinaryTreePostOrderTraversal::TreeNode(4);
		btpotRoot2->left->right->left->parent = btpotRoot2->left->right;
		btpotRoot2->left->right->right = new BinaryTreePostOrderTraversal::TreeNode(6);
		btpotRoot2->left->right->right->parent = btpotRoot2->left->right;
		btpotRoot2->right = new BinaryTreePostOrderTraversal::TreeNode(11);
		btpotRoot2->right->parent = btpotRoot2;
		btpotRoot2->right->left = new BinaryTreePostOrderTraversal::TreeNode(9);
		btpotRoot2->right->left->parent = btpotRoot2->right;
		btpotRoot2->right->left->left = new BinaryTreePostOrderTraversal::TreeNode(8);
		btpotRoot2->right->left->left->parent = btpotRoot2->right->left;
		btpotRoot2->right->left->right = new BinaryTreePostOrderTraversal::TreeNode(10);
		btpotRoot2->right->left->right->parent = btpotRoot2->right->left;
		btpotRoot2->right->right = new BinaryTreePostOrderTraversal::TreeNode(13);
		btpotRoot2->right->right->parent = btpotRoot2->right;
		btpotRoot2->right->right->left = new BinaryTreePostOrderTraversal::TreeNode(12);
		btpotRoot2->right->right->left->parent = btpotRoot2->right->right;
		btpotRoot2->right->right->right = new BinaryTreePostOrderTraversal::TreeNode(14);
		btpotRoot2->right->right->right->parent = btpotRoot2->right->right;
		PrintBinaryTree<BinaryTreePostOrderTraversal::TreeNode, std::ostringstream>(btpotRoot2, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		BinaryTreePostOrderTraversal().Iterate_Stack(btpotRoot2);
		BinaryTreePostOrderTraversal().Iterate_Stack2(btpotRoot2);
		BinaryTreePostOrderTraversal().Iterate_Stack3(btpotRoot2);
		BinaryTreePostOrderTraversal().Iterate_Stack_Generic(btpotRoot2);
		BinaryTreePostOrderTraversal().Iterate_Stack_PrevNodePtr(btpotRoot2);
		BinaryTreePostOrderTraversal().Iterate_WParentPtr(btpotRoot2);
		BinaryTreePostOrderTraversal::DeleteTree(btpotRoot2);
	}
	{
		BinaryTreeLevelOrderTraversal::TreeNode * btltRoot = new BinaryTreeLevelOrderTraversal::TreeNode(3);
		btltRoot->left = new BinaryTreeLevelOrderTraversal::TreeNode(9);
		btltRoot->right = new BinaryTreeLevelOrderTraversal::TreeNode(20);
		btltRoot->right->left = new BinaryTreeLevelOrderTraversal::TreeNode(15);
		btltRoot->right->right = new BinaryTreeLevelOrderTraversal::TreeNode(7);
		PrintBinaryTree<BinaryTreeLevelOrderTraversal::TreeNode, std::ostringstream>(btltRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		BinaryTreeLevelOrderTraversal().TopDown_DFS_Recur(btltRoot);
		BinaryTreeLevelOrderTraversal().TopDown_BFS_Queue(btltRoot);
		BinaryTreeLevelOrderTraversal().TopDown_BFS_Queue2(btltRoot);
		BinaryTreeLevelOrderTraversal().TopDown_BFS_Queue3(btltRoot);
		BinaryTreeLevelOrderTraversal().BottomUp_DFS_Recur(btltRoot);
		BinaryTreeLevelOrderTraversal().BottomUp_BFS_Queue(btltRoot);
		BinaryTreeLevelOrderTraversal().TopDownZigzag_BFS(btltRoot);
		BinaryTreeLevelOrderTraversal().TopDownZigzag_BFS_2Stack(btltRoot);
		BinaryTreeLevelOrderTraversal::DeleteTree(btltRoot);
	}
	{
		MaxDepthBinaryTree::TreeNode * madbtRoot = new MaxDepthBinaryTree::TreeNode(1);
		madbtRoot->left = new MaxDepthBinaryTree::TreeNode(2);
		madbtRoot->right = new MaxDepthBinaryTree::TreeNode(4);
		madbtRoot->right->left = new MaxDepthBinaryTree::TreeNode(5);
		madbtRoot->right->left->right = new MaxDepthBinaryTree::TreeNode(6);
		madbtRoot->right->right = new MaxDepthBinaryTree::TreeNode(3);
		PrintBinaryTree<MaxDepthBinaryTree::TreeNode, std::ostringstream>(madbtRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		MaxDepthBinaryTree().DFS_Recur(madbtRoot);
		MaxDepthBinaryTree().BFS(madbtRoot);
		MaxDepthBinaryTree::DeleteTree(madbtRoot);
	}
	{
		MinDepthBinaryTree::TreeNode * midbtRoot = new MinDepthBinaryTree::TreeNode(1);
		midbtRoot->left = new MinDepthBinaryTree::TreeNode(2);
		midbtRoot->right = new MinDepthBinaryTree::TreeNode(4);
		midbtRoot->right->left = new MinDepthBinaryTree::TreeNode(5);
		midbtRoot->right->left->right = new MinDepthBinaryTree::TreeNode(6);
		midbtRoot->right->right = new MinDepthBinaryTree::TreeNode(3);
		PrintBinaryTree<MinDepthBinaryTree::TreeNode, std::ostringstream>(midbtRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		MinDepthBinaryTree().DFS_Recur(midbtRoot);
		MinDepthBinaryTree().BFS(midbtRoot);
		MinDepthBinaryTree::DeleteTree(midbtRoot);
	}
	{
		BinaryTreePathSum::TreeNode * btpsRoot = new BinaryTreePathSum::TreeNode(5);
		btpsRoot->left = new BinaryTreePathSum::TreeNode(4);
		btpsRoot->left->left = new BinaryTreePathSum::TreeNode(11);
		btpsRoot->left->left->left = new BinaryTreePathSum::TreeNode(7);
		btpsRoot->left->left->right = new BinaryTreePathSum::TreeNode(2);
		btpsRoot->left->right = new BinaryTreePathSum::TreeNode(18);
		btpsRoot->left->right->left = new BinaryTreePathSum::TreeNode(10);
		btpsRoot->left->right->right = new BinaryTreePathSum::TreeNode(1);
		btpsRoot->right = new BinaryTreePathSum::TreeNode(8);
		btpsRoot->right->left = new BinaryTreePathSum::TreeNode(9);
		btpsRoot->right->left->left = new BinaryTreePathSum::TreeNode(5);
		btpsRoot->right->left->right = new BinaryTreePathSum::TreeNode(7);
		btpsRoot->right->right = new BinaryTreePathSum::TreeNode(6);
		btpsRoot->right->right->left = new BinaryTreePathSum::TreeNode(3);
		btpsRoot->right->right->right = new BinaryTreePathSum::TreeNode(16);
		PrintBinaryTree<BinaryTreePathSum::TreeNode, std::ostringstream>(btpsRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		BinaryTreePathSum().HasRootToLeafPathSumRecur(btpsRoot, 22);
		BinaryTreePathSum().FindAllRootToLeafPath(btpsRoot, 22);
		BinaryTreePathSum().FindAllArbitraryPath(btpsRoot, 22);
		BinaryTreePathSum::DeleteTree(btpsRoot);
	}
	{
		BinaryTreeMaxPathSum::TreeNode * btmpsRoot = new BinaryTreeMaxPathSum::TreeNode(8);
		btmpsRoot->left = new BinaryTreeMaxPathSum::TreeNode(-4);
		btmpsRoot->right = new BinaryTreeMaxPathSum::TreeNode(5);
		btmpsRoot->left->left = new BinaryTreeMaxPathSum::TreeNode(7);
		btmpsRoot->left->right = new BinaryTreeMaxPathSum::TreeNode(3);
		btmpsRoot->right->left = new BinaryTreeMaxPathSum::TreeNode(-6);
		btmpsRoot->right->right = new BinaryTreeMaxPathSum::TreeNode(9);
		btmpsRoot->left->left->left = new BinaryTreeMaxPathSum::TreeNode(2);
		btmpsRoot->left->left->right = new BinaryTreeMaxPathSum::TreeNode(4);
		btmpsRoot->left->right->left = new BinaryTreeMaxPathSum::TreeNode(-2);
		btmpsRoot->left->right->right = new BinaryTreeMaxPathSum::TreeNode(5);
		btmpsRoot->right->left->left = new BinaryTreeMaxPathSum::TreeNode(7);
		btmpsRoot->right->left->right = new BinaryTreeMaxPathSum::TreeNode(-1);
		btmpsRoot->left->left->left->left = new BinaryTreeMaxPathSum::TreeNode(-4);
		btmpsRoot->left->left->left->right = new BinaryTreeMaxPathSum::TreeNode(6);
		PrintBinaryTree<BinaryTreeMaxPathSum::TreeNode, std::ostringstream>(btmpsRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		BinaryTreeMaxPathSum().GO_Recur(btmpsRoot);
		BinaryTreeMaxPathSum::DeleteTree(btmpsRoot);
	}
	{
		SumRootToLeafNums::TreeNode * srtlnRoot = new SumRootToLeafNums::TreeNode(5);
		srtlnRoot->left = new SumRootToLeafNums::TreeNode(4);
		srtlnRoot->left->left = new SumRootToLeafNums::TreeNode(1);
		srtlnRoot->left->left->left = new SumRootToLeafNums::TreeNode(7);
		srtlnRoot->left->left->right = new SumRootToLeafNums::TreeNode(2);
		srtlnRoot->right = new SumRootToLeafNums::TreeNode(8);
		srtlnRoot->right->left = new SumRootToLeafNums::TreeNode(9);
		srtlnRoot->right->right = new SumRootToLeafNums::TreeNode(4);
		srtlnRoot->right->right->left = new SumRootToLeafNums::TreeNode(5);
		srtlnRoot->right->right->right = new SumRootToLeafNums::TreeNode(1);
		PrintBinaryTree<SumRootToLeafNums::TreeNode, std::ostringstream>(srtlnRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		SumRootToLeafNums().SolveRecur(srtlnRoot);
		SumRootToLeafNums::DeleteTree(srtlnRoot);
	}
	{
		UniqueBinarySearchTree().count_Recur(3);
		UniqueBinarySearchTree().count_DP(3);

		std::vector<UniqueBinarySearchTree::TreeNode *> ubstRootVecRecur = UniqueBinarySearchTree().generate_Recur(3);
		bstOss << "UniqueBinarySearchTree generate recur (1...3):" << std::endl;
		for (std::vector<UniqueBinarySearchTree::TreeNode *>::iterator i = ubstRootVecRecur.begin(); i != ubstRootVecRecur.end(); ++i)
		{
			PrintBinaryTree<UniqueBinarySearchTree::TreeNode, std::ostringstream>(*i, bstOss);
			UniqueBinarySearchTree::DeleteTree(*i);
		}
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());

		std::vector<UniqueBinarySearchTree::TreeNode *> ubstRootVecDP = UniqueBinarySearchTree().generate_DP(3);
		bstOss << "UniqueBinarySearchTree generate DP (1...3):" << std::endl;
		for (std::vector<UniqueBinarySearchTree::TreeNode *>::iterator i = ubstRootVecDP.begin(); i != ubstRootVecDP.end(); ++i)
		{
			PrintBinaryTree<UniqueBinarySearchTree::TreeNode, std::ostringstream>(*i, bstOss);
			UniqueBinarySearchTree::DeleteTree(*i);
		}
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
	}
	{
		ConstructBinaryTreeFrom2Traversals::TreeNode * cbtftRoot1 = ConstructBinaryTreeFrom2Traversals().BruteForce_InPost
			(std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }), std::vector<int>({ 0, 2, 4, 6, 5, 3, 1, 8, 10, 9, 7 }));
		bstOss << "ConstructBinaryTreeFrom2Traversals BruteForce InPost-Order:" << std::endl;
		bstOss << "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10" << std::endl << "0, 2, 4, 6, 5, 3, 1, 8, 10, 9, 7" << std::endl;
		PrintBinaryTree<ConstructBinaryTreeFrom2Traversals::TreeNode, std::ostringstream>(cbtftRoot1, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConstructBinaryTreeFrom2Traversals::DeleteTree(cbtftRoot1);


		ConstructBinaryTreeFrom2Traversals::TreeNode * cbtftRoot2 = ConstructBinaryTreeFrom2Traversals().HashTable_InPost
			(std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }), std::vector<int>({ 0, 2, 4, 6, 5, 3, 1, 8, 10, 9, 7 }));
		bstOss << "ConstructBinaryTreeFrom2Traversals HashTable InPost-Order:" << std::endl;
		bstOss << "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10" << std::endl << "0, 2, 4, 6, 5, 3, 1, 8, 10, 9, 7" << std::endl;
		PrintBinaryTree<ConstructBinaryTreeFrom2Traversals::TreeNode, std::ostringstream>(cbtftRoot2, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConstructBinaryTreeFrom2Traversals::DeleteTree(cbtftRoot2);


		ConstructBinaryTreeFrom2Traversals::TreeNode * cbtftRoot0 = ConstructBinaryTreeFrom2Traversals().IterateStack_InPost
		(std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }), std::vector<int>({ 0, 2, 4, 6, 5, 3, 1, 8, 10, 9, 7 }));
		bstOss << "ConstructBinaryTreeFrom2Traversals IterateStack InPost-Order:" << std::endl;
		bstOss << "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10" << std::endl << "0, 2, 4, 6, 5, 3, 1, 8, 10, 9, 7" << std::endl;
		PrintBinaryTree<ConstructBinaryTreeFrom2Traversals::TreeNode, std::ostringstream>(cbtftRoot0, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConstructBinaryTreeFrom2Traversals::DeleteTree(cbtftRoot0);


		ConstructBinaryTreeFrom2Traversals::TreeNode * cbtftRoot3 = ConstructBinaryTreeFrom2Traversals().BruteForce_PreIn
			(std::vector<int>({ 7, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10 }), std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }));
		bstOss << "ConstructBinaryTreeFrom2Traversals BruteForce PreIn-Order:" << std::endl;
		bstOss << "7, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10" << std::endl << "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10" << std::endl;
		PrintBinaryTree<ConstructBinaryTreeFrom2Traversals::TreeNode, std::ostringstream>(cbtftRoot3, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConstructBinaryTreeFrom2Traversals::DeleteTree(cbtftRoot3);


		ConstructBinaryTreeFrom2Traversals::TreeNode * cbtftRoot4 = ConstructBinaryTreeFrom2Traversals().HashTable_PreIn
			(std::vector<int>({ 7, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10 }), std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }));
		bstOss << "ConstructBinaryTreeFrom2Traversals HashTable PreIn-Order:" << std::endl;
		bstOss << "7, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10" << std::endl << "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10" << std::endl;
		PrintBinaryTree<ConstructBinaryTreeFrom2Traversals::TreeNode, std::ostringstream>(cbtftRoot4, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConstructBinaryTreeFrom2Traversals::DeleteTree(cbtftRoot4);


		ConstructBinaryTreeFrom2Traversals::TreeNode * cbtftRoot5 = ConstructBinaryTreeFrom2Traversals().IterateStack_PreIn
		(std::vector<int>({ 7, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10 }), std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }));
		bstOss << "ConstructBinaryTreeFrom2Traversals IterateStack PreIn-Order:" << std::endl;
		bstOss << "7, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10" << std::endl << "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10" << std::endl;
		PrintBinaryTree<ConstructBinaryTreeFrom2Traversals::TreeNode, std::ostringstream>(cbtftRoot5, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConstructBinaryTreeFrom2Traversals::DeleteTree(cbtftRoot5);


        ConstructBinaryTreeFrom2Traversals::TreeNode * cbtftRoot6 = ConstructBinaryTreeFrom2Traversals().BruteForce_PrePost
                (std::vector<int>({ 7, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10 }), std::vector<int>({ 0, 2, 4, 6, 5, 3, 1, 8, 10, 9, 7 }));
        bstOss << "ConstructBinaryTreeFrom2Traversals BruteForce PrePost-Order:" << std::endl;
        bstOss << "7, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10" << std::endl << "0, 2, 4, 6, 5, 3, 1, 8, 10, 9, 7" << std::endl;
        PrintBinaryTree<ConstructBinaryTreeFrom2Traversals::TreeNode, std::ostringstream>(cbtftRoot6, bstOss);
        std::cout << bstOss.str() << std::endl;
        bstOss.str(std::string());
        ConstructBinaryTreeFrom2Traversals::DeleteTree(cbtftRoot6);


        ConstructBinaryTreeFrom2Traversals::TreeNode * cbtftRoot7 = ConstructBinaryTreeFrom2Traversals().HashTable_PrePost
                (std::vector<int>({ 7, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10 }), std::vector<int>({ 0, 2, 4, 6, 5, 3, 1, 8, 10, 9, 7 }));
        bstOss << "ConstructBinaryTreeFrom2Traversals HashTable PrePost-Order:" << std::endl;
        bstOss << "7, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10" << std::endl << "0, 2, 4, 6, 5, 3, 1, 8, 10, 9, 7" << std::endl;
        PrintBinaryTree<ConstructBinaryTreeFrom2Traversals::TreeNode, std::ostringstream>(cbtftRoot7, bstOss);
        std::cout << bstOss.str() << std::endl;
        bstOss.str(std::string());
        ConstructBinaryTreeFrom2Traversals::DeleteTree(cbtftRoot7);
	}
	{
		ConstructBSTFromTraversal::TreeNode * root = ConstructBSTFromTraversal().Preorder_BruteForce_Recur(std::vector<int>({ 7, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10 }));
		bstOss << "ConstructBSTFromTraversal Preorder BruteForce Recur:" << std::endl;
		bstOss << "7, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10" << std::endl;
		PrintBinaryTree<ConstructBSTFromTraversal::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConstructBSTFromTraversal::DeleteTree(root);

		ConstructBSTFromTraversal::TreeNode * root2 = ConstructBSTFromTraversal().Preorder_Linear_Recur(std::vector<int>({ 7, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10 }));
		bstOss << "ConstructBSTFromTraversal Preorder Linear Recur:" << std::endl;
		bstOss << "7, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10" << std::endl;
		PrintBinaryTree<ConstructBSTFromTraversal::TreeNode, std::ostringstream>(root2, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConstructBSTFromTraversal::DeleteTree(root2);

		root = ConstructBSTFromTraversal().IteratePreorderSortedStack(std::vector<int>({ 7, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10 }));
		bstOss << "ConstructBSTFromTraversal IteratePreorderSortedStack:" << std::endl;
		bstOss << "7, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10" << std::endl;
		PrintBinaryTree<ConstructBSTFromTraversal::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConstructBSTFromTraversal::DeleteTree(root);

		ConstructBSTFromTraversal::TreeNode * root3 = ConstructBSTFromTraversal().Postorder_BruteForce_Recur(std::vector<int>({ 0, 2, 4, 6, 5, 3, 1, 8, 10, 9, 7 }));
		bstOss << "ConstructBSTFromTraversal Postorder BruteForce Recur:" << std::endl;
		bstOss << "0, 2, 4, 6, 5, 3, 1, 8, 10, 9, 7" << std::endl;
		PrintBinaryTree<ConstructBSTFromTraversal::TreeNode, std::ostringstream>(root3, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConstructBSTFromTraversal::DeleteTree(root3);

		ConstructBSTFromTraversal::TreeNode * root4 = ConstructBSTFromTraversal().Postorder_Linear_Recur(std::vector<int>({ 0, 2, 4, 6, 5, 3, 1, 8, 10, 9, 7 }));
		bstOss << "ConstructBSTFromTraversal Postorder Linear Recur:" << std::endl;
		bstOss << "0, 2, 4, 6, 5, 3, 1, 8, 10, 9, 7" << std::endl;
		PrintBinaryTree<ConstructBSTFromTraversal::TreeNode, std::ostringstream>(root4, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConstructBSTFromTraversal::DeleteTree(root4);

		root3 = ConstructBSTFromTraversal().IteratePostorderSortedStack(std::vector<int>({ 0, 2, 4, 6, 5, 3, 1, 8, 10, 9, 7 }));
		bstOss << "ConstructBSTFromTraversal IteratePostorderSortedStack:" << std::endl;
		bstOss << "0, 2, 4, 6, 5, 3, 1, 8, 10, 9, 7" << std::endl;
		PrintBinaryTree<ConstructBSTFromTraversal::TreeNode, std::ostringstream>(root3, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConstructBSTFromTraversal::DeleteTree(root3);
	}
	{
		ConstructBinaryTreeFromTraversal::TreeNode * root = ConstructBinaryTreeFromTraversal().PreOrder(std::vector<ConstructBinaryTreeFromTraversal::TreeNode *>(
		{ new ConstructBinaryTreeFromTraversal::TreeNode(7), new ConstructBinaryTreeFromTraversal::TreeNode(1), new ConstructBinaryTreeFromTraversal::TreeNode(0), nullptr, nullptr
		, new ConstructBinaryTreeFromTraversal::TreeNode(3), new ConstructBinaryTreeFromTraversal::TreeNode(2), nullptr, nullptr, new ConstructBinaryTreeFromTraversal::TreeNode(5), new ConstructBinaryTreeFromTraversal::TreeNode(4), nullptr, nullptr
		, new ConstructBinaryTreeFromTraversal::TreeNode(6), nullptr, nullptr, new ConstructBinaryTreeFromTraversal::TreeNode(9), new ConstructBinaryTreeFromTraversal::TreeNode(8), nullptr, nullptr
		, new ConstructBinaryTreeFromTraversal::TreeNode(10), nullptr, nullptr }));
		bstOss << "ConstructBinaryTreeFromTraversal PreOrder for \"7, 1, 0, N, N, 3, 2, N, N, 5, 4, N, N, 6, N, N, 9, 8, N, N, 10, N, N\":" << std::endl;
		PrintBinaryTree<ConstructBinaryTreeFromTraversal::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConstructBinaryTreeFromTraversal::DeleteTree(root);

		ConstructBinaryTreeFromTraversal::TreeNode * root2 = ConstructBinaryTreeFromTraversal().PostOrder(std::vector<ConstructBinaryTreeFromTraversal::TreeNode *>(
		{ nullptr, nullptr, new ConstructBinaryTreeFromTraversal::TreeNode(0), nullptr, nullptr, new ConstructBinaryTreeFromTraversal::TreeNode(2), nullptr, nullptr, new ConstructBinaryTreeFromTraversal::TreeNode(4), nullptr, nullptr
		, new ConstructBinaryTreeFromTraversal::TreeNode(6), new ConstructBinaryTreeFromTraversal::TreeNode(5), new ConstructBinaryTreeFromTraversal::TreeNode(3), new ConstructBinaryTreeFromTraversal::TreeNode(1)
		, nullptr, nullptr, new ConstructBinaryTreeFromTraversal::TreeNode(8), nullptr, nullptr, new ConstructBinaryTreeFromTraversal::TreeNode(10)
		, new ConstructBinaryTreeFromTraversal::TreeNode(9), new ConstructBinaryTreeFromTraversal::TreeNode(7) }));
		bstOss << "ConstructBinaryTreeFromTraversal PostOrder for \"N, N, 0, N, N, 2, N, N, 4, N, N, 6, 5, 3, 1, N, N, 8, N, N, 10, 9, 7\":" << std::endl;
		PrintBinaryTree<ConstructBinaryTreeFromTraversal::TreeNode, std::ostringstream>(root2, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConstructBinaryTreeFromTraversal::DeleteTree(root2);

		ConstructBinaryTreeFromTraversal::TreeNode * root3 = ConstructBinaryTreeFromTraversal().LevelOrder(std::vector<ConstructBinaryTreeFromTraversal::TreeNode *>(
		{ new ConstructBinaryTreeFromTraversal::TreeNode(7), new ConstructBinaryTreeFromTraversal::TreeNode(1), new ConstructBinaryTreeFromTraversal::TreeNode(9), new ConstructBinaryTreeFromTraversal::TreeNode(0)
			, new ConstructBinaryTreeFromTraversal::TreeNode(3), new ConstructBinaryTreeFromTraversal::TreeNode(8), new ConstructBinaryTreeFromTraversal::TreeNode(10), nullptr, nullptr
			, new ConstructBinaryTreeFromTraversal::TreeNode(2), new ConstructBinaryTreeFromTraversal::TreeNode(5), nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
			, new ConstructBinaryTreeFromTraversal::TreeNode(4), new ConstructBinaryTreeFromTraversal::TreeNode(6), nullptr, nullptr, nullptr, nullptr }));
		bstOss << "ConstructBinaryTreeFromTraversal LevelOrder for \"7, 1, 9, 0, 3, 8, 10, N, N, 2, 5, N, N, N, N, N, N, 4, 6, N, N, N, N\":" << std::endl;
		PrintBinaryTree<ConstructBinaryTreeFromTraversal::TreeNode, std::ostringstream>(root3, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConstructBinaryTreeFromTraversal::DeleteTree(root3);
	}
	{
		ConvertSortedArrayToBinarySearchTree::TreeNode * csatbstRoot1 = ConvertSortedArrayToBinarySearchTree().PreOrder
			(std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }));
		bstOss << "ConvertSortedArrayToBinarySearchTree Pre-Order:" << std::endl;
		bstOss << "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10" << std::endl;
		PrintBinaryTree<ConvertSortedArrayToBinarySearchTree::TreeNode, std::ostringstream>(csatbstRoot1, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConvertSortedArrayToBinarySearchTree::DeleteTree(csatbstRoot1);

		ConvertSortedArrayToBinarySearchTree::TreeNode * csatbstRoot2 = ConvertSortedArrayToBinarySearchTree().InOrder
			(std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }));
		bstOss << "ConvertSortedArrayToBinarySearchTree In-Order:" << std::endl;
		bstOss << "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10" << std::endl;
		PrintBinaryTree<ConvertSortedArrayToBinarySearchTree::TreeNode, std::ostringstream>(csatbstRoot2, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConvertSortedArrayToBinarySearchTree::DeleteTree(csatbstRoot2);

		ConvertSortedArrayToBinarySearchTree::TreeNode * csatbstRoot3 = ConvertSortedArrayToBinarySearchTree().IteratePreorderStack
		(std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }));
		bstOss << "ConvertSortedArrayToBinarySearchTree IteratePreorderStack:" << std::endl;
		bstOss << "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10" << std::endl;
		PrintBinaryTree<ConvertSortedArrayToBinarySearchTree::TreeNode, std::ostringstream>(csatbstRoot3, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConvertSortedArrayToBinarySearchTree::DeleteTree(csatbstRoot3);

		ConvertSortedArrayToBinarySearchTree::TreeNode * csatbstRoot4 = ConvertSortedArrayToBinarySearchTree().IterateInorderStack
		(std::vector<int>({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }));
		bstOss << "ConvertSortedArrayToBinarySearchTree IterateInorderStack:" << std::endl;
		bstOss << "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10" << std::endl;
		PrintBinaryTree<ConvertSortedArrayToBinarySearchTree::TreeNode, std::ostringstream>(csatbstRoot4, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConvertSortedArrayToBinarySearchTree::DeleteTree(csatbstRoot4);
	}
	{
		ConvertSortedListToBinarySearchTree::ListNode * csltbstHeadP = new ConvertSortedListToBinarySearchTree::ListNode(0);
		csltbstHeadP->next = new ConvertSortedListToBinarySearchTree::ListNode(1);
		csltbstHeadP->next->next = new ConvertSortedListToBinarySearchTree::ListNode(2);
		csltbstHeadP->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(3);
		csltbstHeadP->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(4);
		csltbstHeadP->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(5);
		csltbstHeadP->next->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(6);
		csltbstHeadP->next->next->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(7);
		csltbstHeadP->next->next->next->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(8);
		csltbstHeadP->next->next->next->next->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(9);
		csltbstHeadP->next->next->next->next->next->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(10);
		ConvertSortedListToBinarySearchTree::ListNode * csltbstHeadI = new ConvertSortedListToBinarySearchTree::ListNode(0);
		csltbstHeadI->next = new ConvertSortedListToBinarySearchTree::ListNode(1);
		csltbstHeadI->next->next = new ConvertSortedListToBinarySearchTree::ListNode(2);
		csltbstHeadI->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(3);
		csltbstHeadI->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(4);
		csltbstHeadI->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(5);
		csltbstHeadI->next->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(6);
		csltbstHeadI->next->next->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(7);
		csltbstHeadI->next->next->next->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(8);
		csltbstHeadI->next->next->next->next->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(9);
		csltbstHeadI->next->next->next->next->next->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(10);
		ConvertSortedListToBinarySearchTree::ListNode * csltbstHeadI2 = new ConvertSortedListToBinarySearchTree::ListNode(0);
		csltbstHeadI2->next = new ConvertSortedListToBinarySearchTree::ListNode(1);
		csltbstHeadI2->next->next = new ConvertSortedListToBinarySearchTree::ListNode(2);
		csltbstHeadI2->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(3);
		csltbstHeadI2->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(4);
		csltbstHeadI2->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(5);
		csltbstHeadI2->next->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(6);
		csltbstHeadI2->next->next->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(7);
		csltbstHeadI2->next->next->next->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(8);
		csltbstHeadI2->next->next->next->next->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(9);
		csltbstHeadI2->next->next->next->next->next->next->next->next->next->next = new ConvertSortedListToBinarySearchTree::ListNode(10);
		bstOss << "ConvertSortedListToBinarySearchTree Pre-order:" << std::endl;
		PrintLinkedList<ConvertSortedListToBinarySearchTree::ListNode, std::ostringstream>(csltbstHeadP, bstOss);
		ConvertSortedListToBinarySearchTree::TreeNode * csltrbstRootP = ConvertSortedListToBinarySearchTree().PreOrder(csltbstHeadP);
		PrintBinaryTree<ConvertSortedListToBinarySearchTree::TreeNode, std::ostringstream>(csltrbstRootP, bstOss);
		bstOss << "ConvertSortedListToBinarySearchTree In-order:" << std::endl;
		PrintLinkedList<ConvertSortedListToBinarySearchTree::ListNode, std::ostringstream>(csltbstHeadI, bstOss);
		ConvertSortedListToBinarySearchTree::TreeNode * csltrbstRootI = ConvertSortedListToBinarySearchTree().InOrder(csltbstHeadI);
		PrintBinaryTree<ConvertSortedListToBinarySearchTree::TreeNode, std::ostringstream>(csltrbstRootI, bstOss);
		bstOss << "ConvertSortedListToBinarySearchTree In-order IterateStack:" << std::endl;
		PrintLinkedList<ConvertSortedListToBinarySearchTree::ListNode, std::ostringstream>(csltbstHeadI2, bstOss);
		ConvertSortedListToBinarySearchTree::TreeNode * csltrbstRootI2 = ConvertSortedListToBinarySearchTree().IterateInorderStack(csltbstHeadI2);
		PrintBinaryTree<ConvertSortedListToBinarySearchTree::TreeNode, std::ostringstream>(csltrbstRootI2, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConvertSortedListToBinarySearchTree::DeleteLinkedList(csltbstHeadP);
		ConvertSortedListToBinarySearchTree::DeleteLinkedList(csltbstHeadI);
		ConvertSortedListToBinarySearchTree::DeleteLinkedList(csltbstHeadI2);
		ConvertSortedListToBinarySearchTree::DeleteTree(csltrbstRootP);
		ConvertSortedListToBinarySearchTree::DeleteTree(csltrbstRootI);
		ConvertSortedListToBinarySearchTree::DeleteTree(csltrbstRootI2);
	}
	for (int i = 0; i < 3; ++i)
	{
		RecoverAlmostBinarySearchTree::TreeNode * rbstRoot = new RecoverAlmostBinarySearchTree::TreeNode(6);
		rbstRoot->left = new RecoverAlmostBinarySearchTree::TreeNode(2);
		rbstRoot->left->left = new RecoverAlmostBinarySearchTree::TreeNode(1);
		rbstRoot->left->right = new RecoverAlmostBinarySearchTree::TreeNode(8);//
		rbstRoot->left->right->left = new RecoverAlmostBinarySearchTree::TreeNode(3);
		rbstRoot->left->right->right = new RecoverAlmostBinarySearchTree::TreeNode(5);
		rbstRoot->right = new RecoverAlmostBinarySearchTree::TreeNode(7);
		rbstRoot->right->right = new RecoverAlmostBinarySearchTree::TreeNode(9);
		rbstRoot->right->right->left = new RecoverAlmostBinarySearchTree::TreeNode(4);//
		PrintBinaryTree<RecoverAlmostBinarySearchTree::TreeNode, std::ostringstream>(rbstRoot, bstOss);
		bstOss << "RecoverAlmostBinarySearchTree for the above tree ";
		if (i == 0)
		{
			bstOss << "InorderRecur:" << std::endl;
			RecoverAlmostBinarySearchTree().InorderRecur(rbstRoot);
		}
		else if (i == 1)
		{
			bstOss << "IterateInorderStack:" << std::endl;
			RecoverAlmostBinarySearchTree().IterateInorderStack(rbstRoot);
		}
		else if (i == 2)
		{
			bstOss << "Threaded:" << std::endl;
			RecoverAlmostBinarySearchTree().GO_Threaded(rbstRoot);
		}
		PrintBinaryTree<RecoverAlmostBinarySearchTree::TreeNode, std::ostringstream>(rbstRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		RecoverAlmostBinarySearchTree::DeleteTree(rbstRoot);
	}
	{
		FlattenBinaryTreeToLinkedList::TreeNode * fbttllRoot = new FlattenBinaryTreeToLinkedList::TreeNode(1);
		fbttllRoot->left = new FlattenBinaryTreeToLinkedList::TreeNode(2);
		fbttllRoot->left->left = new FlattenBinaryTreeToLinkedList::TreeNode(3);
		fbttllRoot->left->right = new FlattenBinaryTreeToLinkedList::TreeNode(4);
		fbttllRoot->right = new FlattenBinaryTreeToLinkedList::TreeNode(5);
		fbttllRoot->right->right = new FlattenBinaryTreeToLinkedList::TreeNode(6);
		bstOss << "FlattenBinaryTreeToLinkedList:" << std::endl;
		PrintBinaryTree<FlattenBinaryTreeToLinkedList::TreeNode, std::ostringstream>(fbttllRoot, bstOss);
		FlattenBinaryTreeToLinkedList().GO(fbttllRoot);
		PrintBinaryTree<FlattenBinaryTreeToLinkedList::TreeNode, std::ostringstream>(fbttllRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		FlattenBinaryTreeToLinkedList::DeleteTree(fbttllRoot);
	}
	{
		PopulatingNextRightPtr::TreeLinkNode * pnrpRootPerf = new PopulatingNextRightPtr::TreeLinkNode(1);
		pnrpRootPerf->left = new PopulatingNextRightPtr::TreeLinkNode(2);
		pnrpRootPerf->left->left = new PopulatingNextRightPtr::TreeLinkNode(4);
		pnrpRootPerf->left->right = new PopulatingNextRightPtr::TreeLinkNode(5);
		pnrpRootPerf->right = new PopulatingNextRightPtr::TreeLinkNode(3);
		pnrpRootPerf->right->left = new PopulatingNextRightPtr::TreeLinkNode(6);
		pnrpRootPerf->right->right = new PopulatingNextRightPtr::TreeLinkNode(7);
		PopulatingNextRightPtr::TreeLinkNode * pnrpRootNPerf = new PopulatingNextRightPtr::TreeLinkNode(1);
		pnrpRootNPerf->left = new PopulatingNextRightPtr::TreeLinkNode(2);
		pnrpRootNPerf->left->left = new PopulatingNextRightPtr::TreeLinkNode(4);
		pnrpRootNPerf->left->right = new PopulatingNextRightPtr::TreeLinkNode(5);
		pnrpRootNPerf->right = new PopulatingNextRightPtr::TreeLinkNode(3);
		pnrpRootNPerf->right->right = new PopulatingNextRightPtr::TreeLinkNode(7);
		PopulatingNextRightPtr::TreeLinkNode * pnrpRootNPerf2 = new PopulatingNextRightPtr::TreeLinkNode(1);
		pnrpRootNPerf2->left = new PopulatingNextRightPtr::TreeLinkNode(2);
		pnrpRootNPerf2->left->left = new PopulatingNextRightPtr::TreeLinkNode(4);
		pnrpRootNPerf2->left->right = new PopulatingNextRightPtr::TreeLinkNode(5);
		pnrpRootNPerf2->right = new PopulatingNextRightPtr::TreeLinkNode(3);
		pnrpRootNPerf2->right->right = new PopulatingNextRightPtr::TreeLinkNode(7);
		bstOss << "PopulatingNextRightPtr PerfectBST:" << std::endl;
		PopulatingNextRightPtr().Connect_PerfectBST(pnrpRootPerf);
		PrintBinaryTree<PopulatingNextRightPtr::TreeLinkNode, std::ostringstream>(pnrpRootPerf, bstOss);
		bstOss << "PopulatingNextRightPtr NonPerfectBST1:" << std::endl;
		PopulatingNextRightPtr().Connect_NonPerfectBST1(pnrpRootNPerf);
		PrintBinaryTree<PopulatingNextRightPtr::TreeLinkNode, std::ostringstream>(pnrpRootNPerf, bstOss);
		bstOss << "PopulatingNextRightPtr NonPerfectBST2:" << std::endl;
		PopulatingNextRightPtr().Connect_NonPerfectBST1(pnrpRootNPerf2);
		PrintBinaryTree<PopulatingNextRightPtr::TreeLinkNode, std::ostringstream>(pnrpRootNPerf2, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		PopulatingNextRightPtr::DeleteTree(pnrpRootPerf);
		PopulatingNextRightPtr::DeleteTree(pnrpRootNPerf);
		PopulatingNextRightPtr::DeleteTree(pnrpRootNPerf2);
	}
    {
        BinaryTreePreOrderSucc::TreeNode * btisRoot = new BinaryTreePreOrderSucc::TreeNode(6);
        btisRoot->left = new BinaryTreePreOrderSucc::TreeNode(2);
        btisRoot->left->parent = btisRoot;
        btisRoot->left->right = new BinaryTreePreOrderSucc::TreeNode(3);
        btisRoot->left->right->parent = btisRoot->left;
        btisRoot->right = new BinaryTreePreOrderSucc::TreeNode(8);
        btisRoot->right->parent = btisRoot;
        btisRoot->right->left = new BinaryTreePreOrderSucc::TreeNode(7);
        btisRoot->right->left->parent = btisRoot->right;
        BinaryTreePreOrderSucc().Find_BST_Only(btisRoot, btisRoot->left->right);
        BinaryTreePreOrderSucc().Find_BST_Only(btisRoot, btisRoot->right);
        BinaryTreePreOrderSucc().Find_BST_Only(btisRoot, btisRoot->right->left);
        PrintBinaryTree<BinaryTreePreOrderSucc::TreeNode, std::ostringstream>(btisRoot, bstOss);
        std::cout << bstOss.str() << std::endl;
        bstOss.str(std::string());
        BinaryTreePreOrderSucc::DeleteTree(btisRoot);
    }
	{
		BinaryTreeInorderSucc::TreeNode * btisRoot = new BinaryTreeInorderSucc::TreeNode(6);
		btisRoot->left = new BinaryTreeInorderSucc::TreeNode(2);
		btisRoot->left->parent = btisRoot;
		btisRoot->left->right = new BinaryTreeInorderSucc::TreeNode(3);
		btisRoot->left->right->parent = btisRoot->left;
		btisRoot->right = new BinaryTreeInorderSucc::TreeNode(8);
		btisRoot->right->parent = btisRoot;
		btisRoot->right->left = new BinaryTreeInorderSucc::TreeNode(7);
		btisRoot->right->left->parent = btisRoot->right;
		BinaryTreeInorderSucc().Find_WParentPtr(btisRoot->left->right);
		BinaryTreeInorderSucc().Find_WParentPtr(btisRoot->right);
		BinaryTreeInorderSucc().Find_BST_Only(btisRoot, btisRoot->left->right);
		BinaryTreeInorderSucc().Find_BST_Only(btisRoot, btisRoot->right);
		PrintBinaryTree<BinaryTreeInorderSucc::TreeNode, std::ostringstream>(btisRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		BinaryTreeInorderSucc::DeleteTree(btisRoot);
	}
	{
		BinaryTreePostOrderSucc::TreeNode * btpsRoot = new BinaryTreePostOrderSucc::TreeNode(7);
		btpsRoot->left = new BinaryTreePostOrderSucc::TreeNode(3);
		btpsRoot->left->parent = btpsRoot;
		btpsRoot->left->left = new BinaryTreePostOrderSucc::TreeNode(1);
		btpsRoot->left->left->parent = btpsRoot->left;
		btpsRoot->left->left->left = new BinaryTreePostOrderSucc::TreeNode(0);
		btpsRoot->left->left->left->parent = btpsRoot->left->left;
		btpsRoot->left->left->right = new BinaryTreePostOrderSucc::TreeNode(2);
		btpsRoot->left->left->right->parent = btpsRoot->left->left;
		btpsRoot->left->right = new BinaryTreePostOrderSucc::TreeNode(5);
		btpsRoot->left->right->parent = btpsRoot->left;
		btpsRoot->left->right->left = new BinaryTreePostOrderSucc::TreeNode(4);
		btpsRoot->left->right->left->parent = btpsRoot->left->right;
		btpsRoot->left->right->right = new BinaryTreePostOrderSucc::TreeNode(6);
		btpsRoot->left->right->right->parent = btpsRoot->left->right;
		btpsRoot->right = new BinaryTreePostOrderSucc::TreeNode(11);
		btpsRoot->right->parent = btpsRoot;
		btpsRoot->right->left = new BinaryTreePostOrderSucc::TreeNode(9);
		btpsRoot->right->left->parent = btpsRoot->right;
		btpsRoot->right->left->left = new BinaryTreePostOrderSucc::TreeNode(8);
		btpsRoot->right->left->left->parent = btpsRoot->right->left;
		btpsRoot->right->left->right = new BinaryTreePostOrderSucc::TreeNode(10);
		btpsRoot->right->left->right->parent = btpsRoot->right->left;
		btpsRoot->right->right = new BinaryTreePostOrderSucc::TreeNode(13);
		btpsRoot->right->right->parent = btpsRoot->right;
		btpsRoot->right->right->left = new BinaryTreePostOrderSucc::TreeNode(12);
		btpsRoot->right->right->left->parent = btpsRoot->right->right;
		btpsRoot->right->right->right = new BinaryTreePostOrderSucc::TreeNode(14);
		btpsRoot->right->right->right->parent = btpsRoot->right->right;
		BinaryTreePostOrderSucc().Find_WParentPtr(btpsRoot->left);
		BinaryTreePostOrderSucc().Find_WParentPtr(btpsRoot->left->right->left);
		BinaryTreePostOrderSucc().Find_WParentPtr(btpsRoot->right->left);
		BinaryTreePostOrderSucc().Find_BST_Only(btpsRoot, btpsRoot->left);
		BinaryTreePostOrderSucc().Find_BST_Only(btpsRoot, btpsRoot->left->right->left);
		BinaryTreePostOrderSucc().Find_BST_Only(btpsRoot, btpsRoot->right->left);
		PrintBinaryTree<BinaryTreePostOrderSucc::TreeNode, std::ostringstream>(btpsRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		BinaryTreePostOrderSucc::DeleteTree(btpsRoot);
	}
	{
		LowestCommonAncestorBinaryTree::TreeNode * lcabtRoot = new LowestCommonAncestorBinaryTree::TreeNode(7);
		lcabtRoot->left = new LowestCommonAncestorBinaryTree::TreeNode(3);
		lcabtRoot->left->parent = lcabtRoot;
		lcabtRoot->left->left = new LowestCommonAncestorBinaryTree::TreeNode(1);
		lcabtRoot->left->left->parent = lcabtRoot->left;
		lcabtRoot->left->left->left = new LowestCommonAncestorBinaryTree::TreeNode(0);
		lcabtRoot->left->left->left->parent = lcabtRoot->left->left;
		lcabtRoot->left->left->right = new LowestCommonAncestorBinaryTree::TreeNode(2);
		lcabtRoot->left->left->right->parent = lcabtRoot->left->left;
		lcabtRoot->left->right = new LowestCommonAncestorBinaryTree::TreeNode(5);
		lcabtRoot->left->right->parent = lcabtRoot->left;
		lcabtRoot->left->right->left = new LowestCommonAncestorBinaryTree::TreeNode(4);
		lcabtRoot->left->right->left->parent = lcabtRoot->left->right;
		lcabtRoot->left->right->right = new LowestCommonAncestorBinaryTree::TreeNode(6);
		lcabtRoot->left->right->right->parent = lcabtRoot->left->right;
		lcabtRoot->right = new LowestCommonAncestorBinaryTree::TreeNode(11);
		lcabtRoot->right->parent = lcabtRoot;
		lcabtRoot->right->left = new LowestCommonAncestorBinaryTree::TreeNode(9);
		lcabtRoot->right->left->parent = lcabtRoot->right;
		lcabtRoot->right->left->left = new LowestCommonAncestorBinaryTree::TreeNode(8);
		lcabtRoot->right->left->left->parent = lcabtRoot->right->left;
		lcabtRoot->right->left->right = new LowestCommonAncestorBinaryTree::TreeNode(10);
		lcabtRoot->right->left->right->parent = lcabtRoot->right->left;
		lcabtRoot->right->right = new LowestCommonAncestorBinaryTree::TreeNode(13);
		lcabtRoot->right->right->parent = lcabtRoot->right;
		lcabtRoot->right->right->left = new LowestCommonAncestorBinaryTree::TreeNode(12);
		lcabtRoot->right->right->left->parent = lcabtRoot->right->right;
		lcabtRoot->right->right->right = new LowestCommonAncestorBinaryTree::TreeNode(14);
		lcabtRoot->right->right->right->parent = lcabtRoot->right->right;
		LowestCommonAncestorBinaryTree().Find_Recur(lcabtRoot, 4, 3);
		LowestCommonAncestorBinaryTree().Find_Recur(lcabtRoot, 4, 5);
		LowestCommonAncestorBinaryTree().Find_Recur(lcabtRoot, 4, 7);
		LowestCommonAncestorBinaryTree().Find_Recur(lcabtRoot, 4, 4);
		LowestCommonAncestorBinaryTree().Find_Recur(lcabtRoot, lcabtRoot->right->left->left, lcabtRoot->right->left);
		LowestCommonAncestorBinaryTree().Find_Recur(lcabtRoot, lcabtRoot->right->left->left, lcabtRoot->right->right);
		LowestCommonAncestorBinaryTree().Find_Iterate_WParentPtr(lcabtRoot->right->left->left, lcabtRoot->right->left);
		LowestCommonAncestorBinaryTree().Find_Iterate_WParentPtr(lcabtRoot->right->left->left, lcabtRoot->right->right);
		LowestCommonAncestorBinaryTree().Find_IterateHashTable_WParentPtr(lcabtRoot->right->left->left, lcabtRoot->right->left);
		LowestCommonAncestorBinaryTree().Find_IterateHashTable_WParentPtr(lcabtRoot->right->left->left, lcabtRoot->right->right);
		LowestCommonAncestorBinaryTree().Find_IterateStack_WParentPtr(lcabtRoot->right->left->left, lcabtRoot->right->left);
		LowestCommonAncestorBinaryTree().Find_IterateStack_WParentPtr(lcabtRoot->right->left->left, lcabtRoot->right->right);
		PrintBinaryTree<LowestCommonAncestorBinaryTree::TreeNode, std::ostringstream>(lcabtRoot, bstOss);
		LowestCommonAncestorBinaryTree().Find_XOR2PathSum(lcabtRoot, lcabtRoot->right->left->left, lcabtRoot->right->left);
		LowestCommonAncestorBinaryTree().Find_XOR2PathSum(lcabtRoot, lcabtRoot->right->left->left, lcabtRoot->right->right);
		PrintBinaryTree<LowestCommonAncestorBinaryTree::TreeNode, std::ostringstream>(lcabtRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		LowestCommonAncestorBinaryTree::DeleteTree(lcabtRoot);
	}
	{
		LowestCommonAncestorBinarySearchTree::TreeNode * root = new LowestCommonAncestorBinarySearchTree::TreeNode(5);
		root->left = new LowestCommonAncestorBinarySearchTree::TreeNode(2);
		root->left->left = new LowestCommonAncestorBinarySearchTree::TreeNode(0);
		root->left->left->right = new LowestCommonAncestorBinarySearchTree::TreeNode(1);
		root->left->right = new LowestCommonAncestorBinarySearchTree::TreeNode(3);
		root->left->right->right = new LowestCommonAncestorBinarySearchTree::TreeNode(4);
		root->right = new LowestCommonAncestorBinarySearchTree::TreeNode(8);
		root->right->left = new LowestCommonAncestorBinarySearchTree::TreeNode(6);
		root->right->left->right = new LowestCommonAncestorBinarySearchTree::TreeNode(7);
		root->right->right = new LowestCommonAncestorBinarySearchTree::TreeNode(9);
		root->right->right->right = new LowestCommonAncestorBinarySearchTree::TreeNode(10);
		LowestCommonAncestorBinarySearchTree().Find_Recur(root, 1, 4);
		LowestCommonAncestorBinarySearchTree().Find_Recur(root, 7, 8);
		LowestCommonAncestorBinarySearchTree().Find_Recur(root, 3, 11);
		LowestCommonAncestorBinarySearchTree().Find_Recur(root, 7, 7);
		PrintBinaryTree<LowestCommonAncestorBinarySearchTree::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		LowestCommonAncestorBinarySearchTree::DeleteTree(root);
	}
	{
		//TwoSum().GO_SortScan(std::vector<int>({ -11, -8, -5, 2, 6, 8, 13, 15, 20, 23, 24 }), -13);
		//TwoSum().GO_SortScan(std::vector<int>({ -11, -8, -5, 2, 6, 8, 13, 15, 20, 23, 24 }), 0);
		//TwoSum().GO_SortScan(std::vector<int>({ -11, -8, -5, 2, 6, 8, 13, 15, 20, 23, 24 }), 39);
		//TwoSum().GO_SortScan(std::vector<int>({ -11, -8, -5, 2, 6, 8, 13, 15, 20, 23, 24 }), 11);
		TwoSumBinarySearchTree::TreeNode * tsbstRoot = new TwoSumBinarySearchTree::TreeNode(8);
		tsbstRoot->left = new TwoSumBinarySearchTree::TreeNode(-5);
		tsbstRoot->left->left = new TwoSumBinarySearchTree::TreeNode(-11);
		tsbstRoot->left->left->right = new TwoSumBinarySearchTree::TreeNode(-8);
		tsbstRoot->left->right = new TwoSumBinarySearchTree::TreeNode(2);
		tsbstRoot->left->right->right = new TwoSumBinarySearchTree::TreeNode(6);
		tsbstRoot->right = new TwoSumBinarySearchTree::TreeNode(20);
		tsbstRoot->right->left = new TwoSumBinarySearchTree::TreeNode(13);
		tsbstRoot->right->left->right = new TwoSumBinarySearchTree::TreeNode(15);
		tsbstRoot->right->right = new TwoSumBinarySearchTree::TreeNode(23);
		tsbstRoot->right->right->right = new TwoSumBinarySearchTree::TreeNode(24);
		TwoSumBinarySearchTree().Greedy(tsbstRoot, -13);
		TwoSumBinarySearchTree().Greedy(tsbstRoot, 0);
		TwoSumBinarySearchTree().Greedy(tsbstRoot, 39);
		TwoSumBinarySearchTree().Greedy(tsbstRoot, 11);
		PrintBinaryTree<TwoSumBinarySearchTree::TreeNode, std::ostringstream>(tsbstRoot, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		TwoSumBinarySearchTree::DeleteTree(tsbstRoot);
	}
	{
		Merge2BalancedBinarySearchTree::TreeNode * root1 = new Merge2BalancedBinarySearchTree::TreeNode(100);
		root1->left = new Merge2BalancedBinarySearchTree::TreeNode(50);
		root1->left->left = new Merge2BalancedBinarySearchTree::TreeNode(20);
		root1->left->right = new Merge2BalancedBinarySearchTree::TreeNode(70);
		root1->right = new Merge2BalancedBinarySearchTree::TreeNode(300);
		Merge2BalancedBinarySearchTree::TreeNode * root2 = new Merge2BalancedBinarySearchTree::TreeNode(80);
		root2->left = new Merge2BalancedBinarySearchTree::TreeNode(40);
		root2->right = new Merge2BalancedBinarySearchTree::TreeNode(120);
		bstOss << "Merge2BalancedBinarySearchTree root1, root2, merged, merged2:" << std::endl;
		PrintBinaryTree<Merge2BalancedBinarySearchTree::TreeNode, std::ostringstream>(root1, bstOss);
		PrintBinaryTree<Merge2BalancedBinarySearchTree::TreeNode, std::ostringstream>(root2, bstOss);
		Merge2BalancedBinarySearchTree::TreeNode * merged = Merge2BalancedBinarySearchTree().NewBST_From2SortedArrays(root1, root2);
		Merge2BalancedBinarySearchTree::TreeNode * merged2 = Merge2BalancedBinarySearchTree().InPlace_FromMerged2SortedDoublyLinkedLists(root1, root2);
		PrintBinaryTree<Merge2BalancedBinarySearchTree::TreeNode, std::ostringstream>(merged, bstOss);
		PrintBinaryTree<Merge2BalancedBinarySearchTree::TreeNode, std::ostringstream>(merged2, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		Merge2BalancedBinarySearchTree::DeleteTree(merged);
		Merge2BalancedBinarySearchTree::DeleteTree(merged2);
	}
	{
		ConvertBSTtoCircularDoublyLinkedList::TreeNode * root = new ConvertBSTtoCircularDoublyLinkedList::TreeNode(5);
		root->left = new ConvertBSTtoCircularDoublyLinkedList::TreeNode(2);
		root->left->left = new ConvertBSTtoCircularDoublyLinkedList::TreeNode(0);
		root->left->left->right = new ConvertBSTtoCircularDoublyLinkedList::TreeNode(1);
		root->left->right = new ConvertBSTtoCircularDoublyLinkedList::TreeNode(3);
		root->left->right->right = new ConvertBSTtoCircularDoublyLinkedList::TreeNode(4);
		root->right = new ConvertBSTtoCircularDoublyLinkedList::TreeNode(8);
		root->right->left = new ConvertBSTtoCircularDoublyLinkedList::TreeNode(6);
		root->right->left->right = new ConvertBSTtoCircularDoublyLinkedList::TreeNode(7);
		root->right->right = new ConvertBSTtoCircularDoublyLinkedList::TreeNode(9);
		root->right->right->right = new ConvertBSTtoCircularDoublyLinkedList::TreeNode(10);
		bstOss << "ConvertBSTtoCircularDoublyLinkedList and CircularDoublyLinkedListToBST and CircularDoublyLinkedListToReversedBST:" << std::endl;
		PrintBinaryTree<ConvertBSTtoCircularDoublyLinkedList::TreeNode, std::ostringstream>(root, bstOss);
		ConvertBSTtoCircularDoublyLinkedList::TreeNode * head = ConvertBSTtoCircularDoublyLinkedList().InPlaceTreeToListPostorderRecur(root);
		PrintLinkedList<ConvertBSTtoCircularDoublyLinkedList::TreeNode, std::ostringstream>(head, bstOss);
		root = ConvertBSTtoCircularDoublyLinkedList().InPlaceListToTreeInorderRecur(head);
		PrintBinaryTree<ConvertBSTtoCircularDoublyLinkedList::TreeNode, std::ostringstream>(root, bstOss);

		head = ConvertBSTtoCircularDoublyLinkedList().InPlaceTreeToListPostorderRecur(root);
		root = ConvertBSTtoCircularDoublyLinkedList().InPlaceListToReversedTreeInorderRecur(head);
		PrintBinaryTree<ConvertBSTtoCircularDoublyLinkedList::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConvertBSTtoCircularDoublyLinkedList::DeleteTree(root);
	}
	{
		KdTree t(2, std::vector<std::vector<int>>({ { 38, 23 }, { 40, 26 }, { 29, 16 }, { 30, 11 }, { 27, 28 }, { 31, 85 }, { 7, 39 }, { 15, 61 }, { 32, 29 }, { 53, 14 },
		{ 70, 3 }, { 67, 51 }, { 99, 90 }, { 82, 64 }, { 73, 75 } }));
		t.Print();
		t.FindRange(std::vector<int>({ 13, 34 }), std::vector<int>({ 76, 80 }));
		t.FindRange(std::vector<int>({ 50, 50 }), 50.0);
		t.FindRange(std::vector<int>({ 50, 50 }), 26.0);
		t.FindRange(std::vector<int>({ 50, 50 }), 18.0);
		t.FindRange(std::vector<int>({ 50, 50 }), 5.0);
		t.FindNearest(std::vector<int>({ 50, 50 }));
		t.FindNearest(std::vector<int>({ 39, 24 }));
		t.FindNearest(std::vector<int>({ 41, 25 }));
		t.FindNearest(std::vector<int>({ 73, 75 }));

		t.Insert(std::vector<int>({ 7,39 }));
		t.Insert(std::vector<int>({ 27,28 }));
		t.Insert(std::vector<int>({ 29,16 }));
		t.Print();
		t.Remove(std::vector<int>({ 99,90 }));
		t.Print();
		t.Remove(std::vector<int>({ 29,16 }));
		t.Print();
		t.Remove(std::vector<int>({ 27,28 }));
		t.Print();
		t.Remove(std::vector<int>({ 38,23 }));
		t.Print();
	}
	{
		BinarySearchTree t(std::vector<int>({ 50, 90, 15, 70, 10, 23, 64, 32, 77, 7, 95, 32, 13, 13, 13, 18, 96, 92, 70, 70, 96, 96, 23, 32, 23, 8, 9, 4, 14, 14, 3, 5, 8
			, 73, 77, 79, 83, 17, 16, 37, 47, 55, 58, 71, 92, 78, 92, 97, 95, 95, 97, 99, 33, 51 }));
		t.Print();
		BinarySearchTree::TreeNode * clone1 = t.Clone();
		BinarySearchTree::DeleteTreeIterate(clone1);
		BinarySearchTree::TreeNode * clone2 = t.CloneMirror();
		BinarySearchTree::DeleteTreeIterate(clone2);
		BinarySearchTree::TreeNode * a = t.FindLowerBound(70);
		t.FindLowerBound(60);
		t.FindLowerBound(23);
		t.FindLowerBound(79);
		BinarySearchTree::TreeNode * b = t.FindUpperBound(70);
		t.FindUpperBound(60);
		t.FindUpperBound(9);
		t.FindUpperBound(15);
		t.FindUpperBound(79);
		t.FindUpperBound(83);
		t.FindUpperBound(23);
		t.FindUpperBound(32);
		t.FindUpperBound(55);
		t.FindUpperBound(47);
		t.FindUpperBound(70);
		t.FindUpperBound(83);
		t.FindUpperBound(99);
		t.FindLCA(a, b);
		t.FindKthNode(5);
		t.FindKthNode(13);
		t.FindCeil(17);
		t.FindCeil(65);
		t.FindCeil(89);
		t.FindCeil(87);
		t.FindCeil(12);
		t.FindCeil(22);
		t.FindCeil(31);
		t.FindCeil(69);
		t.FindFloor(89);
		t.FindFloor(70);
		t.FindFloor(6);
		t.FindFloor(19);
		t.FindFloor(12);
		t.FindFloor(22);
		t.FindFloor(31);
		t.FindFloor(69);
		t.FindRange(13, 70);
		t.CountRange(13, 70);
		t.CountRange(11, 75);
		t.CountSmallerEntries(96);
		t.CountSmallerEqualEntries(96);
		t.CountSmallerEntries(23);
		t.CountSmallerEqualEntries(32);
		t.CountSmallerEntries(15);
		t.CountSmallerEqualEntries(15);
		t.CountSmallerEntries(10);
		t.CountSmallerEqualEntries(10);
		t.CountSmallerEntries(13);
		t.CountSmallerEqualEntries(13);
		t.CountSmallerEntries(70);
		t.CountSmallerEqualEntries(70);
		t.CountSmallerEntries(65);
		t.CountSmallerEqualEntries(65);
		t.FindKLargest(9);
		t.FindMax();
		t.FindMin();
		t.GetRank(13);
		t.GetRank(15);
		t.GetRank(70);
		t.GetRank(86);
		t.GetRank(96);
		t.GetRank(33);
		t.Remove(15);
		t.Print();
		t.Remove(50);
		t.Print();
		t.Remove(70);
		t.Print();
		t.Remove(70);
		t.Print();
		t.Remove(51);
		t.Print();
		t.Remove(90);
		t.Print();
		t.MakeEmpty();
	}
	{
		AVLTree t(std::vector<int>({ 10, 85, 15, 70, 20, 60, 30, 50, 65, 80, 90, 40, 5, 55 }));
		t.Print();
		t.FindMax();
		t.FindMin();
		t.Remove(50);
		t.Print();
		t.MakeEmpty();
	}
	{
		SplayTree t(std::vector<int>({ 50, 85, 15, 70, 10, 23, 64, 32, 77 }));
		t.Print();
		t.FindMax();
		t.FindMin();
		t.Contains(70);
		t.Print();
		t.Contains(32);
		t.Print();
		t.Contains(63);
		t.Print();
		t.Contains(14);
		t.Print();
		t.Remove(23);
		t.Print();
		t.MakeEmptyRecur();
	}
	{
		RedBlackTree t(-99, std::vector<int>({ 10, 85, 15, 70, 20, 60, 30, 50, 65, 80, 90, 40, 5, 55 }));
		t.Print();
		t.FindMax();
		t.FindMin();
		t.Remove_ButtomUpRecur(60);
		//t.Print();
	}
	{
		AATree t(std::vector<int>({ 10, 85, 15, 70, 20, 60, 30, 50, 65, 80, 90, 40 }));
		t.Print();
		t.FindMax();
		t.FindMin();
		t.Remove(50);
		t.Print();
		t.MakeEmpty();
	}
	{
		LargestIndependentSetBinaryTree::TreeNode * root1 = new LargestIndependentSetBinaryTree::TreeNode(10);
		root1->left = new LargestIndependentSetBinaryTree::TreeNode(20);
		root1->left->left = new LargestIndependentSetBinaryTree::TreeNode(40);
		root1->left->right = new LargestIndependentSetBinaryTree::TreeNode(50);
		root1->left->right->left = new LargestIndependentSetBinaryTree::TreeNode(70);
		root1->left->right->right = new LargestIndependentSetBinaryTree::TreeNode(80);
		root1->right = new LargestIndependentSetBinaryTree::TreeNode(30);
		root1->right->right = new LargestIndependentSetBinaryTree::TreeNode(60);
		LargestIndependentSetBinaryTree().Recur(root1);
		PrintBinaryTree<LargestIndependentSetBinaryTree::TreeNode, std::ostringstream>(root1, bstOss);
		LargestIndependentSetBinaryTree().DP_Recur(root1);
		PrintBinaryTree<LargestIndependentSetBinaryTree::TreeNode, std::ostringstream>(root1, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		LargestIndependentSetBinaryTree::DeleteTree(root1);
	}
	{
		OptimalBinarySearchTree().Cost_Recur(std::vector<int>({ 10, 12, 20 }));
		OptimalBinarySearchTree().Cost_DP2D(std::vector<int>({ 10, 12, 20 }));
		OptimalBinarySearchTree().Cost_Recur(std::vector<int>({ 34, 8, 50 }));
		OptimalBinarySearchTree().Cost_DP2D(std::vector<int>({ 34, 8, 50 }));
	}
	{
		KBalancedNodesBinaryTree::TreeNode * root = new KBalancedNodesBinaryTree::TreeNode(34);
		root->left = new KBalancedNodesBinaryTree::TreeNode(6);
		root->left->left = new KBalancedNodesBinaryTree::TreeNode(27);
		root->left->left->left = new KBalancedNodesBinaryTree::TreeNode(28);
		root->left->left->right = new KBalancedNodesBinaryTree::TreeNode(0);
		root->left->right = new KBalancedNodesBinaryTree::TreeNode(56);
		root->left->right->right = new KBalancedNodesBinaryTree::TreeNode(3);
		root->left->right->right->left = new KBalancedNodesBinaryTree::TreeNode(17);
		root->right = new KBalancedNodesBinaryTree::TreeNode(6);
		root->right->left = new KBalancedNodesBinaryTree::TreeNode(32);
		root->right->left->right = new KBalancedNodesBinaryTree::TreeNode(1);
		root->right->left->right->left = new KBalancedNodesBinaryTree::TreeNode(41);
		root->right->left->right->left->right = new KBalancedNodesBinaryTree::TreeNode(64);
		root->right->left->right->right = new KBalancedNodesBinaryTree::TreeNode(27);
		root->right->right = new KBalancedNodesBinaryTree::TreeNode(21);
		root->right->right->right = new KBalancedNodesBinaryTree::TreeNode(28);
		PrintBinaryTree<KBalancedNodesBinaryTree::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		KBalancedNodesBinaryTree().FindKUnbalancedNode(root, 3);
		KBalancedNodesBinaryTree::DeleteTree(root);
	}
	{
		SumRootToLeafBinaryNumBinaryTree::TreeNode * root = new SumRootToLeafBinaryNumBinaryTree::TreeNode(1);
		root->left = new SumRootToLeafBinaryNumBinaryTree::TreeNode(0);
		root->left->left = new SumRootToLeafBinaryNumBinaryTree::TreeNode(0);
		root->left->left->left = new SumRootToLeafBinaryNumBinaryTree::TreeNode(0);
		root->left->left->right = new SumRootToLeafBinaryNumBinaryTree::TreeNode(1);
		root->left->right = new SumRootToLeafBinaryNumBinaryTree::TreeNode(1);
		root->left->right->right = new SumRootToLeafBinaryNumBinaryTree::TreeNode(1);
		root->left->right->right->left = new SumRootToLeafBinaryNumBinaryTree::TreeNode(0);
		root->right = new SumRootToLeafBinaryNumBinaryTree::TreeNode(1);
		root->right->left = new SumRootToLeafBinaryNumBinaryTree::TreeNode(0);
		root->right->left->right = new SumRootToLeafBinaryNumBinaryTree::TreeNode(0);
		root->right->left->right->left = new SumRootToLeafBinaryNumBinaryTree::TreeNode(1);
		root->right->left->right->left->right = new SumRootToLeafBinaryNumBinaryTree::TreeNode(1);
		root->right->left->right->right = new SumRootToLeafBinaryNumBinaryTree::TreeNode(0);
		root->right->right = new SumRootToLeafBinaryNumBinaryTree::TreeNode(0);
		root->right->right->right = new SumRootToLeafBinaryNumBinaryTree::TreeNode(0);
		PrintBinaryTree<SumRootToLeafBinaryNumBinaryTree::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		SumRootToLeafBinaryNumBinaryTree().Recur(root);
		SumRootToLeafBinaryNumBinaryTree::DeleteTree(root);
	}
	{
		ExteriorNodesBinaryTree::TreeNode * root = new ExteriorNodesBinaryTree::TreeNode(34);
		root->left = new ExteriorNodesBinaryTree::TreeNode(6);
		root->left->left = new ExteriorNodesBinaryTree::TreeNode(27);
		root->left->left->left = new ExteriorNodesBinaryTree::TreeNode(28);
		root->left->left->right = new ExteriorNodesBinaryTree::TreeNode(0);
		root->left->right = new ExteriorNodesBinaryTree::TreeNode(56);
		root->left->right->right = new ExteriorNodesBinaryTree::TreeNode(3);
		root->left->right->right->left = new ExteriorNodesBinaryTree::TreeNode(17);
		root->right = new ExteriorNodesBinaryTree::TreeNode(6);
		root->right->left = new ExteriorNodesBinaryTree::TreeNode(2);
		root->right->left->right = new ExteriorNodesBinaryTree::TreeNode(1);
		root->right->left->right->left = new ExteriorNodesBinaryTree::TreeNode(41);
		root->right->left->right->left->right = new ExteriorNodesBinaryTree::TreeNode(64);
		root->right->left->right->right = new ExteriorNodesBinaryTree::TreeNode(27);
		root->right->right = new ExteriorNodesBinaryTree::TreeNode(21);
		root->right->right->right = new ExteriorNodesBinaryTree::TreeNode(28);
		PrintBinaryTree<ExteriorNodesBinaryTree::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ExteriorNodesBinaryTree().Recur(root);
		ExteriorNodesBinaryTree::DeleteTree(root);
	}
	{
		MinFirstBST t;
		t.Insert(4);
		t.Insert(11);
		t.Insert(3);
		t.Insert(2);
		t.Insert(1);
		t.Insert(3);
		t.Insert(11);
		t.Insert(17);
		t.Insert(5);
		t.Insert(4);
		t.Insert(2);
		t.Insert(3);
		t.Insert(7);
		t.Insert(18);
		t.Insert(4);
		t.Insert(19);
		t.Insert(14);
		t.Insert(17);
		t.Insert(11);
		t.Insert(9);
		t.Insert(14);
		t.Insert(11);
		t.Insert(12);
		t.Insert(13);
		t.Insert(15);
		t.Insert(15);
		t.Insert(6);
		t.Insert(5);
		t.Insert(17);
		t.Insert(17);
		t.Insert(19);
		t.Insert(18);
		t.Insert(5);
		t.Insert(4);
		t.Contains(6);
		t.Contains(9);
		t.Contains(13);
		t.Contains(15);
		t.FindLowerBound(11);
		t.FindLowerBound(17);
		t.FindLowerBound(7);
		t.FindLowerBound(2);
		t.FindUpperBound(11);
		t.FindUpperBound(17);
		t.FindUpperBound(13);
		t.FindUpperBound(5);
		t.FindUpperBound(9);
		t.FindUpperBound(7);
		t.FindUpperBound(19);
		t.FindUpperBound(6);
		t.GetSortedKeys();
		t.Print();
		t.Remove(1);
		t.Remove(17);
		t.Print();
		t.Remove(11);
		t.Remove(18);
		t.Print();
		t.Remove(4);
		t.Remove(14);
		t.Print();
		t.Remove(2);
		t.Print();
		t.Remove(11);
		t.Remove(18);
		t.Print();
		t.Remove(5);
		t.Remove(11);
		t.Print();
		t.Remove(4);
		t.Remove(11);
		t.Print();
	}
	{
		InBetweenAncestorDescendantBST::TreeNode * root = new InBetweenAncestorDescendantBST::TreeNode(19);
		root->left = new InBetweenAncestorDescendantBST::TreeNode(7);
		root->left->left = new InBetweenAncestorDescendantBST::TreeNode(3);
		root->left->left->left = new InBetweenAncestorDescendantBST::TreeNode(2);
		root->left->left->right = new InBetweenAncestorDescendantBST::TreeNode(5);
		root->left->right = new InBetweenAncestorDescendantBST::TreeNode(11);
		root->left->right->right = new InBetweenAncestorDescendantBST::TreeNode(17);
		root->left->right->right->left = new InBetweenAncestorDescendantBST::TreeNode(13);
		root->right = new InBetweenAncestorDescendantBST::TreeNode(43);
		root->right->left = new InBetweenAncestorDescendantBST::TreeNode(23);
		root->right->left->right = new InBetweenAncestorDescendantBST::TreeNode(37);
		root->right->left->right->left = new InBetweenAncestorDescendantBST::TreeNode(29);
		root->right->left->right->left->right = new InBetweenAncestorDescendantBST::TreeNode(31);
		root->right->left->right->right = new InBetweenAncestorDescendantBST::TreeNode(41);
		root->right->right = new InBetweenAncestorDescendantBST::TreeNode(47);
		root->right->right->right = new InBetweenAncestorDescendantBST::TreeNode(53);
		PrintBinaryTree<InBetweenAncestorDescendantBST::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		InBetweenAncestorDescendantBST().Valid_Iterate(root->right->left, root, root->right->left->right);
		InBetweenAncestorDescendantBST().Valid_Iterate(root->right->left, root, root->right->left->right->left->right);
		InBetweenAncestorDescendantBST().Valid_Iterate(root->right->left->right->left, root->right->left->right->left->right, root->right->left);
		InBetweenAncestorDescendantBST().Valid_Iterate(root->right->left, root->left, root->right->right);
		InBetweenAncestorDescendantBST().Valid_Iterate(root->left, root->left, root->left->right->right->left);
		InBetweenAncestorDescendantBST().Valid_Iterate(root->left->right->right->left, root->left->right->right->left, root);
		InBetweenAncestorDescendantBST().Valid_Iterate(root->left, root->left->left, root->left->right->right->left);
		InBetweenAncestorDescendantBST().Valid_Iterate(root->right->left->right->left, root->right->left, root->left->right);
		InBetweenAncestorDescendantBST().Valid_Iterate(root->right->right, root->right->right->right, root);
		InBetweenAncestorDescendantBST::DeleteTree(root);
	}
	{
        auto v = std::vector<std::pair<std::pair<char, double>, std::string>>(
        {
            { { 'a', 8.17 }, "" }, { { 'b', 1.49 }, "" }, { { 'c', 2.78 }, "" }, { { 'd', 4.25 }, "" }, { { 'e', 12.70 }, "" }, { { 'f', 2.23 }, "" },
            { { 'g', 2.02 }, "" }, { { 'h', 6.09 }, "" }, { { 'i', 6.97 }, "" }, { { 'j', 0.15 }, "" }, { { 'k', 0.77 }, "" }, { { 'l', 4.03 }, "" },
            { { 'm', 2.41 }, "" }, { { 'n', 6.75 }, "" }, { { 'o', 7.51 }, "" }, { { 'p', 1.93 }, "" }, { { 'q', 0.10 }, "" }, { { 'r', 5.99 }, "" },
            { { 's', 6.33 }, "" }, { { 't', 9.06 }, "" }, { { 'u', 2.76 }, "" }, { { 'v', 0.98 }, "" }, { { 'w', 2.36 }, "" }, { { 'x', 0.15 }, "" },
            { { 'y', 1.97 }, "" }, { { 'z', 0.07 }, "" }
        });
		HuffmanCoding().Encode(v);
	}
	{
		ConnectBinaryTreeLeaves::TreeNode * cbt = new ConnectBinaryTreeLeaves::TreeNode(0);
		cbt->left = new ConnectBinaryTreeLeaves::TreeNode(1);
		cbt->left->left = new ConnectBinaryTreeLeaves::TreeNode(2);
		cbt->left->left->left = new ConnectBinaryTreeLeaves::TreeNode(3);
		cbt->left->right = new ConnectBinaryTreeLeaves::TreeNode(4);
		cbt->left->right->left = new ConnectBinaryTreeLeaves::TreeNode(5);
		cbt->right = new ConnectBinaryTreeLeaves::TreeNode(6);
		cbt->right->left = new ConnectBinaryTreeLeaves::TreeNode(7);
		cbt->right->left->right = new ConnectBinaryTreeLeaves::TreeNode(8);
		cbt->right->right = new ConnectBinaryTreeLeaves::TreeNode(9);
		cbt->right->right->left = new ConnectBinaryTreeLeaves::TreeNode(10);
		PrintBinaryTree<ConnectBinaryTreeLeaves::TreeNode, std::ostringstream>(cbt, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		ConnectBinaryTreeLeaves().Recur(cbt);
		ConnectBinaryTreeLeaves::DeleteTree(cbt);
	}
	{
		BSTIterator::TreeNode * r = new BSTIterator::TreeNode(8);
		r->left = new BSTIterator::TreeNode(4);
		r->left->left = new BSTIterator::TreeNode(2);
		r->left->left->left = new BSTIterator::TreeNode(1);
		r->left->left->right = new BSTIterator::TreeNode(3);
		r->left->right = new BSTIterator::TreeNode(6);
		r->left->right->left = new BSTIterator::TreeNode(5);
		r->left->right->right = new BSTIterator::TreeNode(7);
		r->right = new BSTIterator::TreeNode(12);
		r->right->left = new BSTIterator::TreeNode(10);
		r->right->left->left = new BSTIterator::TreeNode(9);
		r->right->left->right = new BSTIterator::TreeNode(11);
		r->right->right = new BSTIterator::TreeNode(14);
		r->right->right->left = new BSTIterator::TreeNode(13);
		r->right->right->right = new BSTIterator::TreeNode(15);
		PrintBinaryTree<BSTIterator::TreeNode, std::ostringstream>(r, bstOss);
		bstOss << "BSTIterator for above tree: ";
		BSTIterator itr(r);
		while (itr.HasNext())
			bstOss << itr.Next()->val << ",";
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		BSTIterator::DeleteTree(r);
	}
	{
		BinaryTreeUpsideDown::TreeNode * r = new BinaryTreeUpsideDown::TreeNode(1);
		r->left = new BinaryTreeUpsideDown::TreeNode(2);
		r->left->left = new BinaryTreeUpsideDown::TreeNode(4);
		r->left->right = new BinaryTreeUpsideDown::TreeNode(5);
		r->right = new BinaryTreeUpsideDown::TreeNode(3);
		PrintBinaryTree<BinaryTreeUpsideDown::TreeNode, std::ostringstream>(r, bstOss);
		bstOss << "BinaryTreeUpsideDown Recur for above tree: " << std::endl;
		BinaryTreeUpsideDown::TreeNode * res = BinaryTreeUpsideDown().Recur(r);
		PrintBinaryTree<BinaryTreeUpsideDown::TreeNode, std::ostringstream>(res, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		BinaryTreeUpsideDown::DeleteTree(res);

		r = new BinaryTreeUpsideDown::TreeNode(1);
		r->left = new BinaryTreeUpsideDown::TreeNode(2);
		r->left->left = new BinaryTreeUpsideDown::TreeNode(4);
		r->left->right = new BinaryTreeUpsideDown::TreeNode(5);
		r->right = new BinaryTreeUpsideDown::TreeNode(3);
		PrintBinaryTree<BinaryTreeUpsideDown::TreeNode, std::ostringstream>(r, bstOss);
		bstOss << "BinaryTreeUpsideDown Iterate for above tree: " << std::endl;
		res = BinaryTreeUpsideDown().Iterate2(r);
		PrintBinaryTree<BinaryTreeUpsideDown::TreeNode, std::ostringstream>(res, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		BinaryTreeUpsideDown::DeleteTree(res);
	}
	{
		BinaryTreeRightSideView::TreeNode * r = new BinaryTreeRightSideView::TreeNode(1);
		r->left = new BinaryTreeRightSideView::TreeNode(2);
		r->left->right = new BinaryTreeRightSideView::TreeNode(5);
		r->left->right->left = new BinaryTreeRightSideView::TreeNode(6);
		r->left->right->right = new BinaryTreeRightSideView::TreeNode(7);
		r->left->right->left->left = new BinaryTreeRightSideView::TreeNode(8);
		r->right = new BinaryTreeRightSideView::TreeNode(3);
		r->right->right = new BinaryTreeRightSideView::TreeNode(4);
		PrintBinaryTree<BinaryTreeRightSideView::TreeNode, std::ostringstream>(r, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		BinaryTreeRightSideView().BFS(r);
		BinaryTreeRightSideView().DFS(r);
		BinaryTreeRightSideView::DeleteTree(r);
	}
	{
		InvertBinaryTree::TreeNode * root = new InvertBinaryTree::TreeNode(7);
		root->left = new InvertBinaryTree::TreeNode(3);
		root->left->left = new InvertBinaryTree::TreeNode(1);
		//root->left->left->left = new InvertBinaryTree::TreeNode(0);
		root->left->left->right = new InvertBinaryTree::TreeNode(2);
		root->left->right = new InvertBinaryTree::TreeNode(5);
		//root->left->right->left = new InvertBinaryTree::TreeNode(4);
		root->left->right->right = new InvertBinaryTree::TreeNode(6);
		root->right = new InvertBinaryTree::TreeNode(11);
		root->right->left = new InvertBinaryTree::TreeNode(9);
		//root->right->left->left = new InvertBinaryTree::TreeNode(8);
		root->right->left->right = new InvertBinaryTree::TreeNode(10);
		root->right->right = new InvertBinaryTree::TreeNode(13);
		root->right->right->left = new InvertBinaryTree::TreeNode(12);
		//root->right->right->right = new InvertBinaryTree::TreeNode(14);
		PrintBinaryTree<InvertBinaryTree::TreeNode, std::ostringstream>(root, bstOss);
		bstOss << "InvertBinaryTree Recur for above tree:" << std::endl;
		root = InvertBinaryTree().Recur(root);
		PrintBinaryTree<InvertBinaryTree::TreeNode, std::ostringstream>(root, bstOss);
		bstOss << "InvertBinaryTree IterateWQueue for above tree:" << std::endl;
		root = InvertBinaryTree().IterateWQueue(root);
		PrintBinaryTree<InvertBinaryTree::TreeNode, std::ostringstream>(root, bstOss);
		bstOss << "InvertBinaryTree IterateWStack for above tree:" << std::endl;
		root = InvertBinaryTree().IterateWStack(root);
		PrintBinaryTree<InvertBinaryTree::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		bstOss.str(std::string());
		InvertBinaryTree::DeleteTree(root);
	}
	{
		VerifyPreOrderTraversalBinaryTree().IterateWStack(std::string("1,#,#,#,#"));
		VerifyPreOrderTraversalBinaryTree().ConstSpace(std::string("1,#,#,#,#"));
		VerifyPreOrderTraversalBinaryTree().IterateWStack2(std::string("1,#,#,#,#"));
		VerifyPreOrderTraversalBinaryTree().ConstSpace2(std::string("1,#,#,#,#"));

		VerifyPreOrderTraversalBinaryTree().IterateWStack(std::string("196,233,345,#,#,11,#,#,22,#,565,#,#"));
		VerifyPreOrderTraversalBinaryTree().ConstSpace(std::string("196,233,345,#,#,11,#,#,22,#,565,#,#"));
		VerifyPreOrderTraversalBinaryTree().IterateWStack2(std::string("196,233,345,#,#,11,#,#,22,#,565,#,#"));
		VerifyPreOrderTraversalBinaryTree().ConstSpace2(std::string("196,233,345,#,#,11,#,#,22,#,565,#,#"));
	}
	{
		VerifyPostOrderTraversalBinaryTree().IterateWStack(std::string("#,#,#,2,1"));
		VerifyPostOrderTraversalBinaryTree().ConstSpace(std::string("#,#,#,2,1"));

		VerifyPostOrderTraversalBinaryTree().IterateWStack(std::string("#,#,#,2,#,#,3,#,4,1"));
		VerifyPostOrderTraversalBinaryTree().ConstSpace(std::string("#,#,#,2,#,#,3,#,4,1"));

		VerifyPostOrderTraversalBinaryTree().IterateWStack(std::string("#,#,#,2,5,#,#,3,#,4,1"));
		VerifyPostOrderTraversalBinaryTree().ConstSpace(std::string("#,#,#,2,5,#,#,3,#,4,1"));
	}
	{
		VerifyLevelOrderTraversalBinaryTree().Iterate(std::string("5,1,4,#,2,3,#,#,#,#,#"));
		VerifyLevelOrderTraversalBinaryTree().Iterate(std::string("5,1,4,#,2,3,#,6,#,#,#"));
		VerifyLevelOrderTraversalBinaryTree().Iterate(std::string("5,1,#,#,2,3,#,#,#,#,#"));
	}
	{
		VerifyPreOrderTraversalBST().BruteForceRecur({ 7,3,1,0,2,5,4,6,11,9,8,10,13,12,14 });
		VerifyPreOrderTraversalBST().LinearRecur({ 7,3,1,0,2,5,4,6,11,9,8,10,13,12,14 });
		VerifyPreOrderTraversalBST().UseSortedStack({ 7,3,1,0,2,5,4,6,11,9,8,10,13,12,14 });
		VerifyPreOrderTraversalBST().InPlace(std::vector<int>({ 7,3,1,0,2,5,4,6,11,9,8,10,13,12,14 }));

		VerifyPreOrderTraversalBST().BruteForceRecur({ 7,3,1,0,2,8,4,6,11,9,5,10,13,12,14 });
		VerifyPreOrderTraversalBST().LinearRecur({ 7,3,1,0,2,8,4,6,11,9,5,10,13,12,14 });
		VerifyPreOrderTraversalBST().UseSortedStack({ 7,3,1,0,2,8,4,6,11,9,5,10,13,12,14 });
		VerifyPreOrderTraversalBST().InPlace(std::vector<int>({ 7,3,1,0,2,8,4,6,11,9,5,10,13,12,14 }));

		VerifyPreOrderTraversalBST().BruteForceRecur({ 7,3,1,0,11,5,4,6,2,9,8,10,13,12,14 });
		VerifyPreOrderTraversalBST().LinearRecur({ 7,3,1,0,11,5,4,6,2,9,8,10,13,12,14 });
		VerifyPreOrderTraversalBST().UseSortedStack({ 7,3,1,0,11,5,4,6,2,9,8,10,13,12,14 });
		VerifyPreOrderTraversalBST().InPlace(std::vector<int>({ 7,3,1,0,11,5,4,6,2,9,8,10,13,12,14 }));

		VerifyPreOrderTraversalBST().BruteForceRecur({ 7,3,1,0,2,5,4,6,11,14,8,10,13,12,9 });
		VerifyPreOrderTraversalBST().LinearRecur({ 7,3,1,0,2,5,4,6,11,14,8,10,13,12,9 });
		VerifyPreOrderTraversalBST().UseSortedStack({ 7,3,1,0,2,5,4,6,11,14,8,10,13,12,9 });
		VerifyPreOrderTraversalBST().InPlace(std::vector<int>({ 7,3,1,0,2,5,4,6,11,14,8,10,13,12,9 }));
	}
	{
		VerifyPostOrderTraversalBST().LinearRecur({ 0,2,1,4,6,5,3,8,10,9,12,14,13,11,7 });
		VerifyPostOrderTraversalBST().UsingSortedStack({ 0,2,1,4,6,5,3,8,10,9,12,14,13,11,7 });

		VerifyPostOrderTraversalBST().LinearRecur({ 0,2,1,4,6,8,3,5,10,9,12,14,13,11,7 });
		VerifyPostOrderTraversalBST().UsingSortedStack({ 0,2,1,4,6,8,3,5,10,9,12,14,13,11,7 });

		VerifyPostOrderTraversalBST().LinearRecur({ 0,11,1,4,6,5,3,8,10,9,12,14,13,2,7 });
		VerifyPostOrderTraversalBST().UsingSortedStack({ 0,11,1,4,6,5,3,8,10,9,12,14,13,2,7 });

		VerifyPostOrderTraversalBST().LinearRecur({ 0,2,1,4,6,5,3,8,10,14,12,9,13,11,7 });
		VerifyPostOrderTraversalBST().UsingSortedStack({ 0,2,1,4,6,5,3,8,10,14,12,9,13,11,7 });
	}
	{
		LongestConsecutivePathBinaryTree::TreeNode * root = new LongestConsecutivePathBinaryTree::TreeNode(1);
		root->right = new LongestConsecutivePathBinaryTree::TreeNode(3);
		root->right->left = new LongestConsecutivePathBinaryTree::TreeNode(2);
		root->right->right = new LongestConsecutivePathBinaryTree::TreeNode(4);
		root->right->right->right = new LongestConsecutivePathBinaryTree::TreeNode(5);
		PrintBinaryTree<LongestConsecutivePathBinaryTree::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		LongestConsecutivePathBinaryTree().Recur(root);
		LongestConsecutivePathBinaryTree().Recur2(root);
		bstOss.str(std::string());
		LongestConsecutivePathBinaryTree::DeleteTree(root);

		root = new LongestConsecutivePathBinaryTree::TreeNode(2);
		root->right = new LongestConsecutivePathBinaryTree::TreeNode(3);
		root->right->left = new LongestConsecutivePathBinaryTree::TreeNode(2);
		root->right->left->left = new LongestConsecutivePathBinaryTree::TreeNode(1);
		PrintBinaryTree<LongestConsecutivePathBinaryTree::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		LongestConsecutivePathBinaryTree().Recur(root);
		LongestConsecutivePathBinaryTree().Recur2(root);
		bstOss.str(std::string());
		LongestConsecutivePathBinaryTree::DeleteTree(root);
	}
	{
		ClosestValBST::TreeNode * Root = new ClosestValBST::TreeNode(9);
		Root->left = new ClosestValBST::TreeNode(5);
		Root->left->left = new ClosestValBST::TreeNode(3);
		Root->left->left->left = new ClosestValBST::TreeNode(1);
		Root->left->left->right = new ClosestValBST::TreeNode(4);
		Root->left->right = new ClosestValBST::TreeNode(7);
		Root->left->right->left = new ClosestValBST::TreeNode(6);
		Root->left->right->right = new ClosestValBST::TreeNode(8);
		Root->right = new ClosestValBST::TreeNode(14);
		Root->right->left = new ClosestValBST::TreeNode(12);
		Root->right->left->left = new ClosestValBST::TreeNode(11);
		Root->right->left->right = new ClosestValBST::TreeNode(13);
		Root->right->right = new ClosestValBST::TreeNode(17);
		Root->right->right->left = new ClosestValBST::TreeNode(16);
		Root->right->right->right = new ClosestValBST::TreeNode(18);
		PrintBinaryTree<ClosestValBST::TreeNode, std::ostringstream>(Root, bstOss);
		std::cout << bstOss.str() << std::endl;
		ClosestValBST().Recur(Root, 15.5);
		ClosestValBST().Iterate(Root, 15.5);
		ClosestValBST().UseMaxHeap(Root, 9.2, 7);
		ClosestValBST().UseTwoStacks(Root, 9.2, 7);
		ClosestValBST().UseTwoStacks(Root, 3.0, 7);
		ClosestValBST().UseTwoStacks(Root, 7.0, 7);
		ClosestValBST().UseTwoStacks(Root, 12.0, 7);
		ClosestValBST().UseTwoStacks(Root, 17.0, 7);
		ClosestValBST().UseTwoStacks(Root, 2.5, 3);
		ClosestValBST().UseTwoStacks(Root, 17.5, 3);
		ClosestValBST().UseTwoStacks(Root, 1.5, 3);
		ClosestValBST().UseTwoStacks(Root, 3.5, 3);
		ClosestValBST().UseTwoStacks(Root, 4.5, 3);
		ClosestValBST().UseTwoStacks(Root, 5.5, 3);
		ClosestValBST().UseTwoStacks(Root, 6.5, 3);
		ClosestValBST().UseTwoStacks(Root, 7.5, 3);
		ClosestValBST().UseTwoStacks(Root, 8.5, 3);
		bstOss.str(std::string());
		ClosestValBST::DeleteTree(Root);
	}
	{
		BinaryTreeVerticalOrderTraversal::TreeNode * root = new BinaryTreeVerticalOrderTraversal::TreeNode(3);
		root->left = new BinaryTreeVerticalOrderTraversal::TreeNode(9);
		root->left->left = new BinaryTreeVerticalOrderTraversal::TreeNode(4);
		root->left->right = new BinaryTreeVerticalOrderTraversal::TreeNode(0);
		root->left->right->right = new BinaryTreeVerticalOrderTraversal::TreeNode(2);
		root->right = new BinaryTreeVerticalOrderTraversal::TreeNode(8);
		root->right->left = new BinaryTreeVerticalOrderTraversal::TreeNode(1);
		root->right->left->left = new BinaryTreeVerticalOrderTraversal::TreeNode(5);
		root->right->right = new BinaryTreeVerticalOrderTraversal::TreeNode(7);
		PrintBinaryTree<BinaryTreeVerticalOrderTraversal::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		BinaryTreeVerticalOrderTraversal().BFS_I(root);
        BinaryTreeVerticalOrderTraversal().BFS_II(root);
        BinaryTreeVerticalOrderTraversal().DFS_II(root);
		bstOss.str(std::string());
		BinaryTreeVerticalOrderTraversal::DeleteTree(root);
	}
	{
		CountUnivalueSubtrees::TreeNode * root = new CountUnivalueSubtrees::TreeNode(5);
		root->left = new CountUnivalueSubtrees::TreeNode(1);
		root->left->left = new CountUnivalueSubtrees::TreeNode(5);
		root->left->right = new CountUnivalueSubtrees::TreeNode(5);
		root->right = new CountUnivalueSubtrees::TreeNode(5);
		root->right->right = new CountUnivalueSubtrees::TreeNode(5);
		PrintBinaryTree < CountUnivalueSubtrees::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		CountUnivalueSubtrees().Recur(root);
		CountUnivalueSubtrees().IteratePostorderStack_HashMap(root);
		CountUnivalueSubtrees().IteratePostorderStack_LeftSibStk(root);
		bstOss.str(std::string());
		CountUnivalueSubtrees::DeleteTree(root);

		root = new CountUnivalueSubtrees::TreeNode(7);
		root->left = new CountUnivalueSubtrees::TreeNode(5);
		root->left->left = new CountUnivalueSubtrees::TreeNode(1);
		root->left->left->right = new CountUnivalueSubtrees::TreeNode(1);
		root->left->right = new CountUnivalueSubtrees::TreeNode(5);
		root->left->right->right = new CountUnivalueSubtrees::TreeNode(5);
		root->right = new CountUnivalueSubtrees::TreeNode(9);
		root->right->left = new CountUnivalueSubtrees::TreeNode(9);
		root->right->right = new CountUnivalueSubtrees::TreeNode(13);
		root->right->right->left = new CountUnivalueSubtrees::TreeNode(13);
		root->right->right->left->left = new CountUnivalueSubtrees::TreeNode(13);
		root->right->right->left->right = new CountUnivalueSubtrees::TreeNode(13);
		PrintBinaryTree < CountUnivalueSubtrees::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		CountUnivalueSubtrees().Recur(root);
		CountUnivalueSubtrees().IteratePostorderStack_HashMap(root);
		CountUnivalueSubtrees().IteratePostorderStack_LeftSibStk(root);
		bstOss.str(std::string());
		CountUnivalueSubtrees::DeleteTree(root);
	}
	{
		LargestBSTSubtree::TreeNode * root = new LargestBSTSubtree::TreeNode(10);
		root->left = new LargestBSTSubtree::TreeNode(5);
		root->left->left = new LargestBSTSubtree::TreeNode(1);
		root->left->right = new LargestBSTSubtree::TreeNode(8);
		root->right = new LargestBSTSubtree::TreeNode(15);
		root->right->right = new LargestBSTSubtree::TreeNode(7);
		PrintBinaryTree<LargestBSTSubtree::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		LargestBSTSubtree().Recur(root);
		LargestBSTSubtree().IteratePostorderStack_HashMap(root);
		LargestBSTSubtree().IteratePostorderStack_LeftSibStk(root);
		bstOss.str(std::string());
		LargestBSTSubtree::DeleteTree(root);

		root = new LargestBSTSubtree::TreeNode(7);
		root->left = new LargestBSTSubtree::TreeNode(3);
		root->left->left = new LargestBSTSubtree::TreeNode(1);
		root->left->left->right = new LargestBSTSubtree::TreeNode(2);
		root->left->right = new LargestBSTSubtree::TreeNode(5);
		root->left->right->right = new LargestBSTSubtree::TreeNode(6);
		root->right = new LargestBSTSubtree::TreeNode(11);
		root->right->left = new LargestBSTSubtree::TreeNode(9);
		root->right->right = new LargestBSTSubtree::TreeNode(15);
		root->right->right->left = new LargestBSTSubtree::TreeNode(13);
		root->right->right->left->left = new LargestBSTSubtree::TreeNode(12);
		root->right->right->left->right = new LargestBSTSubtree::TreeNode(14);
		PrintBinaryTree<LargestBSTSubtree::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		LargestBSTSubtree().Recur(root);
		LargestBSTSubtree().IteratePostorderStack_HashMap(root);
		LargestBSTSubtree().IteratePostorderStack_LeftSibStk(root);
		bstOss.str(std::string());
		LargestBSTSubtree::DeleteTree(root);
	}
	{
		LargestInRangeBSTSubtree::TreeNode * Root = new LargestInRangeBSTSubtree::TreeNode(9);
		Root->left = new LargestInRangeBSTSubtree::TreeNode(5);
		Root->left->left = new LargestInRangeBSTSubtree::TreeNode(3);
		Root->left->left->left = new LargestInRangeBSTSubtree::TreeNode(1);
		Root->left->left->right = new LargestInRangeBSTSubtree::TreeNode(4);
		Root->left->right = new LargestInRangeBSTSubtree::TreeNode(7);
		Root->left->right->left = new LargestInRangeBSTSubtree::TreeNode(6);
		Root->left->right->right = new LargestInRangeBSTSubtree::TreeNode(8);
		Root->right = new LargestInRangeBSTSubtree::TreeNode(14);
		Root->right->left = new LargestInRangeBSTSubtree::TreeNode(12);
		Root->right->left->left = new LargestInRangeBSTSubtree::TreeNode(11);
		Root->right->left->right = new LargestInRangeBSTSubtree::TreeNode(13);
		Root->right->right = new LargestInRangeBSTSubtree::TreeNode(17);
		Root->right->right->left = new LargestInRangeBSTSubtree::TreeNode(16);
		Root->right->right->right = new LargestInRangeBSTSubtree::TreeNode(18);
		PrintBinaryTree<LargestInRangeBSTSubtree::TreeNode, std::ostringstream>(Root, bstOss);
		std::cout << bstOss.str() << std::endl;
		LargestInRangeBSTSubtree().PostorderRecur(Root, 3, 11);
		LargestInRangeBSTSubtree().PostorderRecur(Root, 1, 14);
		LargestInRangeBSTSubtree().PostorderRecur(Root, 10, 16);
		LargestInRangeBSTSubtree().PostorderRecur(Root, 12, 17);
		LargestInRangeBSTSubtree().PostorderRecur(Root, 2, 2);
		LargestInRangeBSTSubtree().PostorderRecur(Root, 9, 10);
		LargestInRangeBSTSubtree().PostorderRecur(Root,	19, 21);
		bstOss.str(std::string());
		LargestInRangeBSTSubtree::DeleteTree(Root);
	}
	{
		FindLeavesOfBinaryTree::TreeNode * root = new FindLeavesOfBinaryTree::TreeNode(1);
		root->left = new FindLeavesOfBinaryTree::TreeNode(2);
		root->left->left = new FindLeavesOfBinaryTree::TreeNode(4);
		root->left->right = new FindLeavesOfBinaryTree::TreeNode(5);
		root->right = new FindLeavesOfBinaryTree::TreeNode(3);
		PrintBinaryTree<FindLeavesOfBinaryTree::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		FindLeavesOfBinaryTree().DFS_Recur(root);
		FindLeavesOfBinaryTree().IteratePostorderStack_HashMap(root);
		FindLeavesOfBinaryTree().IteratePostorderStack_LeftSibStk(root);
		bstOss.str(std::string());
		FindLeavesOfBinaryTree::DeleteTree(root);

		root = new FindLeavesOfBinaryTree::TreeNode(7);
		root->left = new FindLeavesOfBinaryTree::TreeNode(3);
		root->left->left = new FindLeavesOfBinaryTree::TreeNode(1);
		root->left->left->right = new FindLeavesOfBinaryTree::TreeNode(2);
		root->left->right = new FindLeavesOfBinaryTree::TreeNode(5);
		root->left->right->right = new FindLeavesOfBinaryTree::TreeNode(6);
		root->right = new FindLeavesOfBinaryTree::TreeNode(11);
		root->right->left = new FindLeavesOfBinaryTree::TreeNode(9);
		root->right->right = new FindLeavesOfBinaryTree::TreeNode(15);
		root->right->right->left = new FindLeavesOfBinaryTree::TreeNode(13);
		root->right->right->left->left = new FindLeavesOfBinaryTree::TreeNode(12);
		root->right->right->left->right = new FindLeavesOfBinaryTree::TreeNode(14);
		PrintBinaryTree<FindLeavesOfBinaryTree::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		FindLeavesOfBinaryTree().DFS_Recur(root);
		FindLeavesOfBinaryTree().IteratePostorderStack_HashMap(root);
		FindLeavesOfBinaryTree().IteratePostorderStack_LeftSibStk(root);
		bstOss.str(std::string());
		FindLeavesOfBinaryTree::DeleteTree(root);
	}
	{
		std::string bstStr = "4(2(3)(1))(6(5))";
		std::cout << "ConstructBinaryTreeFromNestedTraversal for \"" << bstStr << "\":" << std::endl;
		ConstructBinaryTreeFromNestedTraversal::TreeNode * root = ConstructBinaryTreeFromNestedTraversal().Recur(bstStr);
		PrintBinaryTree<ConstructBinaryTreeFromNestedTraversal::TreeNode, std::ostringstream>(root, bstOss);
		ConstructBinaryTreeFromNestedTraversal::DeleteTree(root);
		root = ConstructBinaryTreeFromNestedTraversal().Stack(bstStr);
		PrintBinaryTree<ConstructBinaryTreeFromNestedTraversal::TreeNode, std::ostringstream>(root, bstOss);
		std::cout << bstOss.str() << std::endl;
		ConstructBinaryTreeFromNestedTraversal::DeleteTree(root);
		bstOss.str(std::string());
	}
	{
		DecodeNestedString().Recur(std::string("3[a]2[bc]"));
		DecodeNestedString().Stack(std::string("3[a]2[bc]"));
		DecodeNestedString().Recur(std::string("3[a2[c]]"));
		DecodeNestedString().Stack(std::string("3[a2[c]]"));
		DecodeNestedString().Recur(std::string("2[abc]3[cd]ef"));
		DecodeNestedString().Stack(std::string("2[abc]3[cd]ef"));

		EncodeShortestNestedString().DP2D(std::string("a"));
		EncodeShortestNestedString().DP2D(std::string("aaaa"));
		EncodeShortestNestedString().DP2D(std::string("aaaaa"));
		EncodeShortestNestedString().DP2D(std::string("abababababababcd"));
		EncodeShortestNestedString().DP2D(std::string("abbbabbbc"));
		EncodeShortestNestedString().DP2D(std::string("abbbabbbcabbbabbbc"));
	}
	{
		/*
		std::ifstream f("In_ParseNestedListString.txt");
		std::stringstream ss;
		ss << f.rdbuf();
		ParseNestedListString().deserialize(ss.str());
		*/
		ParseNestedListString().deserialize("[]");
		ParseNestedListString().deserialize("[[]]");
		ParseNestedListString().deserialize("[-1]");
		ParseNestedListString().deserialize("[1,2]");
		ParseNestedListString().deserialize("[1,[2]]");
		ParseNestedListString().deserialize("[[1],2]");
		ParseNestedListString().deserialize("324");
		ParseNestedListString().deserialize("[[1,2],3,[4,5]]");
		ParseNestedListString().deserialize("[123,[456,[789]]]");
		ParseNestedListString().deserialize("[[[6,7],4,5],2,[3,[[6],8,[4,[5,[[7,3],0]]],4],1],9]");
	}
	{
		ParseNestedTernaryExpression().Recur("T?2:3");
		ParseNestedTernaryExpression().Recur("F?1:T?4:5");
		ParseNestedTernaryExpression().Recur("T?T?F:5:3");
	}
    {
        FindNearestLeafNodeBinaryTree::TreeNode * root = new FindNearestLeafNodeBinaryTree::TreeNode(1);
        root->left = new FindNearestLeafNodeBinaryTree::TreeNode(2);
        root->left->left = new FindNearestLeafNodeBinaryTree::TreeNode(4);
        root->left->left->left = new FindNearestLeafNodeBinaryTree::TreeNode(5);
        root->left->left->left->left = new FindNearestLeafNodeBinaryTree::TreeNode(6);
        root->right = new FindNearestLeafNodeBinaryTree::TreeNode(3);
        PrintBinaryTree<FindNearestLeafNodeBinaryTree::TreeNode, std::ostringstream>(root, bstOss);
        std::cout << bstOss.str() << std::endl;
        FindNearestLeafNodeBinaryTree().BFS(root, 2);
        FindNearestLeafNodeBinaryTree().Recur(root, 2);
        FindNearestLeafNodeBinaryTree::DeleteTree(root);
        bstOss.str(std::string());

        root = new FindNearestLeafNodeBinaryTree::TreeNode(1);
        root->left = new FindNearestLeafNodeBinaryTree::TreeNode(2);
        root->right = new FindNearestLeafNodeBinaryTree::TreeNode(3);
        root->right->left = new FindNearestLeafNodeBinaryTree::TreeNode(4);
        root->right->left->left = new FindNearestLeafNodeBinaryTree::TreeNode(6);
        root->right->left->left->left = new FindNearestLeafNodeBinaryTree::TreeNode(8);
        root->right->left->left->right = new FindNearestLeafNodeBinaryTree::TreeNode(9);
        root->right->right = new FindNearestLeafNodeBinaryTree::TreeNode(5);
        root->right->right->right = new FindNearestLeafNodeBinaryTree::TreeNode(7);
        root->right->right->right->left = new FindNearestLeafNodeBinaryTree::TreeNode(10);
        PrintBinaryTree<FindNearestLeafNodeBinaryTree::TreeNode, std::ostringstream>(root, bstOss);
        std::cout << bstOss.str() << std::endl;
        FindNearestLeafNodeBinaryTree().BFS(root, 3);
        FindNearestLeafNodeBinaryTree().Recur(root, 3);
        FindNearestLeafNodeBinaryTree().BFS(root, 7);
        FindNearestLeafNodeBinaryTree().Recur(root, 7);
        FindNearestLeafNodeBinaryTree().BFS(root, 4);
        FindNearestLeafNodeBinaryTree().Recur(root, 4);
        FindNearestLeafNodeBinaryTree::DeleteTree(root);
        bstOss.str(std::string());
    }
    {
        SplitBST::TreeNode * root = new SplitBST::TreeNode(4);
        root->left = new SplitBST::TreeNode(2);
        root->left->left = new SplitBST::TreeNode(1);
        root->left->right = new SplitBST::TreeNode(3);
        root->right = new SplitBST::TreeNode(6);
        root->right->left = new SplitBST::TreeNode(5);
        root->right->right = new SplitBST::TreeNode(7);
        PrintBinaryTree<SplitBST::TreeNode, std::ostringstream>(root, bstOss);
        bstOss << std::endl << "SplitBST for above BST with value=2:" << std::endl;
        std::vector<SplitBST::TreeNode*> res = SplitBST().Recur(root, 2);
        for (auto & r : res)
            PrintBinaryTree<SplitBST::TreeNode, std::ostringstream>(r, bstOss);
        std::cout << bstOss.str() << std::endl;
        for (auto & r : res)
            SplitBST::DeleteTree(r);
        bstOss.str(std::string());
    }
    {
        ListOfNodesFormBinaryTree::TreeNode * r1 = new ListOfNodesFormBinaryTree::TreeNode(0);

        PrintBinaryTree<ListOfNodesFormBinaryTree::TreeNode, std::ostringstream>(r1, bstOss);
        std::cout << bstOss.str() << std::endl;
        ListOfNodesFormBinaryTree().HashSet(std::vector<ListOfNodesFormBinaryTree::TreeNode*>({r1}));
        bstOss.str(std::string());

        ListOfNodesFormBinaryTree::TreeNode * r2 = new ListOfNodesFormBinaryTree::TreeNode(1);

        PrintBinaryTree<ListOfNodesFormBinaryTree::TreeNode, std::ostringstream>(r1, bstOss);
        PrintBinaryTree<ListOfNodesFormBinaryTree::TreeNode, std::ostringstream>(r2, bstOss);
        std::cout << bstOss.str() << std::endl;
        ListOfNodesFormBinaryTree().HashSet(std::vector<ListOfNodesFormBinaryTree::TreeNode*>({r1, r2}));
        bstOss.str(std::string());

        r1->left = new ListOfNodesFormBinaryTree::TreeNode(2);
        r1->right = new ListOfNodesFormBinaryTree::TreeNode(3);

        PrintBinaryTree<ListOfNodesFormBinaryTree::TreeNode, std::ostringstream>(r1, bstOss);
        std::cout << bstOss.str() << std::endl;
        ListOfNodesFormBinaryTree().HashSet(std::vector<ListOfNodesFormBinaryTree::TreeNode*>({r1, r1->left, r1->right}));
        bstOss.str(std::string());

        r2->left = r1->right;
        PrintBinaryTree<ListOfNodesFormBinaryTree::TreeNode, std::ostringstream>(r1, bstOss);
        PrintBinaryTree<ListOfNodesFormBinaryTree::TreeNode, std::ostringstream>(r2, bstOss);
        std::cout << bstOss.str() << std::endl;
        ListOfNodesFormBinaryTree().HashSet(std::vector<ListOfNodesFormBinaryTree::TreeNode*>({r1, r1->left, r1->right, r2}));
        bstOss.str(std::string());

        r2->left = NULL;
        ListOfNodesFormBinaryTree::DeleteTree(r1);
        ListOfNodesFormBinaryTree::DeleteTree(r2);
        bstOss.str(std::string());
    }
    {
        MinDist2NodesBinaryTree::TreeNode * r = new MinDist2NodesBinaryTree::TreeNode(0);
        r->left = new MinDist2NodesBinaryTree::TreeNode(1);
        r->left->left = new MinDist2NodesBinaryTree::TreeNode(2);
        r->left->left->left = new MinDist2NodesBinaryTree::TreeNode(3);
        r->left->left->right = new MinDist2NodesBinaryTree::TreeNode(4);
        r->left->right = new MinDist2NodesBinaryTree::TreeNode(5);
        r->left->right->left = new MinDist2NodesBinaryTree::TreeNode(6);
        r->left->right->right = new MinDist2NodesBinaryTree::TreeNode(7);
        r->right = new MinDist2NodesBinaryTree::TreeNode(8);
        r->right->left = new MinDist2NodesBinaryTree::TreeNode(9);
        r->right->left->left = new MinDist2NodesBinaryTree::TreeNode(10);
        r->right->left->right = new MinDist2NodesBinaryTree::TreeNode(11);
        r->right->right = new MinDist2NodesBinaryTree::TreeNode(12);
        r->right->right->left = new MinDist2NodesBinaryTree::TreeNode(13);
        r->right->right->right = new MinDist2NodesBinaryTree::TreeNode(14);
        PrintBinaryTree<MinDist2NodesBinaryTree::TreeNode, std::ostringstream>(r, bstOss);
        std::cout << bstOss.str() << std::endl;
        MinDist2NodesBinaryTree().HashMap(r, r->left->left, r->right->right->left);
        MinDist2NodesBinaryTree().HashMap(r, r->left->left->right, r->right->left->right);
        MinDist2NodesBinaryTree().HashMap(r, r->left->left->right, r->left->left->right);
        MinDist2NodesBinaryTree().HashMap(r, r->left->left->right, r->left->left);
        MinDist2NodesBinaryTree().HashMap(r, r, r->right->left->left);
        MinDist2NodesBinaryTree().HashMap(r, r->right, r->right->right);
        MinDist2NodesBinaryTree().HashMap(r, r->right->left, r->right->left->right);
        bstOss.str(std::string());
        MinDist2NodesBinaryTree::DeleteTree(r);
    }
    {
        ConvertBSTtoMinHeap::TreeNode * t = new ConvertBSTtoMinHeap::TreeNode(4);
        t->left = new ConvertBSTtoMinHeap::TreeNode(2);
        t->left->left = new ConvertBSTtoMinHeap::TreeNode(1);
        t->left->right = new ConvertBSTtoMinHeap::TreeNode(3);
        t->right = new ConvertBSTtoMinHeap::TreeNode(6);
        t->right->left = new ConvertBSTtoMinHeap::TreeNode(5);
        t->right->right = new ConvertBSTtoMinHeap::TreeNode(7);
        PrintBinaryTree<ConvertBSTtoMinHeap::TreeNode, std::ostringstream>(t, bstOss);
        bstOss << "ConvertBSTtoMinHeap UseInOrderArray for above BinaryTree:" << std::endl;
        t = ConvertBSTtoMinHeap().InorderArray(t);
        PrintBinaryTree<ConvertBSTtoMinHeap::TreeNode, std::ostringstream>(t, bstOss);
        std::cout << bstOss.str() << std::endl;
        bstOss.str(std::string());
        ConvertBSTtoMinHeap::DeleteTree(t);

        ConvertBSTtoMinHeap::TreeNode * r = new ConvertBSTtoMinHeap::TreeNode(4);
        //r->left = new ConvertBSTtoMinHeap::TreeNode(2);
        //r->left->left = new ConvertBSTtoMinHeap::TreeNode(1);
        //r->left->right = new ConvertBSTtoMinHeap::TreeNode(3);
        r->right = new ConvertBSTtoMinHeap::TreeNode(6);
        r->right->left = new ConvertBSTtoMinHeap::TreeNode(5);
        //r->right->right = new ConvertBSTtoMinHeap::TreeNode(7);
        PrintBinaryTree<ConvertBSTtoMinHeap::TreeNode, std::ostringstream>(r, bstOss);
        bstOss << "ConvertBSTtoMinHeap InPlace for above BinaryTree:" << std::endl;
        r = ConvertBSTtoMinHeap().InPlace(r);
        PrintBinaryTree<ConvertBSTtoMinHeap::TreeNode, std::ostringstream>(r, bstOss);
        std::cout << bstOss.str() << std::endl;
        bstOss.str(std::string());
        ConvertBSTtoMinHeap::DeleteTree(r);

        r = ConvertBSTtoMinHeap().SortedArrayToMinHeap(std::vector<int>({1,2,3,4,5,6,7}));
        bstOss << "ConvertBSTtoMinHeap SortedArrayToMinHeap: " << std::endl;
        PrintBinaryTree<ConvertBSTtoMinHeap::TreeNode, std::ostringstream>(r, bstOss);
        std::cout << bstOss.str() << std::endl;
        bstOss.str(std::string());
        ConvertBSTtoMinHeap::DeleteTree(r);
    }
    {
        PrintBinaryTreeIn2DArray::TreeNode * r = new PrintBinaryTreeIn2DArray::TreeNode(0);
        r->left = new PrintBinaryTreeIn2DArray::TreeNode(1);
        r->left->left = new PrintBinaryTreeIn2DArray::TreeNode(2);
        r->left->left->left = new PrintBinaryTreeIn2DArray::TreeNode(3);
        r->left->left->right = new PrintBinaryTreeIn2DArray::TreeNode(4);
        r->left->right = new PrintBinaryTreeIn2DArray::TreeNode(5);
        r->left->right->left = new PrintBinaryTreeIn2DArray::TreeNode(6);
        r->left->right->right = new PrintBinaryTreeIn2DArray::TreeNode(7);
        r->right = new PrintBinaryTreeIn2DArray::TreeNode(8);
        r->right->left = new PrintBinaryTreeIn2DArray::TreeNode(9);
        r->right->left->left = new PrintBinaryTreeIn2DArray::TreeNode(0);
        r->right->left->right = new PrintBinaryTreeIn2DArray::TreeNode(1);
        r->right->right = new PrintBinaryTreeIn2DArray::TreeNode(2);
        r->right->right->left = new PrintBinaryTreeIn2DArray::TreeNode(3);
        r->right->right->right = new PrintBinaryTreeIn2DArray::TreeNode(4);
        PrintBinaryTree<PrintBinaryTreeIn2DArray::TreeNode, std::ostringstream>(r, bstOss);
        std::cout << bstOss.str() << std::endl;
        PrintBinaryTreeIn2DArray().Recur(r);
        PrintBinaryTreeIn2DArray().BFS(r);
        PrintBinaryTreeIn2DArray().ToStrRecur(r);
        bstOss.str(std::string());
        PrintBinaryTreeIn2DArray::DeleteTree(r);
    }
    {
        FlipEquivalentBinaryTrees::TreeNode * r1 = new FlipEquivalentBinaryTrees::TreeNode(1);
        r1->left = new FlipEquivalentBinaryTrees::TreeNode(2);
        r1->left->left = new FlipEquivalentBinaryTrees::TreeNode(4);
        r1->left->right = new FlipEquivalentBinaryTrees::TreeNode(5);
        r1->left->right->left = new FlipEquivalentBinaryTrees::TreeNode(7);
        r1->left->right->right = new FlipEquivalentBinaryTrees::TreeNode(8);
        r1->right = new FlipEquivalentBinaryTrees::TreeNode(3);
        r1->right->left = new FlipEquivalentBinaryTrees::TreeNode(6);
        FlipEquivalentBinaryTrees::TreeNode * r2 = new FlipEquivalentBinaryTrees::TreeNode(1);
        r2->left = new FlipEquivalentBinaryTrees::TreeNode(3);
        r2->left->right = new FlipEquivalentBinaryTrees::TreeNode(6);
        r2->right = new FlipEquivalentBinaryTrees::TreeNode(2);
        r2->right->left = new FlipEquivalentBinaryTrees::TreeNode(4);
        r2->right->right = new FlipEquivalentBinaryTrees::TreeNode(5);
        r2->right->right->left = new FlipEquivalentBinaryTrees::TreeNode(8);
        r2->right->right->right = new FlipEquivalentBinaryTrees::TreeNode(7);
        PrintBinaryTree<FlipEquivalentBinaryTrees::TreeNode, std::ostringstream>(r1, bstOss);
        PrintBinaryTree<FlipEquivalentBinaryTrees::TreeNode, std::ostringstream>(r2, bstOss);
        std::cout << bstOss.str() << std::endl;
        FlipEquivalentBinaryTrees().Recur(r1, r2);
        bstOss.str(std::string());
        FlipEquivalentBinaryTrees::DeleteTree(r1);
        FlipEquivalentBinaryTrees::DeleteTree(r2);
    }
    {
        MinCamerasBinaryTree::TreeNode * r1 = new MinCamerasBinaryTree::TreeNode(0);
        r1->left = new MinCamerasBinaryTree::TreeNode(0);
        r1->left->left = new MinCamerasBinaryTree::TreeNode(0);
        r1->left->right = new MinCamerasBinaryTree::TreeNode(0);
        PrintBinaryTree<MinCamerasBinaryTree::TreeNode, std::ostringstream>(r1, bstOss);
        std::cout << bstOss.str() << std::endl;
        MinCamerasBinaryTree().Recur(r1);
        bstOss.str(std::string());
        MinCamerasBinaryTree::DeleteTree(r1);
        MinCamerasBinaryTree::TreeNode * r2 = new MinCamerasBinaryTree::TreeNode(0);
        r2->left = new MinCamerasBinaryTree::TreeNode(0);
        r2->left->left = new MinCamerasBinaryTree::TreeNode(0);
        r2->left->left->left = new MinCamerasBinaryTree::TreeNode(0);
        r2->left->left->left->right = new MinCamerasBinaryTree::TreeNode(0);
        PrintBinaryTree<MinCamerasBinaryTree::TreeNode, std::ostringstream>(r2, bstOss);
        std::cout << bstOss.str() << std::endl;
        MinCamerasBinaryTree().Recur(r2);
        bstOss.str(std::string());
        MinCamerasBinaryTree::DeleteTree(r2);
    }
    {
        FlattenBinaryTreeInInorder::TreeNode * r = new FlattenBinaryTreeInInorder::TreeNode(5);
        r->left = new FlattenBinaryTreeInInorder::TreeNode(3);
        r->left->left = new FlattenBinaryTreeInInorder::TreeNode(2);
        r->left->right = new FlattenBinaryTreeInInorder::TreeNode(4);
        r->left->left->left = new FlattenBinaryTreeInInorder::TreeNode(1);
        r->right = new FlattenBinaryTreeInInorder::TreeNode(6);
        //r->right->right = new FlattenBinaryTreeInInorder::TreeNode(8);
        //r->right->right->left = new FlattenBinaryTreeInInorder::TreeNode(7);
        //r->right->right->right = new FlattenBinaryTreeInInorder::TreeNode(9);
        bstOss << "FlattenBinaryTreeInInorder:" << std::endl;
        PrintBinaryTree<FlattenBinaryTreeInInorder::TreeNode, std::ostringstream>(r, bstOss);
        FlattenBinaryTreeInInorder::TreeNode * res = FlattenBinaryTreeInInorder().Iterate(r);
        PrintBinaryTree<FlattenBinaryTreeInInorder::TreeNode, std::ostringstream>(res, bstOss);
        std::cout << bstOss.str() << std::endl;
        bstOss.str(std::string());
        FlattenBinaryTreeInInorder::DeleteTree(res);
    }
    {
        SubtreeContainingAllDeepestNodes::TreeNode * r = new SubtreeContainingAllDeepestNodes::TreeNode(3);
        r->left = new SubtreeContainingAllDeepestNodes::TreeNode(5);
        r->left->left = new SubtreeContainingAllDeepestNodes::TreeNode(6);
        r->left->right = new SubtreeContainingAllDeepestNodes::TreeNode(2);
        r->left->right->left = new SubtreeContainingAllDeepestNodes::TreeNode(7);
        r->left->right->right = new SubtreeContainingAllDeepestNodes::TreeNode(4);
        r->right = new SubtreeContainingAllDeepestNodes::TreeNode(1);
        r->right->left = new SubtreeContainingAllDeepestNodes::TreeNode(0);
        r->right->right = new SubtreeContainingAllDeepestNodes::TreeNode(8);
        bstOss << "SubtreeContainingAllDeepestNodes: " << std::endl;
        PrintBinaryTree<SubtreeContainingAllDeepestNodes::TreeNode, std::ostringstream>(r, bstOss);
        SubtreeContainingAllDeepestNodes::TreeNode * res = SubtreeContainingAllDeepestNodes().Recur(r);
        PrintBinaryTree<SubtreeContainingAllDeepestNodes::TreeNode, std::ostringstream>(res, bstOss);
        std::cout << bstOss.str() << std::endl;
        bstOss.str(std::string());
        SubtreeContainingAllDeepestNodes::DeleteTree(r);
    }
    {
        BinaryTreeLevelOrderArrToInOrderArr().Recur(std::vector<int>({4, 2, 6, 1, 3, 5, 7}));
    }
    {
        MaxDiffBtwNodeAncestorBinaryTree::TreeNode * r = new MaxDiffBtwNodeAncestorBinaryTree::TreeNode(8);
        r->left = new MaxDiffBtwNodeAncestorBinaryTree::TreeNode(3);
        r->left->left = new MaxDiffBtwNodeAncestorBinaryTree::TreeNode(1);
        r->left->right = new MaxDiffBtwNodeAncestorBinaryTree::TreeNode(6);
        r->left->right->left = new MaxDiffBtwNodeAncestorBinaryTree::TreeNode(4);
        r->left->right->right = new MaxDiffBtwNodeAncestorBinaryTree::TreeNode(7);
        r->right = new MaxDiffBtwNodeAncestorBinaryTree::TreeNode(10);
        r->right->right = new MaxDiffBtwNodeAncestorBinaryTree::TreeNode(14);
        r->right->right->left = new MaxDiffBtwNodeAncestorBinaryTree::TreeNode(13);
        PrintBinaryTree<MaxDiffBtwNodeAncestorBinaryTree::TreeNode, std::ostringstream>(r, bstOss);
        std::cout << bstOss.str() << std::endl;
        MaxDiffBtwNodeAncestorBinaryTree().Recur(r);
        bstOss.str(std::string());
        MaxDiffBtwNodeAncestorBinaryTree::DeleteTree(r);
    }
    {
        auto v = AllPossibleFullBinaryTree().Enumerate(7);
        bstOss << "AllPossibleFullBinaryTree for nodeCount=7: " << std::endl;
        for (auto root : v)
            PrintBinaryTree<AllPossibleFullBinaryTree::TreeNode, std::ostringstream>(root, bstOss);
        std::cout << bstOss.str() << std::endl;
        bstOss.str(std::string());
    }
    {
        RemoveSubtWAll0sBinaryTree::TreeNode * r = new RemoveSubtWAll0sBinaryTree::TreeNode(1);
        r->right = new RemoveSubtWAll0sBinaryTree::TreeNode(0);
        r->right->left = new RemoveSubtWAll0sBinaryTree::TreeNode(0);
        r->right->right = new RemoveSubtWAll0sBinaryTree::TreeNode(1);
        bstOss << "RemoveSubtWAll0sBinaryTree:" << std::endl;
        PrintBinaryTree<RemoveSubtWAll0sBinaryTree::TreeNode, std::ostringstream>(r, bstOss);
        r = RemoveSubtWAll0sBinaryTree().Recur(r);
        PrintBinaryTree<RemoveSubtWAll0sBinaryTree::TreeNode, std::ostringstream>(r, bstOss);
        std::cout << bstOss.str() << std::endl;
        bstOss.str(std::string());
        RemoveSubtWAll0sBinaryTree::DeleteTree(r);
    }
    {
        CompleteBinaryTreeInserter::TreeNode * r = new CompleteBinaryTreeInserter::TreeNode(0);
        CompleteBinaryTreeInserter cbti(r);
        for (int i = 1; i < 10; ++i)
            cbti.Insert(i);
        r = cbti.GetRoot();
        PrintBinaryTree<CompleteBinaryTreeInserter::TreeNode, std::ostringstream>(r, bstOss);
        std::cout << bstOss.str() << std::endl;
        bstOss.str(std::string());
        CompleteBinaryTreeInserter::DeleteTree(r);
    }
    {
        MinSwapLRChildToTgtPreorderBinaryTree::TreeNode * r = new MinSwapLRChildToTgtPreorderBinaryTree::TreeNode(1);
        r->left = new MinSwapLRChildToTgtPreorderBinaryTree::TreeNode(2);
        r->right = new MinSwapLRChildToTgtPreorderBinaryTree::TreeNode(3);
        PrintBinaryTree<MinSwapLRChildToTgtPreorderBinaryTree::TreeNode, std::ostringstream>(r, bstOss);
        auto v = MinSwapLRChildToTgtPreorderBinaryTree().Recur(r, std::vector<int>({1,3,2}));
        bstOss << "MinSwapLRChildToTgtPreorderBinaryTree Recur: " << Debug::ToStr1D<int>()(v) << std::endl;
        std::cout << bstOss.str() << std::endl;
        bstOss.str(std::string());
        MinSwapLRChildToTgtPreorderBinaryTree::DeleteTree(r);
    }
    {
        ConstructBinaryTreeFromTraversalWDepth::TreeNode * r = ConstructBinaryTreeFromTraversalWDepth().FromPreorder(std::string("1-2--3--4-5--6--7"));
        bstOss << "ConstructBinaryTreeFromTraversalWDepth from 1-2--3--4-5--6--7:" << std::endl;
        PrintBinaryTree<ConstructBinaryTreeFromTraversalWDepth::TreeNode, std::ostringstream>(r, bstOss);
        std::cout << bstOss.str() << std::endl;
        bstOss.str(std::string());
        ConstructBinaryTreeFromTraversalWDepth::DeleteTree(r);
    }
    {
        MaxAvgSubtree::TreeNode * root = new MaxAvgSubtree::TreeNode(20);
        root->children.push_back(new MaxAvgSubtree::TreeNode(12));
        root->children.push_back(new MaxAvgSubtree::TreeNode(18));
        root->children[0]->children.push_back(new MaxAvgSubtree::TreeNode(11));
        root->children[0]->children.push_back(new MaxAvgSubtree::TreeNode(2));
        root->children[0]->children.push_back(new MaxAvgSubtree::TreeNode(3));
        root->children[1]->children.push_back(new MaxAvgSubtree::TreeNode(15));
        root->children[1]->children.push_back(new MaxAvgSubtree::TreeNode(8));
        MaxAvgSubtree().Recur(root);
        MaxAvgSubtree().Recur2(root);
    }
    {
        PathInZigZagLabelledBinaryTree().Solve(14);
    }
    {
        CountNumOfAtomsInChemicalFormula().Recur(std::string("K4(ON(SO3)2)2"));
    }
    {
        MinCostBinaryTreeFromLeafValues().Greedy(std::vector<int>({6,2,4}));
        MinCostBinaryTreeFromLeafValues().Stack(std::vector<int>({6,2,4}));
    }
    {
        DeleteNodesOnNoRLPathWGreaterEqualSum::TreeNode * root = new DeleteNodesOnNoRLPathWGreaterEqualSum::TreeNode(5);
        root->left = new DeleteNodesOnNoRLPathWGreaterEqualSum::TreeNode(4);
        root->left->left = new DeleteNodesOnNoRLPathWGreaterEqualSum::TreeNode(11);
        root->left->left->left = new DeleteNodesOnNoRLPathWGreaterEqualSum::TreeNode(7);
        root->left->left->right = new DeleteNodesOnNoRLPathWGreaterEqualSum::TreeNode(1);
        root->right = new DeleteNodesOnNoRLPathWGreaterEqualSum::TreeNode(8);
        root->right->left = new DeleteNodesOnNoRLPathWGreaterEqualSum::TreeNode(17);
        root->right->right = new DeleteNodesOnNoRLPathWGreaterEqualSum::TreeNode(4);
        root->right->right->left = new DeleteNodesOnNoRLPathWGreaterEqualSum::TreeNode(5);
        root->right->right->right = new DeleteNodesOnNoRLPathWGreaterEqualSum::TreeNode(3);
        bstOss << "DeleteNodesOnNoRLPathWGreaterEqualSum for limit=22:" << std::endl;
        PrintBinaryTree<DeleteNodesOnNoRLPathWGreaterEqualSum::TreeNode, std::ostringstream>(root, bstOss);
        root = DeleteNodesOnNoRLPathWGreaterEqualSum().GetSufficientSubset(root, 22);
        PrintBinaryTree<DeleteNodesOnNoRLPathWGreaterEqualSum::TreeNode, std::ostringstream>(root, bstOss);
        std::cout << bstOss.str() << std::endl;
        bstOss.str(std::string());
    }

#endif
#ifdef _QuadTree_
	/*QuadTree*/
    RdCout ? redirect_cout::to_file("Out_QuadTree.txt") : redirect_cout::to_cout();
    PrintH("QuadTree");
    {
        QuadTree::Node * root = QuadTree().Construct(std::vector<std::vector<int>>(
                {
                        {1,1,1,1,0,0,0,0},
                        {1,1,1,1,0,0,0,0},
                        {1,1,1,1,1,1,1,1},
                        {1,1,1,1,1,1,1,1},
                        {1,1,1,1,0,0,0,0},
                        {1,1,1,1,0,0,0,0},
                        {1,1,1,1,0,0,0,0},
                        {1,1,1,1,0,0,0,0},
                }));

        QuadTree::Node * t1 = QuadTree().Construct(std::vector<std::vector<int>>(
                {
                        {1,1,1,1},
                        {1,1,1,1},
                        {0,0,0,0},
                        {0,0,0,0},

                }));
        QuadTree::Node * t2 = QuadTree().Construct(std::vector<std::vector<int>>(
                {
                        {1,1,0,0},
                        {1,1,1,1},
                        {1,1,0,0},
                        {1,1,0,0},

                }));
        QuadTree::Node * t1ORt2 = QuadTree().Intersect(t1, t2);
    }
#endif
#ifdef _Heap_
	/*Heap*/
	RdCout ? redirect_cout::to_file("Out_Heap.txt") : redirect_cout::to_cout();
	PrintH("Heap");
	{
		BinaryMinHeap bmh(std::vector<int>({ 41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 }));
		bmh.GetKMin(15);
		bmh.CompareKthElement(15, 80);
		bmh.CompareKthElement(15, 81);
		bmh.CompareKthElement(15, 82);
		for (int i = 0; i < 4; ++i)
			bmh.RemoveMin();
		for (int i = 3; i >= 0; --i)
			bmh.Insert(i);
	}
	{
		BinomialMinHeap bmh(std::vector<int>({ 41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 }));
		bmh.Print();
		bmh.DeleteMin();
		bmh.Print();
		bmh.DeleteMin();
		bmh.Print();
		bmh.DeleteMin();
		bmh.Print();
	}
	{
		LeftistMinHeap h1;
		std::cout << "1." << std::endl;
		LeftistMinHeap h2 = h1;//copy ctor deep copy
		std::cout << "2." << std::endl;
		LeftistMinHeap h3(h1);//copy ctor deep copy
		std::cout << "3." << std::endl;
		LeftistMinHeap h4 = std::move(h2);//copy ctor move
		std::cout << "4." << std::endl;
		LeftistMinHeap h5(std::move(h3));//copy ctor move
		std::cout << "5." << std::endl;
		h2 = h4;//assignment deep copy
		std::cout << "6." << std::endl;
		h3 = std::move(h5);//assignment move
		//end testing ctor/copy ctor
		LeftistMinHeap h(std::vector<int>({ 41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 }));
		h.Print();
		h.DeleteMin();
		h.Print();
		h.DeleteMin();
		h.Print();
		h.DeleteMin();
		h.Print();
	}
	{
		SkewMinHeap h(std::vector<int>({ 41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 }));
		h.Print();
		h.DeleteMin();
		h.Print();
		h.DeleteMin();
		h.Print();
		h.DeleteMin();
		h.Print();
	}
	{
		FibonacciMinHeap h(std::vector<int>({ 41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61 }));
		h.Print();
		h.DeleteMin();
		h.Print();
		h.DeleteMin();
		h.Print();
		h.DeleteMin();
		h.Print();
		h.DeleteMin();
		h.Print();
		h.DeleteMin();
		h.Print();
		FibonacciMinHeap::HeapNode * n1 = h.Insert(51);
		h.Print();
		FibonacciMinHeap::HeapNode * n2 = h.Insert(99);
		h.Print();
		h.DecreaseKey(n1, 24);
		h.Print();
		h.DecreaseKey(n2, 37);
		h.Print();
		FibonacciMinHeap h2(std::vector<int>({ 4, 2, 3, 5, 7, 9, 8, 1, 10, 15, 13, 18, 20, 31 }));
		h2.Print();

	}
	{
		Treap t(std::vector<int>({ 4, 3, 5, 7, 8, 10, 15, 13, 18, 17 }));
		t.Print();
		t.Contains(17);
		t.FindMax();
		t.FindMin();
		t.Remove(5);
		t.Print();
		t.Remove(15);
		t.Print();
		t.Remove(4);
		t.Print();
		t.Remove(13);
		t.Print();
		t.Remove(7);
		t.Print();
	}
	{
		PairingMinHeap h(std::vector<int>({ 9, 4, 3, 5, 8, 7 }));
		h.Print();
		h.DeleteMin();
		h.Print();
		h.DeleteMin();
		h.Print();
		PairingMinHeap::HeapNode * n1 = h.Insert(6);
		h.Print();
		PairingMinHeap::HeapNode * n2 = h.Insert(10);
		h.Print();
		h.DecreaseKey(n1, 3);
		h.Print();
		h.DecreaseKey(n2, 4);
		h.Print();
	}
	{
		Merge2Heaps().UseMinHeapify(std::vector<int>({ 2,5,6,8 }), std::vector<int>({ 1,7,9 }));
	}

#endif
#ifdef _Graph_
	/*Graph*/
	RdCout ? redirect_cout::to_file("Out_Graph.txt") : redirect_cout::to_cout();
	PrintH("Graph");
	{
		std::vector<CloneGraph::UndirectedGraphNode *> cgv;
		for (int i = 0; i <= 2; ++i)
			cgv.push_back(new CloneGraph::UndirectedGraphNode(i));
		cgv[0]->neighbors.push_back(cgv[1]);
		cgv[0]->neighbors.push_back(cgv[2]);
		cgv[1]->neighbors.push_back(cgv[0]);
		cgv[1]->neighbors.push_back(cgv[2]);
		cgv[2]->neighbors.push_back(cgv[0]);
		cgv[2]->neighbors.push_back(cgv[1]);
		cgv[2]->neighbors.push_back(cgv[2]);
		CloneGraph::UndirectedGraphNode * clonedGraph1 = CloneGraph().DFS(cgv[0]);
		CloneGraph::UndirectedGraphNode * clonedGraph2 = CloneGraph().BFS(cgv[0]);
		CloneGraph::DeleteGraph(cgv[0]);
		CloneGraph::DeleteGraph(clonedGraph1);
		CloneGraph::DeleteGraph(clonedGraph2);
	}
	{
		/*
		  4
		  |
		  1    3
		 / \
		0---2
		*/
		std::vector<TrianglesInGraph::UndirectedGraphNode *> graph;
		for (int i = 0; i <= 4; ++i)
			graph.push_back(new TrianglesInGraph::UndirectedGraphNode(i));
		graph[0]->neighbors.push_back(graph[1]);
		graph[0]->neighbors.push_back(graph[2]);
		graph[1]->neighbors.push_back(graph[0]);
		graph[1]->neighbors.push_back(graph[2]);
		graph[1]->neighbors.push_back(graph[4]);
		graph[2]->neighbors.push_back(graph[0]);
		graph[2]->neighbors.push_back(graph[1]);
		graph[4]->neighbors.push_back(graph[1]);
		TrianglesInGraph().Count_BFS(graph[0]);
		TrianglesInGraph::DeleteGraph(graph[0]);

		/*
		    1-------4
		   /|\    / |\
		  / | \ /   | \
		 /  | /\    |  \
		0---2   \   |   6
		 \\-|----\--|--//
		  \ |     \ |  /
		   \|      \| /
			3-------5
		*/
		std::vector<TrianglesInGraph::UndirectedGraphNode *> graph2;
		for (int i = 0; i <= 6; ++i)
			graph2.push_back(new TrianglesInGraph::UndirectedGraphNode(i));
		graph2[0]->neighbors.push_back(graph2[1]);
		graph2[0]->neighbors.push_back(graph2[2]);
		graph2[0]->neighbors.push_back(graph2[3]);
		graph2[0]->neighbors.push_back(graph2[6]);
		graph2[1]->neighbors.push_back(graph2[0]);
		graph2[1]->neighbors.push_back(graph2[2]);
		graph2[1]->neighbors.push_back(graph2[4]);
		graph2[1]->neighbors.push_back(graph2[5]);
		graph2[2]->neighbors.push_back(graph2[0]);
		graph2[2]->neighbors.push_back(graph2[1]);
		graph2[2]->neighbors.push_back(graph2[3]);
		graph2[2]->neighbors.push_back(graph2[4]);
		graph2[3]->neighbors.push_back(graph2[0]);
		graph2[3]->neighbors.push_back(graph2[2]);
		graph2[3]->neighbors.push_back(graph2[5]);
		graph2[4]->neighbors.push_back(graph2[1]);
		graph2[4]->neighbors.push_back(graph2[2]);
		graph2[4]->neighbors.push_back(graph2[5]);
		graph2[4]->neighbors.push_back(graph2[6]);
		graph2[5]->neighbors.push_back(graph2[1]);
		graph2[5]->neighbors.push_back(graph2[3]);
		graph2[5]->neighbors.push_back(graph2[4]);
		graph2[5]->neighbors.push_back(graph2[6]);
		graph2[6]->neighbors.push_back(graph2[0]);
		graph2[6]->neighbors.push_back(graph2[4]);
		graph2[6]->neighbors.push_back(graph2[5]);
		TrianglesInGraph().Count_BFS(graph2[0]);
		TrianglesInGraph::DeleteGraph(graph2[0]);

		TrianglesInGraph().Count_AdjacencyList(std::vector<std::vector<int >>(
		{
			{ 1, 2 },//vertex 0
			{ 0, 2, 4 },//vertex 1
			{ 0, 1 },//vertex 2
			{ },//vertex 3
			{ 1 }//vertex 4
		}));
		TrianglesInGraph().Count_AdjacencyList(std::vector<std::vector<int >>(
		{
			{ 1, 2, 3, 6 },//vertex 0
			{ 0, 2, 4, 5 },//vertex 1
			{ 0, 1, 3, 4 },//vertex 2
			{ 0, 2, 5 },//vertex 3
			{ 1, 2, 5, 6 },//vertex 4
			{ 1, 3, 4, 6 },//vertex 5
			{ 0, 4, 5 }//vertex 6
		}));

		TrianglesInGraph().Count_AdjacencyMatrix(std::vector<std::vector<int >>(
		{
			{0, 1, 1, 0},//vertex 0
			{1, 0, 1, 1},//vertex 1
			{1, 1, 0, 0},//vertex 2
			{0, 0, 0, 0},//vertex 3
			{0, 1, 0, 0}//vertex 4
		}));
		TrianglesInGraph().Count_AdjacencyMatrix(std::vector<std::vector<int >>(
		{
			{ 0, 1, 1, 1, 0, 0, 1 },//vertex 0
			{ 1, 0, 1, 0, 1, 1, 0 },//vertex 1
			{ 1, 1, 0, 1, 1, 0, 0 },//vertex 2
			{ 1, 0, 1, 0, 0, 1, 0 },//vertex 3
			{ 0, 1, 1, 0, 0, 1, 1 },//vertex 4
			{ 0, 1, 0, 1, 1, 0, 1 },//vertex 5
			{ 1, 0, 0, 0, 1, 1, 0 }//vertex 6
		}));
	}

	{
		/*
		1      3----4
		|     / \
		0----2   6
		      \
		       5----7
		*/
		GraphSearch().BFS_Undirected_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 0, 0, 0, 0, 0 },//vertex 0
			{ 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 0, 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 1, 0, 1, 0, 1, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 0, 0 },//vertex 4
			{ 0, 0, 1, 0, 0, 0, 0, 1 },//vertex 5
			{ 0, 0, 0, 1, 0, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 1, 0, 0 },//vertex 7
		}));
		GraphSearch().DFS_Undirected_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 0, 0, 0, 0, 0 },//vertex 0
			{ 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 0, 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 1, 0, 1, 0, 1, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 0, 0 },//vertex 4
			{ 0, 0, 1, 0, 0, 0, 0, 1 },//vertex 5
			{ 0, 0, 0, 1, 0, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 1, 0, 0 },//vertex 7
		}));
		/*
		      2-----3-----------
		          /   \         |
		        /       \       |
		4-----10----9-----8     1
		|     | \   |   /     /
		|     |   \ | /     /
		5-----6-----7-----0
		*/
		GraphSearch().BFS_Undirected_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0 },//vertex 0
			{ 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1 },//vertex 3
			{ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 },//vertex 4
			{ 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1 },//vertex 6
			{ 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1 },//vertex 7
			{ 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0 },//vertex 8
			{ 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1 },//vertex 9
			{ 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0 },//vertex 10
		}));
		GraphSearch().DFS_Undirected_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0 },//vertex 0
			{ 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1 },//vertex 3
			{ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 },//vertex 4
			{ 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1 },//vertex 6
			{ 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1 },//vertex 7
			{ 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0 },//vertex 8
			{ 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1 },//vertex 9
			{ 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0 },//vertex 10
		}));
		/*
		            3----4----6
		           /
		0----1----2
		           \
				    5----7
		*/
		GraphSearch().DFS_Undirected_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 0, 1, 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 1, 0, 1, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 1, 0 },//vertex 4
			{ 0, 0, 1, 0, 0, 0, 0, 1 },//vertex 5
			{ 0, 0, 0, 0, 1, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 1, 0, 0 },//vertex 7
		}));
		/*
		   -----    3----4----6
		 /       \ /        /
		0----1----2      /
		           \  /
		            5----7
		*/
		GraphSearch().DFS_Undirected_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 0, 0, 0, 0, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 1, 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 1, 0, 1, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 1, 0 },//vertex 4
			{ 0, 0, 1, 0, 0, 0, 1, 1 },//vertex 5
			{ 0, 0, 0, 0, 1, 1, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 1, 0, 0 },//vertex 7
		}));
		/*
		                -------
		               /       \
					  v         v
		    -----     3--->4--->6
		   /     \   ^^
		  v       \ / |
		 0--->1--->2  |     ---
		            \ |    |   |
					 v|    v   |
		              5--->7---
		*/
		GraphSearch().DFS_Directed_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 0, 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 0, 0, 1, 0, 1, 0 },//vertex 3
			{ 0, 0, 0, 0, 0, 0, 1, 0 },//vertex 4
			{ 0, 0, 0, 1, 0, 0, 0, 1 },//vertex 5
			{ 0, 0, 0, 1, 0, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 0, 0, 1 },//vertex 7
		}));
		StronglyConnectedComponents().Tarjan_DFS_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 0, 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 0, 0, 1, 0, 1, 0 },//vertex 3
			{ 0, 0, 0, 0, 0, 0, 1, 0 },//vertex 4
			{ 0, 0, 0, 1, 0, 0, 0, 1 },//vertex 5
			{ 0, 0, 0, 1, 0, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 0, 0, 1 },//vertex 7
		}));
		StronglyConnectedComponents().Kosaraju_DFS_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 0, 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 0, 0, 1, 0, 1, 0 },//vertex 3
			{ 0, 0, 0, 0, 0, 0, 1, 0 },//vertex 4
			{ 0, 0, 0, 1, 0, 0, 0, 1 },//vertex 5
			{ 0, 0, 0, 1, 0, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 0, 0, 1 },//vertex 7
		}));
		/*
		0<---2<---5<-->6
		|   ^^    ^    ^
		|  / |    |    |
		v /  |    |    |
		1<---3<-->4<---7<--
		               |   |
                        ---
		*/
		GraphSearch().DFS_Directed_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 0, 1, 1, 0, 1, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 1, 0, 0 },//vertex 4
			{ 0, 0, 1, 0, 0, 0, 1, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 1, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 1, 0, 1, 1 },//vertex 7
		}));
		StronglyConnectedComponents().Tarjan_DFS_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 0, 1, 1, 0, 1, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 1, 0, 0 },//vertex 4
			{ 0, 0, 1, 0, 0, 0, 1, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 1, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 1, 0, 1, 1 },//vertex 7
		}));
		StronglyConnectedComponents().Kosaraju_DFS_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 0, 1, 1, 0, 1, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 1, 0, 0 },//vertex 4
			{ 0, 0, 1, 0, 0, 0, 1, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 1, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 1, 0, 1, 1 },//vertex 7
		}));
	}
	{
		/*
		1---0---3   5
		| /     |
		2       4
		*/
		EulerianGraph().Undirected_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 1, 0, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0 },//vertex 1
			{ 1, 1, 0, 0, 0, 0 },//vertex 2
			{ 1, 0, 0, 0, 1, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0 },//vertex 5
		}));
		EulerianGraph().Fleury_FindEulerPath_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 1, 0, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0 },//vertex 1
			{ 1, 1, 0, 0, 0, 0 },//vertex 2
			{ 1, 0, 0, 0, 1, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0 },//vertex 5
		}));
		/*
		1---0---3   5
		| /   \ |
		2       4
		*/
		EulerianGraph().Undirected_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 1, 1, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0 },//vertex 1
			{ 1, 1, 0, 0, 0, 0 },//vertex 2
			{ 1, 0, 0, 0, 1, 0 },//vertex 3
			{ 1, 0, 0, 1, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0 },//vertex 5
		}));
		EulerianGraph().Fleury_FindEulerPath_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 1, 1, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0 },//vertex 1
			{ 1, 1, 0, 0, 0, 0 },//vertex 2
			{ 1, 0, 0, 0, 1, 0 },//vertex 3
			{ 1, 0, 0, 1, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0 },//vertex 5
		}));
		/*
		   ---
		 /     \
		1---0---3   5
		| /     |
		2       4
		*/
		EulerianGraph().Undirected_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 1, 0, 0 },//vertex 0
			{ 1, 0, 1, 1, 0, 0 },//vertex 1
			{ 1, 1, 0, 0, 0, 0 },//vertex 2
			{ 1, 1, 0, 0, 1, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0 },//vertex 5
		}));
		/*
		               -------
		              /       \
		             v         v
		   -----     3--->4--->6
		  /     \   ^^
		 v       \ / |
		0--->1--->2  |
		           \ |
		            v|
		             5--->7
		*/
		EulerianGraph().Directed_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 0, 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 0, 0, 1, 0, 1, 0 },//vertex 3
			{ 0, 0, 0, 0, 0, 0, 1, 0 },//vertex 4
			{ 0, 0, 0, 1, 0, 0, 0, 1 },//vertex 5
			{ 0, 0, 0, 1, 0, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 7
		}));
		/*
		0<---2<---5<-->6
		|   ^^    ^    ^
		|  / |    |    |
		v /  |    |    |
		1<---3<-->4<---7<--
		               |   |
		                ---
		*/
		EulerianGraph().Directed_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 0, 1, 1, 0, 1, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 1, 0, 0 },//vertex 4
			{ 0, 0, 1, 0, 0, 0, 1, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 1, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 1, 0, 1, 1 },//vertex 7
		}));
		/*
		1<--0<--3   5
		|  ^    ^
		| /     |
		v/      |
		2       4
		*/
		EulerianGraph().Directed_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 1, 0, 0, 0 },//vertex 1
			{ 1, 0, 0, 0, 0, 0 },//vertex 2
			{ 1, 0, 0, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0 },//vertex 5
		}));
		/*
		1<--0<--3   5
		|  ^ \  ^
		| /   \ |
		v/     v|
		2       4
		*/
		EulerianGraph().Directed_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 1, 0 },//vertex 0
			{ 0, 0, 1, 0, 0, 0 },//vertex 1
			{ 1, 0, 0, 0, 0, 0 },//vertex 2
			{ 1, 0, 0, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0 },//vertex 5
		}));
		/*
		   ----
		  /    \
		 /      v
		1<--0<--3   5
		|  ^    ^
		| /     |
		v/      |
		2       4
		*/
		EulerianGraph().Directed_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 1, 1, 0, 0 },//vertex 1
			{ 1, 0, 0, 0, 0, 0 },//vertex 2
			{ 1, 0, 0, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0 },//vertex 5
		}));
		/*
		a-->c<->e
		    |
			v
			d-->f
		*/
		ConnectAllStrInChain().ExistEulerPathInDigraph(std::vector<std::string>(
		{
			"abc", "cde", "cad", "def", "eac"
		}));
		/*
		c-->e
		| /
		vv
		d-->f-->b
		*/
		ConnectAllStrInChain().ExistEulerPathInDigraph(std::vector<std::string>(
		{
			"fcb", "cde", "cad", "def", "ead"
		}));
		/*
		a<-->k--->l
		| ^   ^   |
		|  \   \  |
		|    \  \ |
		v      \ \v
		b--->c--->f<--
		|         |   |
		v          ---
		d
		*/
		ConnectAllStrInChain().ExistEulerPathInDigraph(std::vector<std::string>(
		{
			"bd", "fk", "ab", "kl", "cf", "ff", "fa", "ak", "ka", "lf", "bc"
		}));
	}
	{
		/*
		5---->0<----4
		|           |
		|           |
		v           v
		2---->3---->1
		*/
		std::vector<int> topoOrdering1 = TopologicalSortDAG().DFS_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 1, 0, 0 },//vertex 2
			{ 0, 1, 0, 0, 0, 0 },//vertex 3
			{ 1, 1, 0, 0, 0, 0 },//vertex 4
			{ 1, 0, 1, 0, 0, 0 },//vertex 5
		}));
        std::vector<int> topoOrdering11 = TopologicalSortDAG().BFS_AdjacencyMatrix(std::vector<std::vector<int>>(
        {
                { 0, 0, 0, 0, 0, 0 },//vertex 0
                { 0, 0, 0, 0, 0, 0 },//vertex 1
                { 0, 0, 0, 1, 0, 0 },//vertex 2
                { 0, 1, 0, 0, 0, 0 },//vertex 3
                { 1, 1, 0, 0, 0, 0 },//vertex 4
                { 1, 0, 1, 0, 0, 0 },//vertex 5
        }));
		UniqueTopologicalOrdering().CheckMissedEdges(topoOrdering1, std::vector<std::vector<int>>(
		{
			{ 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 1, 0, 0 },//vertex 2
			{ 0, 1, 0, 0, 0, 0 },//vertex 3
			{ 1, 1, 0, 0, 0, 0 },//vertex 4
			{ 1, 0, 1, 0, 0, 0 },//vertex 5
		}));
		/*
		---------------------
		|                   |
		v                   |
		1-------->3         |
		|         |         |
		|         |         |
		v         v         |
		2-------->4<--------0
		*/
		std::vector<int> topoOrdering2 = TopologicalSortDAG().DFS_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 1 },//vertex 0
			{ 0, 0, 1, 1, 1 },//vertex 1
			{ 0, 0, 0, 0, 1 },//vertex 2
			{ 0, 0, 0, 0, 1 },//vertex 3
			{ 0, 0, 0, 0, 0 },//vertex 4
		}));
        std::vector<int> topoOrdering22 = TopologicalSortDAG().BFS_AdjacencyMatrix(std::vector<std::vector<int>>(
        {
                { 0, 1, 0, 0, 1 },//vertex 0
                { 0, 0, 1, 1, 1 },//vertex 1
                { 0, 0, 0, 0, 1 },//vertex 2
                { 0, 0, 0, 0, 1 },//vertex 3
                { 0, 0, 0, 0, 0 },//vertex 4
        }));
		UniqueTopologicalOrdering().CheckMissedEdges(topoOrdering2, std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 1 },//vertex 0
			{ 0, 0, 1, 1, 1 },//vertex 1
			{ 0, 0, 0, 0, 1 },//vertex 2
			{ 0, 0, 0, 0, 1 },//vertex 3
			{ 0, 0, 0, 0, 0 },//vertex 4
		}));
		/*
		5->4->3->2->4->0->1->3->5

		-------------------------
		|       --------2       |
		|       |       ^       |
		|       |       |(1)    |
		v       v  (1)  |   (2) |
		5------>4------>3--------
		        |(2)    ^
		        |       |
		        v       |
		        0------>1
		*/
		//TopologicalSortDAG().DFS_AdjacencyMatrix(std::vector<std::vector<int>>(
		//{
		//	//{1},//vertex 0
		//	//{3},//vertex 1
		//	//{4},//vertex 2
		//	//{2,5},//vertex 3
		//	//{3,0},//vertex 4
		//	//{4}//vertex 5
		//	//{ 0, 1, 0, 0, 0, 0 },//vertex 0
		//	//{ 0, 0, 0, 1, 0, 0 },//vertex 1
		//	//{ 0, 0, 0, 0, 1, 0 },//vertex 2
		//	//{ 0, 0, 1, 0, 0, 2 },//vertex 3
		//	//{ 2, 0, 0, 1, 0, 0 },//vertex 4
		//	//{ 0, 0, 0, 0, 1, 0 },//vertex 5
		//}));
	}
	{
		/*
		1   0---3---5
		|       | \ |
		2       4   6
		*/
		CyclicGraph().Undirected_UnionFind_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 0, 0, 1, 0, 0, 0 },//vertex 0
			{ 0, 0, 1, 0, 0, 0, 0 },//vertex 1
			{ 0, 1, 0, 0, 0, 0, 0 },//vertex 2
			{ 1, 0, 0, 0, 1, 1, 1 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 0 },//vertex 4
			{ 0, 0, 0, 1, 0, 0, 1 },//vertex 5
			{ 0, 0, 0, 1, 0, 1, 0 },//vertex 6
		}));
		CyclicGraph().Undirected_UnionFindOptimized_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 0, 0, 1, 0, 0, 0 },//vertex 0
			{ 0, 0, 1, 0, 0, 0, 0 },//vertex 1
			{ 0, 1, 0, 0, 0, 0, 0 },//vertex 2
			{ 1, 0, 0, 0, 1, 1, 1 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 0 },//vertex 4
			{ 0, 0, 0, 1, 0, 0, 1 },//vertex 5
			{ 0, 0, 0, 1, 0, 1, 0 },//vertex 6
		}));
		CyclicGraph().Undirected_DFS_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 0, 0, 1, 0, 0, 0 },//vertex 0
			{ 0, 0, 1, 0, 0, 0, 0 },//vertex 1
			{ 0, 1, 0, 0, 0, 0, 0 },//vertex 2
			{ 1, 0, 0, 0, 1, 1, 1 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 0 },//vertex 4
			{ 0, 0, 0, 1, 0, 0, 1 },//vertex 5
			{ 0, 0, 0, 1, 0, 1, 0 },//vertex 6
		}));
		/*
		5---->0<----4
		| \         |
		|     \     |
		v         v v
		2---->3---->1
		*/
		CyclicGraph().Directed_DFS_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 1, 0, 0 },//vertex 2
			{ 0, 1, 0, 0, 0, 0 },//vertex 3
			{ 1, 1, 0, 0, 0, 0 },//vertex 4
			{ 1, 1, 1, 0, 0, 0 },//vertex 5
		}));
	}
	{
		/*
		          24   15   31
		        -----3----4----6
		  11  / 46 5/ \   39  /
		0----1-----2    -----
		 \        / \52
		   ------    5----7
		     48        60
		Only 1 possible min spanning tree:
		          24   15   31
		        -----3----4----6
		  11  /    5/
		0----1     2
		            \52
		             5----7
		               60
		*/
		MinSpanningTree().Kruskal_UnionFind_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 11, 48, 0, 0, 0, 0, 0 },//vertex 0
			{ 11, 0, 46, 24, 0, 0, 0, 0 },//vertex 1
			{ 48, 46, 0, 5, 0, 52, 0, 0 },//vertex 2
			{ 0, 24, 5, 0, 15, 0, 39, 0 },//vertex 3
			{ 0, 0, 0, 15, 0, 0, 31, 0 },//vertex 4
			{ 0, 0, 52, 0, 0, 0, 0, 60 },//vertex 5
			{ 0, 0, 0, 39, 31, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 60, 0, 0 },//vertex 7
		}));
		MinSpanningTree().Kruskal_UnionFind2_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 11, 48, 0, 0, 0, 0, 0 },//vertex 0
			{ 11, 0, 46, 24, 0, 0, 0, 0 },//vertex 1
			{ 48, 46, 0, 5, 0, 52, 0, 0 },//vertex 2
			{ 0, 24, 5, 0, 15, 0, 39, 0 },//vertex 3
			{ 0, 0, 0, 15, 0, 0, 31, 0 },//vertex 4
			{ 0, 0, 52, 0, 0, 0, 0, 60 },//vertex 5
			{ 0, 0, 0, 39, 31, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 60, 0, 0 },//vertex 7
		}));
		MinSpanningTree().Prim_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 11, 48, 0, 0, 0, 0, 0 },//vertex 0
			{ 11, 0, 46, 24, 0, 0, 0, 0 },//vertex 1
			{ 48, 46, 0, 5, 0, 52, 0, 0 },//vertex 2
			{ 0, 24, 5, 0, 15, 0, 39, 0 },//vertex 3
			{ 0, 0, 0, 15, 0, 0, 31, 0 },//vertex 4
			{ 0, 0, 52, 0, 0, 0, 0, 60 },//vertex 5
			{ 0, 0, 0, 39, 31, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 60, 0, 0 },//vertex 7
		}), 3);
		/*    8   7
		    1---2---3
		 4/ |  2|\  | \9
		0   |11 8 \4|14 4
		 8\ | /7|6 \| /10
		    7---6---5
			  1   2
		2 possible min spanning trees:
			      7
		    1   2---3
		 4/    2|\    \9
		0       8 \4    4
		 8\        \
		    7---6---5
			  1   2
			  8   7
		    1---2---3
		 4/    2|\    \9
		0       8 \4    4
		           \
		    7---6---5
			  1   2
		*/
		MinSpanningTree().Kruskal_UnionFind_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 4, 0, 0, 0, 0, 0, 8, 0 },//vertex 0
			{ 4, 8, 0, 0, 0, 0, 0, 11, 0 },//vertex 1
			{ 0, 8, 0, 7, 0, 4, 0, 0, 2 },//vertex 2
			{ 0, 0, 7, 0, 9, 14, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 9, 0, 10, 0, 0, 0 },//vertex 4
			{ 0, 0, 4, 14, 10, 0, 2, 0, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 2, 0, 1, 6 },//vertex 6
			{ 8, 11, 0, 0, 0, 0, 1, 0, 7 },//vertex 7
			{ 0, 0, 2, 0, 0, 0, 6, 7, 0 },//vertex 8
		}));
		MinSpanningTree().Kruskal_UnionFind2_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 4, 0, 0, 0, 0, 0, 8, 0 },//vertex 0
			{ 4, 8, 0, 0, 0, 0, 0, 11, 0 },//vertex 1
			{ 0, 8, 0, 7, 0, 4, 0, 0, 2 },//vertex 2
			{ 0, 0, 7, 0, 9, 14, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 9, 0, 10, 0, 0, 0 },//vertex 4
			{ 0, 0, 4, 14, 10, 0, 2, 0, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 2, 0, 1, 6 },//vertex 6
			{ 8, 11, 0, 0, 0, 0, 1, 0, 7 },//vertex 7
			{ 0, 0, 2, 0, 0, 0, 6, 7, 0 },//vertex 8
		}));
		MinSpanningTree().Prim_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 4, 0, 0, 0, 0, 0, 8, 0 },//vertex 0
			{ 4, 8, 0, 0, 0, 0, 0, 11, 0 },//vertex 1
			{ 0, 8, 0, 7, 0, 4, 0, 0, 2 },//vertex 2
			{ 0, 0, 7, 0, 9, 14, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 9, 0, 10, 0, 0, 0 },//vertex 4
			{ 0, 0, 4, 14, 10, 0, 2, 0, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 2, 0, 1, 6 },//vertex 6
			{ 8, 11, 0, 0, 0, 0, 1, 0, 7 },//vertex 7
			{ 0, 0, 2, 0, 0, 0, 6, 7, 0 },//vertex 8
		}), 3);
		MinSpanningTree().Prim_AdjacencyList(std::vector<std::vector<std::pair<int, int>>>(
		{
			{ { 4, 1 }, { 8, 7 } },//vertex 0
			{ { 4, 0 }, { 8, 1 }, { 11, 7 } },//vertex 1
			{ { 8, 1 }, { 7, 3 }, { 4, 5 }, { 2, 8 } },//vertex 2
			{ { 7, 2 }, { 9, 4 }, { 14, 5 } },//vertex 3
			{ { 9, 3 }, { 10, 5 } },//vertex 4
			{ { 4, 2 }, { 14, 3 }, { 10, 4 }, { 2, 6 } },//vertex 5
			{ { 2, 5 }, { 1, 7 }, { 6, 8 } },//vertex 6
			{ { 8, 0 }, { 11, 1 }, { 1, 6 }, { 7, 8 } },//vertex 7
			{ { 2, 2 }, { 6, 6 }, { 7, 7 } }//vertex 8
		}), 0);

	}
	{
		/*
		           9
		       5------4
		     / |     /|
		 14/  2|  7/  |
		 /  9  | /    |
		0------2    -6|
		 \     | \    |
		  7\ 10| 11\  |
		     \ |     \|
		       1------3
		          15
		*/
		ShortestPathInGraph().BellmanFord_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 7, 9, 0, 0, 14 },//vertex 0
			{ 7, 0, 10, 15, 0, 0 },//vertex 1
			{ 9, 10, 0, 11, 7, 2 },//vertex 2
			{ 0, 15, 11, 0, -6, 0 },//vertex 3
			{ 0, 0, 7, -6, 0, 9 },//vertex 4
			{ 14, 0, 2, 0, 9, 0 },//vertex 5
		}), 0);
		/*
		          9
		       5----->4
		     ^ ^     ^^
		 14/  2|  7/  |
		 /  9  | /    |
		0----->2    -6|
		 \     | \    |
		  7\ 10| 11\  |
		     v v     v|
		       1----->3
		          15
		*/
		ShortestPathInGraph().BellmanFord_DAGAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 7, 9, 0, 0, 14 },//vertex 0
			{ 0, 0, 0, 15, 0, 0 },//vertex 1
			{ 0, 10, 0, 11, 7, 2 },//vertex 2
			{ 0, 0, 0, 0, -6, 0 },//vertex 3
			{ 0, 0, 0, 0, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 9, 0 },//vertex 5
		}), 0);
		AllPairsShortestPaths().FloydWarshall_DP2D_DAGAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 7, 9, 0, 0, 14 },//vertex 0
			{ 0, 0, 0, 15, 0, 0 },//vertex 1
			{ 0, 10, 0, 11, 7, 2 },//vertex 2
			{ 0, 0, 0, 0, -6, 0 },//vertex 3
			{ 0, 0, 0, 0, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 9, 0 },//vertex 5
		}));
		AllPairsShortestPaths().Johnson_DAGAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 7, 9, 0, 0, 14 },//vertex 0
			{ 0, 0, 0, 15, 0, 0 },//vertex 1
			{ 0, 10, 0, 11, 7, 2 },//vertex 2
			{ 0, 0, 0, 0, -6, 0 },//vertex 3
			{ 0, 0, 0, 0, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 9, 0 },//vertex 5
		}));
		/*
		           9
		       5------4
		     / |      |
		 14/  2|      |
		 /  9  |      |
		0------2     6|
		 \     | \    |
		  7\ 10| 11\  |
		     \ |     \|
		       1------3
		          15
		*/
		ShortestPathInGraph().BellmanFord_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 7, 9, 0, 0, 14 },//vertex 0
			{ 7, 0, 10, 15, 0, 0 },//vertex 1
			{ 9, 10, 0, 11, 0, 2 },//vertex 2
			{ 0, 15, 11, 0, 6, 0 },//vertex 3
			{ 0, 0, 0, 6, 0, 9 },//vertex 4
			{ 14, 0, 2, 0, 9, 0 },//vertex 5
		}), 0);
		ShortestPathInGraph().Dijkstra_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 7, 9, 0, 0, 14 },//vertex 0
			{ 7, 0, 10, 15, 0, 0 },//vertex 1
			{ 9, 10, 0, 11, 0, 2 },//vertex 2
			{ 0, 15, 11, 0, 6, 0 },//vertex 3
			{ 0, 0, 0, 6, 0, 9 },//vertex 4
			{ 14, 0, 2, 0, 9, 0 },//vertex 5
		}), 0);
		ShortestPathInGraph().Dijkstra_MinHeap_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 7, 9, 0, 0, 14 },//vertex 0
			{ 7, 0, 10, 15, 0, 0 },//vertex 1
			{ 9, 10, 0, 11, 0, 2 },//vertex 2
			{ 0, 15, 11, 0, 6, 0 },//vertex 3
			{ 0, 0, 0, 6, 0, 9 },//vertex 4
			{ 14, 0, 2, 0, 9, 0 },//vertex 5
		}), 0);
		ShortestPathInGraph().Dijkstra_MinHeap_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 7, 9, 0, 0, 14 },//vertex 0
			{ 7, 0, 10, 15, 0, 0 },//vertex 1
			{ 9, 10, 0, 11, 0, 2 },//vertex 2
			{ 0, 15, 11, 0, 6, 0 },//vertex 3
			{ 0, 0, 0, 6, 0, 9 },//vertex 4
			{ 14, 0, 2, 0, 9, 0 },//vertex 5
		}), 0, 4);
		ShortestPathInGraph().Dijkstra_MinHeap_UndirectedAdjacencyList(std::vector<std::vector<std::pair<int, int>>>(
		{
			{ { 7, 1 }, { 9, 2 }, { 14, 5 } },//vertex 0
			{ { 7, 0 }, { 10, 2 }, { 15, 3 } },//vertex 1
			{ { 9, 0 }, { 10, 1 }, { 11, 3 }, { 2, 5 } },//vertex 2
			{ { 15, 1 }, { 11, 2 }, { 6, 4 } },//vertex 3
			{ { 6, 3 }, { 9, 5 } },//vertex 4
			{ { 14, 0 }, { 2, 2 }, { 9, 4 } }//vertex 5
		}), 0, 4);

		/*
		           9
		       5------4
		     / |      |
		 11/  2|      |
		 /  9  |      |
		0------2     6|
		 \     | \    |
		  7\ 10| 11\  |
		     \ |     \|
		       1------3
		          15
		*/
		ShortestPathInGraph().Dijkstra_MinEdges_MinHeap_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 7, 9, 0, 0, 11 },//vertex 0
			{ 7, 0, 10, 15, 0, 0 },//vertex 1
			{ 9, 10, 0, 11, 0, 2 },//vertex 2
			{ 0, 15, 11, 0, 6, 0 },//vertex 3
			{ 0, 0, 0, 6, 0, 9 },//vertex 4
			{ 11, 0, 2, 0, 9, 0 },//vertex 5
		}), 0, 4);

		AllPairsShortestPaths().FloydWarshall_DP2D_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 7, 9, 0, 0, 14 },//vertex 0
			{ 7, 0, 10, 15, 0, 0 },//vertex 1
			{ 9, 10, 0, 11, 0, 2 },//vertex 2
			{ 0, 15, 11, 0, 6, 0 },//vertex 3
			{ 0, 0, 0, 6, 0, 9 },//vertex 4
			{ 14, 0, 2, 0, 9, 0 },//vertex 5
		}));
		AllPairsShortestPaths().Johnson_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 7, 9, 0, 0, 14 },//vertex 0
			{ 7, 0, 10, 15, 0, 0 },//vertex 1
			{ 9, 10, 0, 11, 0, 2 },//vertex 2
			{ 0, 15, 11, 0, 6, 0 },//vertex 3
			{ 0, 0, 0, 6, 0, 9 },//vertex 4
			{ 14, 0, 2, 0, 9, 0 },//vertex 5
		}));
		

		/*
		   4    5    2
		0<---3<---6<---8
		  3/   7/     / ^
		 v 3  v     /     \3
		1<---4   6/    7    10
		 ^      /      ^  /9
		  3\  v       5|v
		2<---5<--------9
		   1       6
		*/
		AllPairsShortestPaths().FloydWarshall_DP2D_DAGAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 3
			{ 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 4
			{ 0, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 0, 5, 7, 0, 0, 0, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 7
			{ 0, 0, 0, 0, 0, 6, 2, 0, 0, 0, 0 },//vertex 8
			{ 0, 0, 0, 0, 0, 6, 0, 5, 0, 0, 0 },//vertex 9
			{ 0, 0, 0, 0, 0, 0, 0, 0, 3, 9, 0 },//vertex 10
		}));
		AllPairsShortestPaths().Johnson_DAGAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 3
			{ 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 4
			{ 0, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 0, 5, 7, 0, 0, 0, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 7
			{ 0, 0, 0, 0, 0, 6, 2, 0, 0, 0, 0 },//vertex 8
			{ 0, 0, 0, 0, 0, 6, 0, 5, 0, 0, 0 },//vertex 9
			{ 0, 0, 0, 0, 0, 0, 0, 0, 3, 9, 0 },//vertex 10
		}));

		/*
		    -5
		0--------->1
		|  \       |
		|3    \2   |4
		v        v v
		3<---------2
		     1
		*/
		AllPairsShortestPaths().FloydWarshall_DP2D_DAGAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, -5, 2, 3 },//vertex 0
			{ 0, 0, 4, 0 },//vertex 1
			{ 0, 0, 0, 1 },//vertex 2
			{ 0, 0, 0, 0 },//vertex 3
		}));
		AllPairsShortestPaths().Johnson_DAGAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, -5, 2, 3 },//vertex 0
			{ 0, 0, 4, 0 },//vertex 1
			{ 0, 0, 0, 1 },//vertex 2
			{ 0, 0, 0, 0 },//vertex 3
		}));
		/*
		      2
		3-------->2
		^ ^  -3/ ^|
		|4  \/ /  |-7
		|  / /\6  |
		|v /5   \ v
		1<--------0
		      3
		*/
		AllPairsShortestPaths().FloydWarshall_DP2D_DAGAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 3, 0, 6 },//vertex 0
			{ 0, 0, 5, 4 },//vertex 1
			{ -7, -3, 0, 0 },//vertex 2
			{ 0, 0, 2, 0 },//vertex 3
		}));
		AllPairsShortestPaths().Johnson_DAGAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 3, 0, 6 },//vertex 0
			{ 0, 0, 5, 4 },//vertex 1
			{ -7, -3, 0, 0 },//vertex 2
			{ 0, 0, 2, 0 },//vertex 3
		}));
		/*
		-----------------
		|       8       |
		|   3       4   v
		0------>3<------4
		|^    7/|      ^
	  -4|  \ /  |1   /-5
		|  / \  |  /
		vv    2\v/
		1------>2
		    6
		*/
		AllPairsShortestPaths().FloydWarshall_DP2D_DAGAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, -4, 0, 3, 8 },//vertex 0
			{ 0, 0, 6, 0, 0 },//vertex 1
			{ 2, 0, 0, 0, -5 },//vertex 2
			{ 0, 7, 1, 0, 0 },//vertex 3
			{ 0, 0, 0, 4, 0 },//vertex 4
		}));
		AllPairsShortestPaths().Johnson_DAGAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, -4, 0, 3, 8 },//vertex 0
			{ 0, 0, 6, 0, 0 },//vertex 1
			{ 2, 0, 0, 0, -5 },//vertex 2
			{ 0, 7, 1, 0, 0 },//vertex 3
			{ 0, 0, 0, 4, 0 },//vertex 4
		}));
		/*
		-----------------
		|       8       |
		|   3       -4  v
		0------>3<------4
		|^    7/|      ^
	  -4|  \ /  |-1  /-5
		|  / \  |  /
		vv    2\v/
		1------>2
		    6
		*/
		AllPairsShortestPaths().FloydWarshall_DP2D_DAGAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, -4, 0, 3, 8 },//vertex 0
			{ 0, 0, 6, 0, 0 },//vertex 1
			{ 2, 0, 0, 0, -5 },//vertex 2
			{ 0, 7, -1, 0, 0 },//vertex 3
			{ 0, 0, 0, -4, 0 },//vertex 4
		}));
		AllPairsShortestPaths().Johnson_DAGAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, -4, 0, 3, 8 },//vertex 0
			{ 0, 0, 6, 0, 0 },//vertex 1
			{ 2, 0, 0, 0, -5 },//vertex 2
			{ 0, 7, -1, 0, 0 },//vertex 3
			{ 0, 0, 0, -4, 0 },//vertex 4
		}));
	}
	{
		EvaluateDivisions().calcEquation(std::vector<std::pair<std::string, std::string>>({ {"a","b"},{"b","c"} }), std::vector<double>({ 2.0,3.0 }), std::vector<std::pair<std::string, std::string>>({ {"a", "c"},{"b", "a"},{"a", "e"},{"a", "a"},{"x", "x"} }));
	}

	{
		/*
		   4    5    2
		0<---3<---6<---8
		  3/   7/     / ^
		 v 3  v     /     \3
		1<---4   6/    7    10
		 ^      /      ^  /9
		  3\  v       5|v
		2<---5<--------9
		   1       6
		*/
		LongestPathInDAG().DFS_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 3
			{ 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 4
			{ 0, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 0, 5, 7, 0, 0, 0, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 7
			{ 0, 0, 0, 0, 0, 6, 2, 0, 0, 0, 0 },//vertex 8
			{ 0, 0, 0, 0, 0, 6, 0, 5, 0, 0, 0 },//vertex 9
			{ 0, 0, 0, 0, 0, 0, 0, 0, 3, 9, 0 },//vertex 10
		}), 10);
		/*
		   3     4
		1---->4---->6
	   2| \9  |7 4/ |5
	    |   \ | /   |
		v  5 vvv  3 v
		0---->3---->8
	   9|   / | \   |
		| /3  |8 9\ |4
		vv  6 v  5 vv
		2---->5---->7
		*/
		LongestPathInDAG().DFS_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			//0, 1, 2, 3, 4, 5, 6, 7, 8
			{ 0, 0, 9, 5, 0, 0, 0, 0, 0 },//vertex 0
			{ 2, 0, 0, 9, 3, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 0, 0, 6, 0, 0, 0 },//vertex 2
			{ 0, 0, 3, 0, 0, 8, 0, 9, 3 },//vertex 3
			{ 0, 0, 0, 7, 0, 0, 4, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0, 0, 5, 0 },//vertex 5
			{ 0, 0, 0, 4, 0, 0, 0, 0, 5 },//vertex 6
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 7
			{ 0, 0, 0, 0, 0, 0, 0, 4, 0 },//vertex 8
		}), 1);
        /*
        0->1->2->3->4->5
        4->5
        */
        LongestPathInDAG().DFS_AdjacencyMatrix(std::vector<std::vector<int>>(
                {
                    {0,1,0,0,0,0},
                    {0,0,1,0,0,0},
                    {0,0,0,1,0,0},
                    {0,0,0,0,0,1},
                    {0,0,0,0,0,1},
                    {0,0,0,0,0,0},
                }));
	}
	{
		/*
		      2-----3-----------
		          /   \         |
		        /       \       |
		4-----10----9-----8     1
		|     | \   |   /     /
		|     |   \ | /     /
		5-----6-----7-----0
		*/
		VertexColoring().WelshPowell_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0 },//vertex 0
			{ 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1 },//vertex 3
			{ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 },//vertex 4
			{ 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1 },//vertex 6
			{ 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1 },//vertex 7
			{ 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0 },//vertex 8
			{ 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1 },//vertex 9
			{ 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0 },//vertex 10
		}));
		VertexColoring().BacktrackRecur_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0 },//vertex 0
			{ 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1 },//vertex 3
			{ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 },//vertex 4
			{ 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1 },//vertex 6
			{ 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1 },//vertex 7
			{ 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0 },//vertex 8
			{ 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1 },//vertex 9
			{ 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0 },//vertex 10
		}), 3);
		VertexColoring().GreedyIterate_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0 },//vertex 0
			{ 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1 },//vertex 3
			{ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 },//vertex 4
			{ 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1 },//vertex 6
			{ 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1 },//vertex 7
			{ 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0 },//vertex 8
			{ 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1 },//vertex 9
			{ 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0 },//vertex 10
		}));
	}
	{
		/*
		  1---2
		 /     \
		0       3
		 \     /
		  5---4
		*/
		BipartiteGraph().BFS_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 1 },//vertex 0
			{ 1, 0, 1, 0, 0, 0 },//vertex 1
			{ 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 1, 0, 1, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 1 },//vertex 4
			{ 1, 0, 0, 0, 1, 0 },//vertex 5
		}));
		BipartiteGraph().DFS_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 1 },//vertex 0
			{ 1, 0, 1, 0, 0, 0 },//vertex 1
			{ 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 1, 0, 1, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 1 },//vertex 4
			{ 1, 0, 0, 0, 1, 0 },//vertex 5
		}));
		/*
		  1---2
		 /    |
		0     |
		 \    |
		  4---3
		*/
		BipartiteGraph().BFS_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 1 },//vertex 0
			{ 1, 0, 1, 0, 0 },//vertex 1
			{ 0, 1, 0, 1, 0 },//vertex 2
			{ 0, 0, 1, 0, 1 },//vertex 3
			{ 1, 0, 0, 1, 0 },//vertex 4
		}));
		BipartiteGraph().DFS_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 1 },//vertex 0
			{ 1, 0, 1, 0, 0 },//vertex 1
			{ 0, 1, 0, 1, 0 },//vertex 2
			{ 0, 0, 1, 0, 1 },//vertex 3
			{ 1, 0, 0, 1, 0 },//vertex 4
		}));
	}

	{
		/*
		1---0---3   5   6   8
		| /     |       |   |
		2       4       7   9---10
		*/
		BridgesInGraph().FindAll_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },//vertex 7
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 },//vertex 8
			{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1 },//vertex 9
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 },//vertex 10
		}));
		BridgesInGraph().FindAll_Tarjan_DFS_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },//vertex 7
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 },//vertex 8
			{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1 },//vertex 9
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 },//vertex 10
		}));
		CutVerticesInGraph().FindAll_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },//vertex 7
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 },//vertex 8
			{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1 },//vertex 9
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 },//vertex 10
		}));
		CutVerticesInGraph().FindAll_Tarjan_DFS_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },//vertex 7
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 },//vertex 8
			{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1 },//vertex 9
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 },//vertex 10
		}));
		BiconnectedGraph().DFS_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },//vertex 7
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 },//vertex 8
			{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1 },//vertex 9
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 },//vertex 10
		}));
		/*
		   -----    3----4----6
		 /       \ /        /
		0----1----2      /
		           \  /
		            5----7
		*/
		BridgesInGraph().FindAll_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 0, 0, 0, 0, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 1, 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 1, 0, 1, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 1, 0 },//vertex 4
			{ 0, 0, 1, 0, 0, 0, 1, 1 },//vertex 5
			{ 0, 0, 0, 0, 1, 1, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 1, 0, 0 },//vertex 7
		}));
		BridgesInGraph().FindAll_Tarjan_DFS_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 0, 0, 0, 0, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 1, 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 1, 0, 1, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 1, 0 },//vertex 4
			{ 0, 0, 1, 0, 0, 0, 1, 1 },//vertex 5
			{ 0, 0, 0, 0, 1, 1, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 1, 0, 0 },//vertex 7
		}));
		CutVerticesInGraph().FindAll_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 0, 0, 0, 0, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 1, 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 1, 0, 1, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 1, 0 },//vertex 4
			{ 0, 0, 1, 0, 0, 0, 1, 1 },//vertex 5
			{ 0, 0, 0, 0, 1, 1, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 1, 0, 0 },//vertex 7
		}));
		CutVerticesInGraph().FindAll_Tarjan_DFS_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 0, 0, 0, 0, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 1, 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 1, 0, 1, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 1, 0 },//vertex 4
			{ 0, 0, 1, 0, 0, 0, 1, 1 },//vertex 5
			{ 0, 0, 0, 0, 1, 1, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 1, 0, 0 },//vertex 7
		}));
		BiconnectedGraph().DFS_UndirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 0, 0, 0, 0, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 1, 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 1, 0, 1, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 1, 0 },//vertex 4
			{ 0, 0, 1, 0, 0, 0, 1, 1 },//vertex 5
			{ 0, 0, 0, 0, 1, 1, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 1, 0, 0 },//vertex 7
		}));
	}
	{
		/*
		    ---> 1 ---
		10/      |     \9
		 /       |      v
		0        |1     3
		 \       |      ^
		10\      v     /11
		    ---> 2 ---
		residual graph for above:
		0->1->3 (9)
		0->2->3 (10)
		0->1->2->3 (1)
		    ---> 1 ---
		 0/      |     \0
		 /       |      v
		0        |0     3
		 \       |      ^
		 0\      v     /0
		    ---> 2 ---
		*/
		MaxFlowInFlowNetwork().FordFulkerson_ConnectedDirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 10, 10, 0 },//vertex 0
			{ 0, 0, 1, 9 },//vertex 1
			{ 0, 0, 0, 11 },//vertex 2
			{ 0, 0, 0, 0 },//vertex 3
		}), 0, 3);
		MinSTCutInFlowNetwork().FindAll_ConnectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 10, 10, 0 },//vertex 0
			{ 0, 0, 1, 9 },//vertex 1
			{ 0, 0, 0, 11 },//vertex 2
			{ 0, 0, 0, 0 },//vertex 3
		}), 0, 3);
		/*
		            9
		    ---> 1 ---> 3 ---
		10/     4|  \15 |15   \10
		 /   5   v  8 v v  10  v
		0------->6----->7----->5
		 \      4| ^    |15    ^
		15\      v   \6 v     /10
		    ---> 2 ---> 4 ---
			        16
		residual graph of above:
		0->1->3->5 (9)
		0->1->7->5 (1)
		0->2->4->5 (10)
		0->6->7->5 (5)
		0->2->4->6->7->5 (3)
		            0
		    ---> 1 ---> 3 ---
		 0/     4|  \14 |15   \1
		 /   0   v  0 v v   1  v
		0------->6----->7----->5
		 \      4| ^    |15    ^
		 2\      v   \3 v     /0
		    ---> 2 ---> 4 ---
			        3
		*/
		MaxFlowInFlowNetwork().FordFulkerson_ConnectedDirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 10, 15, 0, 0, 0, 5, 0 },//vertex 0
			{ 0, 0, 0, 9, 0, 0, 4, 15 },//vertex 1
			{ 0, 0, 0, 0, 16, 0, 0, 0 },//vertex 2
			{ 0, 0, 0, 0, 0, 10, 0, 15 },//vertex 3
			{ 0, 0, 0, 0, 0, 10, 6, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 4, 0, 0, 0, 0, 8 },//vertex 6
			{ 0, 0, 0, 0, 15, 10, 0, 0 },//vertex 7
		}), 0, 5);
		MinSTCutInFlowNetwork().FindAll_ConnectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 10, 15, 0, 0, 0, 5, 0 },//vertex 0
			{ 0, 0, 0, 9, 0, 0, 4, 15 },//vertex 1
			{ 0, 0, 0, 0, 16, 0, 0, 0 },//vertex 2
			{ 0, 0, 0, 0, 0, 10, 0, 15 },//vertex 3
			{ 0, 0, 0, 0, 0, 10, 6, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 4, 0, 0, 0, 0, 8 },//vertex 6
			{ 0, 0, 0, 0, 15, 10, 0, 0 },//vertex 7
		}), 0, 5);
		/*
		            12
		    ---> 1 ---> 3 ---
		16/     |^    / ^     \20
		 /      ||   /  |      v
		0     10||4 /9  |7      5
		 \      || /    |      ^
		13\     v|v     |     /4
		    ---> 2 ---> 4 ---
			        14
		residual graph for above:
		0->1->3->5 (12)
		0->2->4->5 (4)
		0->2->4->3->5 (7)
		            0
		    ---> 1 ---> 3 ---
		 4/     |^    / ^     \1
		 /      ||   /  |      v
		0     10||4 /9  |0      5
		 \      || /    |      ^
		 2\     v|v     |     /0
		    ---> 2 ---> 4 ---
			        3
		*/
		MaxFlowInFlowNetwork().FordFulkerson_ConnectedDirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 16, 13, 0, 0, 0 },//vertex 0
			{ 0, 0, 10, 12, 0, 0 },//vertex 1
			{ 0, 4, 0, 0, 14, 0 },//vertex 2
			{ 0, 0, 9, 0, 0, 20 },//vertex 3
			{ 0, 0, 0, 7, 0, 4 },//vertex 4
			{ 0, 0, 0, 0, 0, 0 },//vertex 5
		}), 0, 5);
		MinSTCutInFlowNetwork().FindAll_ConnectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 16, 13, 0, 0, 0 },//vertex 0
			{ 0, 0, 10, 12, 0, 0 },//vertex 1
			{ 0, 4, 0, 0, 14, 0 },//vertex 2
			{ 0, 0, 9, 0, 0, 20 },//vertex 3
			{ 0, 0, 0, 7, 0, 4 },//vertex 4
			{ 0, 0, 0, 0, 0, 0 },//vertex 5
		}), 0, 5);
	}
	{
		MaxBipartiteMatching().MaxApplicantJobMatching_BipartiteMatrix(std::vector<std::vector<int>>(
		{
		//job:0, 1, 2, 3, 4, 5
			{ 0, 1, 1, 0, 0, 0 },//applicant 0
			{ 1, 0, 0, 1, 0, 0 },//applicant 1
			{ 0, 0, 1, 0, 0, 0 },//applicant 2
			{ 0, 0, 1, 1, 0, 0 },//applicant 3
			{ 0, 0, 0, 0, 0, 0 },//applicant 4
			{ 0, 0, 0, 0, 0, 1 },//applicant 5
		}));
	}
	{
		/*
		      1     4
		     ^|^   /^\
		   /  |  X  |  \
		 /    vv   \|    v
		0---->2     5---->7
		 \    |\    ^    ^
		   \  |  \  |  /
			 vv    v|/
		      3---->6
		*/
		MaxNumEdgeDisjointPaths().FordFulkerson_ConnectedDirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 1, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 1, 0, 0, 1, 0 },//vertex 2
			{ 0, 0, 0, 0, 0, 0, 1, 0 },//vertex 3
			{ 0, 0, 1, 0, 0, 0, 0, 1 },//vertex 4
			{ 0, 1, 0, 0, 0, 0, 0, 1 },//vertex 5
			{ 0, 0, 0, 0, 0, 1, 0, 1 },//vertex 6
			{ 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 7
		}), 0, 7);
	}
	{
		AlphabetOrderFromGivenDictionary().SolveFor5Chars(std::vector<std::pair<int, int>>(
		{
			std::make_pair(2, 4), std::make_pair(2, 3), std::make_pair(3, 4), std::make_pair(1, 2),
			std::make_pair(1, 4), std::make_pair(1, 3), std::make_pair(0, 2), std::make_pair(0, 4), 
			std::make_pair(0, 3), std::make_pair(0, 1)
		}));

		AlphabetOrderFromGivenDictionary().alienOrderDFS(std::vector<std::string>({ "wrt", "wrf", "er", "ett", "rftt" }));
		AlphabetOrderFromGivenDictionary().alienOrderBFS(std::vector<std::string>({ "wrt", "wrf", "er", "ett", "rftt" }));
	}
	{
		UniqueSequenceReconstructable().IsUniquelyReconstructable(std::vector<int>({1,2,3}), std::vector<std::vector<int>>(
		{
			{1,2},
			{1,3},
			{2,3}
		}));
	}
	{
		/*
		1-->4-->6
		^ \ | / |
		|  vvv  v
		0-->3<--8
		|  ^^^  ^
		v / | \ |
		2-->5-->7
		*/
		KEdgePathsInDigraph().FindAll_DFS_DirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			//0, 1, 2, 3, 4, 5, 6, 7, 8
			{ 0, 1, 1, 1, 0, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 0, 1, 1, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 1, 0, 1, 0, 0, 0 },//vertex 2
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 1, 0, 0 },//vertex 4
			{ 0, 0, 0, 1, 0, 0, 0, 1, 0 },//vertex 5
			{ 0, 0, 0, 1, 0, 0, 0, 0, 1 },//vertex 6
			{ 0, 0, 0, 1, 0, 0, 0, 0, 1 },//vertex 7
			{ 0, 0, 0, 1, 0, 0, 0, 0, 0 },//vertex 8
		}), 0, 3, 4);
		KEdgePathsInDigraph().CountAll_DP3D_DirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			//0, 1, 2, 3, 4, 5, 6, 7, 8
			{ 0, 1, 1, 1, 0, 0, 0, 0, 0 },//vertex 0
			{ 0, 0, 0, 1, 1, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 1, 0, 1, 0, 0, 0 },//vertex 2
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 1, 0, 0 },//vertex 4
			{ 0, 0, 0, 1, 0, 0, 0, 1, 0 },//vertex 5
			{ 0, 0, 0, 1, 0, 0, 0, 0, 1 },//vertex 6
			{ 0, 0, 0, 1, 0, 0, 0, 0, 1 },//vertex 7
			{ 0, 0, 0, 1, 0, 0, 0, 0, 0 },//vertex 8
		}), 0, 3, 4);
		/*
		1-->4-->6
		| \ | / |
		v  vvv  v
		0-->3-->8
		| / | \ |
		vv  v  vv
		2-->5-->7
		*/
		KEdgePathsInDigraph().FindAll_DFS_DirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			//0, 1, 2, 3, 4, 5, 6, 7, 8
			{ 0, 0, 4, 7, 0, 0, 0, 0, 0 },//vertex 0
			{ 5, 0, 0, 8, 2, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 0, 0, 3, 0, 0, 0 },//vertex 2
			{ 0, 0, 9, 0, 0, 5, 0, 1, 7 },//vertex 3
			{ 0, 0, 0, 7, 0, 0, 4, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0, 0, 3, 0 },//vertex 5
			{ 0, 0, 0, 8, 0, 0, 0, 0, 5 },//vertex 6
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 7
			{ 0, 0, 0, 0, 0, 0, 0, 6, 0 },//vertex 8
		}), 1, 7, 3);
		KEdgePathsInDigraph().CountShortestPathWeight_DP3D_DirectedAdjacencyMatrix(std::vector<std::vector<int>>(
		{
			//0, 1, 2, 3, 4, 5, 6, 7, 8
			{ 0, 0, 4, 7, 0, 0, 0, 0, 0 },//vertex 0
			{ 5, 0, 0, 8, 2, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 0, 0, 3, 0, 0, 0 },//vertex 2
			{ 0, 0, 9, 0, 0, 5, 0, 1, 7 },//vertex 3
			{ 0, 0, 0, 7, 0, 0, 4, 0, 0 },//vertex 4
			{ 0, 0, 0, 0, 0, 0, 0, 3, 0 },//vertex 5
			{ 0, 0, 0, 8, 0, 0, 0, 0, 5 },//vertex 6
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0 },//vertex 7
			{ 0, 0, 0, 0, 0, 0, 0, 6, 0 },//vertex 8
		}), 1, 7, 3);
	}
	{
		TheCelebrityProblem().Use2Ptrs(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 1, 0, 1 },//vertex 0
			{ 1, 0, 0, 1, 1, 1 },//vertex 1
			{ 0, 1, 1, 1, 1, 0 },//vertex 2
			{ 0, 0, 0, 0, 0, 0 },//vertex 3
			{ 1, 0, 1, 1, 0, 1 },//vertex 4
			{ 0, 1, 0, 1, 1, 0 },//vertex 5
		}));
		TheCelebrityProblem().Use2PtrsII(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 1, 0, 1 },//vertex 0
			{ 1, 0, 0, 1, 1, 1 },//vertex 1
			{ 0, 1, 1, 1, 1, 0 },//vertex 2
			{ 0, 0, 0, 0, 0, 0 },//vertex 3
			{ 1, 0, 1, 1, 0, 1 },//vertex 4
			{ 0, 1, 0, 1, 1, 0 },//vertex 5
		}));
		TheCelebrityProblem().UsingStack(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 1, 0, 1 },//vertex 0
			{ 1, 0, 0, 1, 1, 1 },//vertex 1
			{ 0, 1, 1, 1, 1, 0 },//vertex 2
			{ 0, 0, 0, 0, 0, 0 },//vertex 3
			{ 1, 0, 1, 1, 0, 1 },//vertex 4
			{ 0, 1, 0, 1, 1, 0 },//vertex 5
		}));
		TheCelebrityProblem().BruteForce(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 1, 0, 1 },//vertex 0
			{ 1, 0, 0, 1, 1, 1 },//vertex 1
			{ 0, 1, 1, 1, 1, 0 },//vertex 2
			{ 0, 0, 0, 0, 0, 0 },//vertex 3
			{ 1, 0, 1, 1, 0, 1 },//vertex 4
			{ 0, 1, 0, 1, 1, 0 },//vertex 5
		}));
	}
	{
		//see elements of programming interview p.127
		DiameterOfTree().DFSRecur_DiAdjMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 7, 0, 0, 0, 14, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//0
			{ 0, 0, 4, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//1
			{ 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//2
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//3
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//4
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//5
			{ 0, 0, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0 },//6
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//7
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 0, 0, 0, 0, 0 },//8
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//9
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2, 0, 0, 0 },//10
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//11
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3 },//12
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//13
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//14
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//15
		}));
	}
	{
		/*
		            3----4----6
		           /
		0----1----2
		           \
				    5----7
		*/
		TwoExistConnectedGraph().Undirected_DFS_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 0, 1, 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 1, 0, 1, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 1, 0 },//vertex 4
			{ 0, 0, 1, 0, 0, 0, 0, 1 },//vertex 5
			{ 0, 0, 0, 0, 1, 0, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 1, 0, 0 },//vertex 7
		}));
		/*
		   -----    3----4----6
		 /       \ /        /
		0----1----2      /
		           \  /
		            5----7
		*/
		TwoExistConnectedGraph().Undirected_DFS_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 1, 0, 0, 0, 0, 0 },//vertex 0
			{ 1, 0, 1, 0, 0, 0, 0, 0 },//vertex 1
			{ 1, 1, 0, 1, 0, 1, 0, 0 },//vertex 2
			{ 0, 0, 1, 0, 1, 0, 0, 0 },//vertex 3
			{ 0, 0, 0, 1, 0, 0, 1, 0 },//vertex 4
			{ 0, 0, 1, 0, 0, 0, 1, 1 },//vertex 5
			{ 0, 0, 0, 0, 1, 1, 0, 0 },//vertex 6
			{ 0, 0, 0, 0, 0, 1, 0, 0 },//vertex 7
		}));
	}
	{
		/*
		      2-----3-----------
		          /   \         |
		        /       \       |
		4-----10----9-----8     1
		|     | \   |   /     /
		|     |   \ | /     /
		5-----6-----7-----0
		*/
		TwoForAllConnectedGraph().Undirected_DFS_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0 },//vertex 0
			{ 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 2
			{ 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1 },//vertex 3
			{ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 },//vertex 4
			{ 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1 },//vertex 6
			{ 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1 },//vertex 7
			{ 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0 },//vertex 8
			{ 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1 },//vertex 9
			{ 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0 },//vertex 10
		}));
		/*
		      2-----3-----------
		      |   /   \         |
		      | /       \       |
		4-----10----9-----8     1
		|     | \   |   /     /
		|     |   \ | /     /
		5-----6-----7-----0
		*/
		TwoForAllConnectedGraph().Undirected_DFS_AdjacencyMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0 },//vertex 0
			{ 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//vertex 1
			{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1 },//vertex 2
			{ 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1 },//vertex 3
			{ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 },//vertex 4
			{ 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0 },//vertex 5
			{ 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1 },//vertex 6
			{ 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1 },//vertex 7
			{ 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0 },//vertex 8
			{ 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1 },//vertex 9
			{ 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0 },//vertex 10
		}));
	}
	{
		/*
		           9
		       5------4
		     / |      |
		 11/  2|      |
		 /  9  |      |
		0------2     6|
		 \     | \    |
		  7\ 10| 11\  |
		     \ |     \|
		       1------3
		          15
		*/
		HighwayNetworkProposal().ShortestPath(std::vector<std::pair<std::pair<int, int>, double>>(
		{
			{ { 0, 1 }, 7.0 }, { { 0, 2 }, 9.0 }, { { 0, 5 }, 11.0 }, { { 1, 2 }, 10.0 }, { { 1, 3 }, 15.0 }, { { 2, 3 }, 11.0 }, { { 2, 5 }, 2.0 }, { { 3, 4 }, 6.0 }, { { 4, 5 }, 9.0 },
		}), std::vector<std::pair<std::pair<int, int>, double>>(
		{
			{ { 3, 5 }, 2.0 }, { { 0, 4 }, 21.0 }, { { 2, 4 }, 12.0 }, { { 1, 4 }, 11.0 }, { { 0, 3 }, 11.0 }, { { 1, 5 }, 11.0 },
		}), 0, 4, 6);
	}
	{
		IsArbitrageExist().BellmanFord_ExistNegativeWeightCycle(std::vector<std::vector<double>>(
		{
			{ 1.0, 0.8123, 0.6404, 78.125, 0.9784, 0.9924, 0.9465 },
			{ 1.2275, 1.0, 0.7860, 96.55, 1.2010, 1.2182, 1.1616 },
			{ 1.5617, 1.2724, 1.0, 122.83, 1.5280, 1.5498, 1.4778 },
			{ 0.0128, 0.0104, 0.0081, 1.0, 1.2442, 0.0126, 0.0120 },
			{ 1.0219, 0.8327, 0.6546, 80.39, 1.0, 1.0142, 0.9672 },
			{ 1.0076, 0.8206, 0.6453, 79.26, 0.9859, 1.0, 0.9535 },
			{ 1.0567, 0.8609, 0.6767, 83.12, 1.0339, 1.0487, 1.0 },
		}));
	}
	{
		/*
		   6     3
		1---->4---->6
	   6| \6  |3 5/ |5
	    |   \ | /   |
		v  5 vvv  8 v  24              5
		0---->3---->8<----13       9---->11
	   5|   / | \   |              |5   ^|
		| /8  |8 8\ |7             |  3/ |7
		vv  9 v  5 vv           4  v / 3 v
		2---->5---->7       14---->10--->12
		*/
		MinDelayTaskSchedulingDAG().Solve(std::vector<std::pair<int, int>>(
		{
			{ 1, 0 }, { 1, 4 }, { 1, 3 }, { 0, 3 }, { 0, 2 }, { 4, 3 }, { 4, 6 }, { 3, 8 }, { 3, 5 }, { 3, 7 }, { 3, 2 }, { 6, 8 }, { 6, 3 }, { 8, 7 }, { 5, 7 }, { 2, 5 }, { 13, 8 },
			{ 9, 10 }, { 9, 11 }, { 10, 11 }, { 10, 12 }, { 11, 12 }, { 14, 10 }
		}), std::vector<int>({ 5, 6, 9, 8, 3, 5, 5, 1, 7, 5, 3, 7, 1, 24, 4 }), 15);

	}
	{
		TeamPhoto::CheckPossible(TeamPhoto(std::vector<int>({ 1, 2, 3, 17, 18, 19, 20 })), TeamPhoto(std::vector<int>({ 11, 12, 13, 14, 15, 21, 22 })));
		TeamPhoto::CheckPossible(TeamPhoto(std::vector<int>({ 11, 12, 13, 14, 15, 16, 17 })), TeamPhoto(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7 })));
		TeamPhoto::CheckPossible(TeamPhoto(std::vector<int>({ 1, 2, 3, 14, 15, 16, 17 })), TeamPhoto(std::vector<int>({ 1, 2, 3, 4, 5, 6, 7 })));
		/*
		             5-------->2
				   / |  \   /  |
				 /	 |    X    |
			   / 	 |  /   \  |
			 v		 v v     v v
		    4------->0<--------6<---------
			|	     ^ ^     ^ ^         |
			|	   	 |  \   /  |         |
			|	 	 |    X    |         |
			| 		 |  /   \  |         |
		  	|		 1         3         |
			|____________________________|
		*/
		TeamPhoto2().LongestTeamSequenceDAG(std::vector<std::vector<int>>(
		{
			{ 41, 42, 43, 44, 45, 46, 47 },//0
			{ 1, 2, 3, 17, 18, 19, 20 },//1
			{ 11, 12, 13, 14, 15, 16, 17 },//2
			{ 1, 2, 3, 14, 15, 16, 17 },//3
			{ 11, 12, 13, 14, 15, 21, 22 },//4
			{ 1, 2, 3, 4, 5, 6, 7 },//5
			{ 31, 32, 33, 34, 35, 36, 37 }//6
		}));
	}
	{
		CourseSchedule().CanFinish(2, std::vector<std::pair<int, int>>({ { 1, 0 } }));
		CourseSchedule().CanFinish(2, std::vector<std::pair<int, int>>({ { 1, 0 }, { 0, 1 } }));
		CourseSchedule().FindOrder(2, std::vector<std::pair<int, int>>({ { 1, 0 } }));
		CourseSchedule().FindOrder(4, std::vector<std::pair<int, int>>({ { 1, 0 }, { 2, 0 }, { 3, 1 }, { 3, 2 } }));
	}
	{
		TowerOfHanoi tower0(0);
		TowerOfHanoi tower1(1);
		TowerOfHanoi tower2(2);
		int n = 5;
		for (int i = n - 1; i >= 0; --i)
			tower0.Add(i);
		tower0.MoveDisks(n, tower2, tower1);
		tower0.Print();
		tower1.Print();
		tower2.Print();

		TowerOfHanoi2().Transfer(5);
	}
	{
		std::vector<std::vector<int>> startConfig(
		{
			{ 4, 3, 2, 1, 0 },
			{ },
			{ },
		});
		std::vector<std::vector<int>> endConfig(
		{
			{ },
			{ 4, 3, 2, 1, 0 },
			{ },
		});
		GeneralTowerOfHanoi().BFS(startConfig, endConfig, 5, 3);
		GeneralTowerOfHanoi().DFS(startConfig, endConfig, 5, 3);

		std::vector<std::vector<int>> startConfig2(
		{
			{ 4 },
			{ 1, 0 },
			{ 3 },
			{ 2 },
		});
		std::vector<std::vector<int>> endConfig2(
		{
			{ },
			{ 4 },
			{ 3, 0 },
			{ 2, 1 },
		});
		GeneralTowerOfHanoi().BFS(startConfig2, endConfig2, 5, 4);
		GeneralTowerOfHanoi().DFS(startConfig2, endConfig2, 5, 4);

		std::vector<std::vector<int>> startConfig3(
		{
			{ },
			{ 3, 0 },
			{ },
			{ 4, 2, 1 },
		});
		std::vector<std::vector<int>> endConfig3(
		{
			{ },
			{ 4, 3, 2, 1, 0 },
			{ },
			{ },
		});
		GeneralTowerOfHanoi().BFS(startConfig3, endConfig3, 5, 4);
		//GeneralTowerOfHanoi().DFS(startConfig3, endConfig3, 5, 4);//too long runtime

		//std::vector<std::vector<int>> startConfig4(
		//{
		//	{ 3, 1 },
		//	{ 0 },
		//	{ },
		//	{ 2 },
		//});
		//std::vector<std::vector<int>> endConfig4(
		//{
		//	{ 1 },
		//	{ 2, 0 },
		//	{ 3 },
		//	{ },
		//});
		//GeneralTowerOfHanoi().BFS(startConfig4, endConfig4, 4, 4);
		//GeneralTowerOfHanoi().DFS(startConfig4, endConfig4, 4, 4);//too long runtime

		//std::vector<std::vector<int>> startConfig5(
		//{
		//	{ },
		//	{ 2, 0 },
		//	{ 1 },
		//	{ 3 },
		//});
		//std::vector<std::vector<int>> endConfig5(
		//{
		//	{ 3, 1 },
		//	{ 0 },
		//	{ },
		//	{ 2 },
		//});
		//GeneralTowerOfHanoi().BFS(startConfig5, endConfig5, 4, 4);
		//GeneralTowerOfHanoi().DFS(startConfig5, endConfig5, 4, 4);//too long runtime
	}
	{
		TreeFromParentChildPairs().TraverseDFS(std::list<std::pair<std::string, std::string>>(
		{
			{ "animal", "mammal" },
			{ "animal", "bird" },
			{ "lifeform", "animal" },
			{ "cat", "lion" },
			{ "mammal", "cat" },
			{ "animal", "fish" },
			{ "lifeform", "plant" },
			{ "lifeform", "fungi" },
			{ "cat", "tiger" },
			{ "cat", "panther" },
			{ "fish", "lionfish" },
			{ "bird", "eagle" },
			{ "mammal", "human" },
			{ "mammal", "whale" },
			/**/
			{ "Mercedes", "4Matic" },
			{ "4Matic", "CLA45Amg" },
			{ "Mercedes", "C63Amg" },
			{ "Ford", "Mustang" },
			{ "BMW", "M4" },
			{ "BMW", "xDrive" },
			{ "xDrive", "435i" },
			{ "Audi", "Quattro" },
			{ "Quattro", "RS5" },
			{ "Quattro", "TT" },
			{ "Subaru", "WRX" },
			{ "WRX", "sti" },
			{ "Japan", "Subaru" },
			{ "America", "Ford" },
			{ "German", "Audi" },
			{ "German", "Mercedes" },
			{ "German", "BMW" },
			{ "Brand", "German" },
			{ "Brand", "America" },
			{ "Brand", "Japan" },
		}));
		TreeFromParentChildPairs().TraverseBFS(std::list<std::pair<std::string, std::string>>(
		{
			{ "animal", "mammal" },
			{ "animal", "bird" },
			{ "lifeform", "animal" },
			{ "cat", "lion" },
			{ "mammal", "cat" },
			{ "animal", "fish" },
			{ "lifeform", "plant" },
			{ "lifeform", "fungi" },
			{ "cat", "tiger" },
			{ "cat", "panther" },
			{ "fish", "lionfish" },
			{ "bird", "eagle" },
			{ "mammal", "human" },
			{ "mammal", "whale" },
			/**/
			{ "Mercedes", "4Matic" },
			{ "4Matic", "CLA45Amg" },
			{ "Mercedes", "C63Amg" },
			{ "Ford", "Mustang" },
			{ "BMW", "M4" },
			{ "BMW", "xDrive" },
			{ "xDrive", "435i" },
			{ "Audi", "Quattro" },
			{ "Quattro", "RS5" },
			{ "Quattro", "TT" },
			{ "Subaru", "WRX" },
			{ "WRX", "sti" },
			{ "Japan", "Subaru" },
			{ "America", "Ford" },
			{ "German", "Audi" },
			{ "German", "Mercedes" },
			{ "German", "BMW" },
			{ "Brand", "German" },
			{ "Brand", "America" },
			{ "Brand", "Japan" },
		}));
		TreeFromParentChildPairs().TraverseDFS(std::list<std::pair<std::string, std::string>>(
		{
			{ "Mercedes", "4Matic" },
			{ "4Matic", "CLA45Amg" },
			{ "Mercedes", "C63Amg" },
			{ "Ford", "Mustang" },
			{ "BMW", "M4" },
			{ "BMW", "xDrive" },
			{ "xDrive", "435i" },
			{ "Audi", "Quattro" },
			{ "Quattro", "RS5" },
			{ "Quattro", "TT" },
			{ "Subaru", "WRX" },
			{ "WRX", "sti" },
			{ "Japan", "Subaru" },
			{ "America", "Ford" },
			{ "German", "Audi" },
			{ "German", "Mercedes" },
			{ "German", "BMW" },
			{ "Brand", "German" },
			{ "Brand", "America" },
			{ "Brand", "Japan" },
			{ "TT", "German" },//back edge
		}));

		ReconstructItinerary().DFS_Recur(std::vector<std::pair<std::string, std::string>>({ { "MUC", "LHR" },{ "JFK", "MUC" },{ "SFO", "SJC" },{ "LHR", "SFO" } }));
		ReconstructItinerary().DFS_Stack(std::vector<std::pair<std::string, std::string>>({ { "MUC", "LHR" },{ "JFK", "MUC" },{ "SFO", "SJC" },{ "LHR", "SFO" } }));

		ReconstructItinerary().DFS_Recur(std::vector<std::pair<std::string, std::string>>({ { "JFK", "SFO" },{ "JFK", "ATL" },{ "SFO", "ATL" },{ "ATL", "JFK" },{ "ATL", "SFO" } }));
		ReconstructItinerary().DFS_Stack(std::vector<std::pair<std::string, std::string>>({ { "JFK", "SFO" },{ "JFK", "ATL" },{ "SFO", "ATL" },{ "ATL", "JFK" },{ "ATL", "SFO" } }));

		ReconstructItinerary().DFS_Recur(std::vector<std::pair<std::string, std::string>>({ { "JFK", "SFO" },{ "JFK", "ATL" },{ "SFO", "ATL" },{ "SFO", "JFK" },{ "ATL", "SFO" } }));
		ReconstructItinerary().DFS_Stack(std::vector<std::pair<std::string, std::string>>({ { "JFK", "SFO" },{ "JFK", "ATL" },{ "SFO", "ATL" },{ "SFO", "JFK" },{ "ATL", "SFO" } }));

		ReconstructItinerary().DFS_Recur(std::vector<std::pair<std::string, std::string>>({ { "JFK", "SFO" },{ "JFK", "ZTL" },{ "SFO", "ZTL" },{ "ZTL", "JFK" },{ "ZTL", "SFO" } }));
		ReconstructItinerary().DFS_Stack(std::vector<std::pair<std::string, std::string>>({ { "JFK", "SFO" },{ "JFK", "ZTL" },{ "SFO", "ZTL" },{ "ZTL", "JFK" },{ "ZTL", "SFO" } }));
		
		ReconstructItinerary().DFS_Recur(std::vector<std::pair<std::string, std::string>>({ { "JFK", "SFO" },{ "JFK", "ZTL" },{ "SFO", "ZTL" },{ "SFO", "JFK" },{ "ZTL", "SFO" } }));
		ReconstructItinerary().DFS_Stack(std::vector<std::pair<std::string, std::string>>({ { "JFK", "SFO" },{ "JFK", "ZTL" },{ "SFO", "ZTL" },{ "SFO", "JFK" },{ "ZTL", "SFO" } }));

		ReconstructItinerary().DFS_Recur(std::vector<std::pair<std::string, std::string>>({ { "JFK", "KUL" },{ "JFK", "NRT" },{ "NRT", "JFK" } }));
		ReconstructItinerary().DFS_Stack(std::vector<std::pair<std::string, std::string>>({ { "JFK", "KUL" },{ "JFK", "NRT" },{ "NRT", "JFK" } }));

		ReconstructItinerary().DFS_Recur(std::vector<std::pair<std::string, std::string>>({ { "JFK", "KUL" },{ "JFK", "NRT" },{ "KUL", "JFK" } }));
		ReconstructItinerary().DFS_Stack(std::vector<std::pair<std::string, std::string>>({ { "JFK", "KUL" },{ "JFK", "NRT" },{ "KUL", "JFK" } }));

		/*
     _______0________
    /       |        \
  _1_      _5_      __9__
 / | \    / | \    /  |  \
2  3  4  6  7  8  10  11  12
		*/
		GenericDFSWStack::TreeNode * tr = new GenericDFSWStack::TreeNode(0);
		tr->children.push_back(new GenericDFSWStack::TreeNode(1));
		tr->children.push_back(new GenericDFSWStack::TreeNode(5));
		tr->children.push_back(new GenericDFSWStack::TreeNode(9));
		tr->children[0]->children.push_back(new GenericDFSWStack::TreeNode(2));
		tr->children[0]->children.push_back(new GenericDFSWStack::TreeNode(3));
		tr->children[0]->children.push_back(new GenericDFSWStack::TreeNode(4));
		tr->children[1]->children.push_back(new GenericDFSWStack::TreeNode(6));
		tr->children[1]->children.push_back(new GenericDFSWStack::TreeNode(7));
		tr->children[1]->children.push_back(new GenericDFSWStack::TreeNode(8));
		tr->children[2]->children.push_back(new GenericDFSWStack::TreeNode(10));
		tr->children[2]->children.push_back(new GenericDFSWStack::TreeNode(11));
		tr->children[2]->children.push_back(new GenericDFSWStack::TreeNode(12));
		GenericDFSWStack().PreorderStack(tr);
		GenericDFSWStack().PreorderStackHashMap(tr);
		GenericDFSWStack().PreorderRecur(tr);
		GenericDFSWStack().PostorderStack(tr);
		GenericDFSWStack().PostorderStackHashMap(tr);
		GenericDFSWStack().PostorderRecur(tr);
		GenericDFSWStack::DeleteTree(tr);
		/*
					    _________________________0_____________________________
				       /                |                  |                   \
				  ____1____         ____5____          ____9_____           ____13____
				 /    |    \       /    |    \        /    |     \         /    |     \
				2     3    _4_    6   __7__   8   __10_   _11    _12_    14    _15    _16____
			   / \    |   / | \   |  /  |  \  |  /  |  \ /   \  /  | \  /  \  /   \  /  |  | \
			  17 18  19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43
		*/
		tr = new GenericDFSWStack::TreeNode(0);
		tr->children.push_back(new GenericDFSWStack::TreeNode(1));
		tr->children.push_back(new GenericDFSWStack::TreeNode(5));
		tr->children.push_back(new GenericDFSWStack::TreeNode(9));
		tr->children.push_back(new GenericDFSWStack::TreeNode(13));
		tr->children[0]->children.push_back(new GenericDFSWStack::TreeNode(2));
		tr->children[0]->children.push_back(new GenericDFSWStack::TreeNode(3));
		tr->children[0]->children.push_back(new GenericDFSWStack::TreeNode(4));
		tr->children[1]->children.push_back(new GenericDFSWStack::TreeNode(6));
		tr->children[1]->children.push_back(new GenericDFSWStack::TreeNode(7));
		tr->children[1]->children.push_back(new GenericDFSWStack::TreeNode(8));
		tr->children[2]->children.push_back(new GenericDFSWStack::TreeNode(10));
		tr->children[2]->children.push_back(new GenericDFSWStack::TreeNode(11));
		tr->children[2]->children.push_back(new GenericDFSWStack::TreeNode(12));
		tr->children[3]->children.push_back(new GenericDFSWStack::TreeNode(14));
		tr->children[3]->children.push_back(new GenericDFSWStack::TreeNode(15));
		tr->children[3]->children.push_back(new GenericDFSWStack::TreeNode(16));
		tr->children[0]->children[0]->children.push_back(new GenericDFSWStack::TreeNode(17));
		tr->children[0]->children[0]->children.push_back(new GenericDFSWStack::TreeNode(18));
		tr->children[0]->children[1]->children.push_back(new GenericDFSWStack::TreeNode(19));
		tr->children[0]->children[2]->children.push_back(new GenericDFSWStack::TreeNode(20));
		tr->children[0]->children[2]->children.push_back(new GenericDFSWStack::TreeNode(21));
		tr->children[0]->children[2]->children.push_back(new GenericDFSWStack::TreeNode(22));
		tr->children[1]->children[0]->children.push_back(new GenericDFSWStack::TreeNode(23));
		tr->children[1]->children[1]->children.push_back(new GenericDFSWStack::TreeNode(24));
		tr->children[1]->children[1]->children.push_back(new GenericDFSWStack::TreeNode(25));
		tr->children[1]->children[1]->children.push_back(new GenericDFSWStack::TreeNode(26));
		tr->children[1]->children[2]->children.push_back(new GenericDFSWStack::TreeNode(27));
		tr->children[2]->children[0]->children.push_back(new GenericDFSWStack::TreeNode(28));
		tr->children[2]->children[0]->children.push_back(new GenericDFSWStack::TreeNode(29));
		tr->children[2]->children[0]->children.push_back(new GenericDFSWStack::TreeNode(30));
		tr->children[2]->children[1]->children.push_back(new GenericDFSWStack::TreeNode(31));
		tr->children[2]->children[1]->children.push_back(new GenericDFSWStack::TreeNode(32));
		tr->children[2]->children[2]->children.push_back(new GenericDFSWStack::TreeNode(33));
		tr->children[2]->children[2]->children.push_back(new GenericDFSWStack::TreeNode(34));
		tr->children[2]->children[2]->children.push_back(new GenericDFSWStack::TreeNode(35));
		tr->children[3]->children[0]->children.push_back(new GenericDFSWStack::TreeNode(36));
		tr->children[3]->children[0]->children.push_back(new GenericDFSWStack::TreeNode(37));
		tr->children[3]->children[1]->children.push_back(new GenericDFSWStack::TreeNode(38));
		tr->children[3]->children[1]->children.push_back(new GenericDFSWStack::TreeNode(39));
		tr->children[3]->children[2]->children.push_back(new GenericDFSWStack::TreeNode(40));
		tr->children[3]->children[2]->children.push_back(new GenericDFSWStack::TreeNode(41));
		tr->children[3]->children[2]->children.push_back(new GenericDFSWStack::TreeNode(42));
		tr->children[3]->children[2]->children.push_back(new GenericDFSWStack::TreeNode(43));
		GenericDFSWStack().PreorderStack(tr);
        GenericDFSWStack().PreorderStackHashMap(tr);
        GenericDFSWStack().PreorderRecur(tr);
		GenericDFSWStack().PostorderStack(tr);
        GenericDFSWStack().PostorderStackHashMap(tr);
        GenericDFSWStack().PostorderRecur(tr);
		GenericDFSWStack::DeleteTree(tr);
	}
	{
        WordLadder().Test("hit", "cog", std::vector<std::string>({"hot","dot","dog","lot","log","cog"}));
        WordLadder().Test("red", "tax", std::vector<std::string>({"ted","tex","red","tax","tad","den","rex","pee"}));

		MinGeneticMutation().Test(std::string("AAAAACCC"), std::string("AACCCCCC"), std::vector<std::string>({ "AAAACCCC", "AAACCCCC", "AACCCCCC" }));
	}
	{
		/*
		     1000
		    0---->1
		2000|   /
		    | /5000
		    vv
		    2
		
		    0    1
		3000|   /
		    | /4000
		    vv
		    2
		*/
		MinCashFlow().Greedy_DirectedAdjMatrix(std::vector<std::vector<int>>(
		{
			{ 0, 1000, 2000 },
			{ 0, 0, 5000 },
			{ 0, 0, 0 },
		}));

		MinCashFlow().MinTransfers(std::vector<std::vector<int>>(
		{
			{ 0,1,10 },
			{ 1,0,1 },
			{ 1,2,5 },
			{ 2,0,5 }
		}));
	}
	{
		/*
		        0
				|
				1
			   / \
			  2   3
			return [1]
		*/
		MinHeightTreesInGraph().BFS(4, std::vector<std::pair<int, int>>({ { 0, 1 },{ 1, 2 },{ 1, 3 } }));
		/*
		     0  1  2
			  \ | /
				3
				|
				4
				|
				5
			return [3, 4]
		*/
		MinHeightTreesInGraph().BFS(6, std::vector<std::pair<int, int>>({ { 0, 3 },{ 1, 3 },{ 2, 3 },{ 4,3 },{ 5,4 } }));
	}
	{
        RemoveInvalidParentheses().BFS_Optimal(std::string("()())()"));
        RemoveInvalidParentheses().BFS_NoHashMap(std::string("()())()"));
		RemoveInvalidParentheses().BFS(std::string("()())()"));
		RemoveInvalidParentheses().DFS(std::string("()())()"));
        RemoveInvalidParentheses().BFS_Optimal(std::string("()()))(()))(()(()))(()"));
        RemoveInvalidParentheses().BFS_NoHashMap(std::string("()()))(()))(()(()))(()"));
        RemoveInvalidParentheses().BFS(std::string("()()))(()))(()(()))(()"));
        RemoveInvalidParentheses().DFS(std::string("()()))(()))(()(()))(()"));
	}
	{
		FreedomTrail().DP2D(std::string("godding"), std::string("ond"));
		FreedomTrail().DFS_DP(std::string("godding"), std::string("ond"));
		FreedomTrail().BFS_DP(std::string("godding"), std::string("ond"));
        FreedomTrail().BFS_DP_Simple(std::string("godding"), std::string("ond"));
		FreedomTrail().DP2D(std::string("czjdn"), std::string("zzznnnjjjdddccc"));
		FreedomTrail().DFS_DP(std::string("czjdn"), std::string("zzznnnjjjdddccc"));
		FreedomTrail().BFS_DP(std::string("czjdn"), std::string("zzznnnjjjdddccc"));
        FreedomTrail().BFS_DP_Simple(std::string("czjdn"), std::string("zzznnnjjjdddccc"));
		
	}
	{
		FriendCircle().DFS(std::vector<std::vector<int>>(
		{
			{ 1,1,0 },
			{ 1,1,0 },
			{ 0,0,1 }
		}));
		FriendCircle().UnionFind(std::vector<std::vector<int>>(
		{
			{ 1,1,0 },
			{ 1,1,0 },
			{ 0,0,1 }
		}));
	}
    {
        MergeAccounts().UnionFind(std::vector<std::vector<std::string>>(
        {
            {"David","David0@m.co","David1@m.co"},
            {"David","David3@m.co","David4@m.co"},
            {"David","David4@m.co","David5@m.co"},
            {"David","David2@m.co","David3@m.co"},
            {"David","David1@m.co","David2@m.co"}
        }));

        MergeAccounts().MergeSets_UnionFind(std::vector<std::vector<int>>(
                {
                        {3,4},
                        {2,3},
                        {2,1},
                        {7,8},
                        {6,5,7},
                        {9},
                        {9},
                        {11,10,5},
                }));
    }
    {
        /*
     _______0________
    /       |        \
   1       _2_        3
  /       / | \        \
12       4  5  6       13
        /   |   \       \
       7   11    8      14
      /           \
     9            10
        */
        LCAofDeepestLeavesGraphTree::TreeNode * r = new LCAofDeepestLeavesGraphTree::TreeNode(0);
        r->children.push_back(new LCAofDeepestLeavesGraphTree::TreeNode(1));
        r->children.push_back(new LCAofDeepestLeavesGraphTree::TreeNode(2));
        r->children.push_back(new LCAofDeepestLeavesGraphTree::TreeNode(3));
        r->children[0]->children.push_back(new LCAofDeepestLeavesGraphTree::TreeNode(12));
        r->children[1]->children.push_back(new LCAofDeepestLeavesGraphTree::TreeNode(4));
        r->children[1]->children.push_back(new LCAofDeepestLeavesGraphTree::TreeNode(5));
        r->children[1]->children.push_back(new LCAofDeepestLeavesGraphTree::TreeNode(6));
        r->children[2]->children.push_back(new LCAofDeepestLeavesGraphTree::TreeNode(13));
        r->children[1]->children[0]->children.push_back(new LCAofDeepestLeavesGraphTree::TreeNode(7));
        r->children[1]->children[1]->children.push_back(new LCAofDeepestLeavesGraphTree::TreeNode(11));
        r->children[1]->children[2]->children.push_back(new LCAofDeepestLeavesGraphTree::TreeNode(8));
        r->children[2]->children[0]->children.push_back(new LCAofDeepestLeavesGraphTree::TreeNode(14));
        r->children[1]->children[0]->children[0]->children.push_back(new LCAofDeepestLeavesGraphTree::TreeNode(9));
        r->children[1]->children[2]->children[0]->children.push_back(new LCAofDeepestLeavesGraphTree::TreeNode(10));
        LCAofDeepestLeavesGraphTree().BottomUp_BFS(r);
        LCAofDeepestLeavesGraphTree::DeleteTree(r);
    }
    {
        FindLoudestRicherPerson().DFS(std::vector<std::vector<int>>({{1,0},{2,1},{3,1},{3,7},{4,3},{5,3},{6,3}}), std::vector<int>({3,2,5,4,6,1,7,0}));
    }
    {
        /*
       3----->0       6
        ^   /  \
         \ v   v
          1--->2     4
               \   /
               v v
                5
         visit:    0,1,2,5,3,4,6
         complete: 5,3,4,6
         */
        EventualSafeVerticesDirectedGraph().FindCompletionVertices(std::vector<std::vector<int>>(
                {
                        {1,2},
                        {2,3},
                        {5},
                        {0},
                        {5},
                        {},
                        {}
                }));
    }
    {
        BusRoutes().BFS_NumOfBuses(std::vector<std::vector<int>>(
                {
                        {1,2,7},
                        {3,6,7},
                }), 1, 6);
    }
    {
        MinStepsToOpen4DigitLock().Test(std::vector<std::string>({"8887","8889","8878","8898","8788","8988","7888","9888"}), std::string("8888"));
    }
    {
        MinStepsSwap0In2DPuzzleBoard().Test(std::vector<std::vector<int>>(
                {
                        {3,2,4},
                        {1,5,0}
                }));
    }
    {
        CheapestFlightsWithinKStops().Test(3, std::vector<std::vector<int>>({{0,1,100},{1,2,100},{0,2,500}}), 0, 2, 1);
        CheapestFlightsWithinKStops().Test(3, std::vector<std::vector<int>>({{0,1,100},{1,2,100},{0,2,500}}), 0, 2, 0);
    }
    {
        OnePathVisitAllRooms().DFS(std::vector<std::vector<int>>({{1},{2},{3},{}}));
        OnePathVisitAllRooms().DFS(std::vector<std::vector<int>>({{1},{3,0,1},{2},{0}}));
    }
    {
        GraphToTreeRedundantEdge().Undirected_UnionFind(std::vector<std::vector<int>>({{1,2}, {2,3}, {3,4}, {1,4}, {1,5}}));
        GraphToTreeRedundantEdge().Directed_UnionFind(std::vector<std::vector<int>>({{1,2}, {2,3}, {3,4}, {4,1}, {1,5}}));
        GraphToTreeRedundantEdge().Directed_UnionFind(std::vector<std::vector<int>>({{2,1}, {4,2}, {1,4}, {3,1}}));
    }
    {
        CrackSafe().deBruijnSeq(2, 2);
        CrackSafe().deBruijnSeq(3, 2);
        CrackSafe().deBruijnSeq(3, 3);
    }
    {
        SumOfDistBtwCurAndAllOtherNodesInTree().TwoPassDFS(6, std::vector<std::vector<int>>({{0,1},{0,2},{2,3},{2,4},{2,5}}));
    }
    {
        ShortestPathVisitAllNodesInGraph().Test(std::vector<std::vector<int>>({{1,2,3},{0},{0},{0}}));
        ShortestPathVisitAllNodesInGraph().Test(std::vector<std::vector<int>>({{1},{0,2,4},{1,3,4},{2},{1,2}}));
    }
    {
        Remove1MalNodeMinimizeInfectedNodes().DFS(std::vector<std::vector<int>>(
                {
                        {1,1,0},
                        {1,1,0},
                        {0,0,1}
                }),std::vector<int>({0,1}));
        Remove1MalNodeMinimizeInfectedNodes().UnionFind(std::vector<std::vector<int>>(
                {
                        {1,1,0},
                        {1,1,0},
                        {0,0,1}
                }),std::vector<int>({0,1}));
        Remove1MalNodeMinimizeInfectedNodes_RemoveEdges().DFS(std::vector<std::vector<int>>(
                {
                        {1,1,0},
                        {1,1,0},
                        {0,0,1}
                }),std::vector<int>({0,1}));
        Remove1MalNodeMinimizeInfectedNodes_RemoveEdges().UnionFind(std::vector<std::vector<int>>(
                {
                        {1,1,0},
                        {1,1,0},
                        {0,0,1}
                }),std::vector<int>({0,1}));
    }
    {
        ConnectedComponentsByStrSwap2Chars().DFS(std::vector<std::string>({"tars","rats","arts","star"}));
        ConnectedComponentsByStrSwap2Chars().BFS(std::vector<std::string>({"tars","rats","arts","star"}));
        ConnectedComponentsByStrSwap2Chars().UnionFind(std::vector<std::string>({"tars","rats","arts","star"}));
    }
    {
        ConnectedComponentsByIntCommonFactor().DFS(std::vector<int>({4,6,15,35}));
        ConnectedComponentsByIntCommonFactor().BFS(std::vector<int>({4,6,15,35}));
        ConnectedComponentsByIntCommonFactor().UnionFind(std::vector<int>({4,6,15,35}));
    }
    {
        MinCostConnectAllNodesInGraph().UnionFind(3, std::vector<std::vector<int>>({{1,2,5},{1,3,6},{2,3,1}}));
        MinCostConnectAllNodesInGraph2().UnionFind(6, std::vector<std::vector<int>>({{1,4},{4,5},{2,3}}), std::vector<std::vector<int>>({{1,2,5},{1,3,10},{1,6,2},{5,6,5}}));
        MinCostRepairAllEdgesInGraph().UnionFind(5, std::vector<std::vector<int>>({{1,2},{2,3},{3,4},{4,5},{1,5}}), std::vector<std::vector<int>>({{1,2,12},{3,4,30},{1,5,8}}));
        MinCostRepairAllEdgesInGraph().UnionFind(6, std::vector<std::vector<int>>({{1,2},{2,3},{4,5},{3,5},{1,6},{2,4}}), std::vector<std::vector<int>>({{1,6,410},{2,4,800}}));
        MinCostRepairAllEdgesInGraph().UnionFind(6, std::vector<std::vector<int>>({{1,2},{2,3},{4,5},{5,6},{1,5},{2,4},{3,4}}), std::vector<std::vector<int>>({{1,5,110},{2,4,84},{3,4,79}}));
    }
    {
        KSwapStrings().BFS("aabc", "abca");
    }
    {
        ShortestSuperStringOfAllStrings().DP(std::vector<std::string>({"catg","ctaagt","gcta","ttca","atgcatc"}));
    }
    {
        ShortestPathWAltColorsInGraph().BFS(3, std::vector<std::vector<int>>({{0,1},{0,2}}), std::vector<std::vector<int>>({{1,0}}));
    }
    {
        MinLexicographicStrBySwapPairs().UnionFind(std::string("dcab"), std::vector<std::vector<int>>({{0,3},{1,2},{0,2}}));
    }

#endif
#ifdef _RMQLCA_
	RdCout ? redirect_cout::to_file("Out_RMQLCA.txt") : redirect_cout::to_cout();
	PrintH("RMQLCA");
	std::ostringstream rmqlcaOss;
	{
		std::vector<int> A({ 2, 5, 1, 4, 9, 3 });
		std::vector<int> segmentTree = RangeMinQuerySegmentTree().Construct(A);
		RangeMinQuerySegmentTree().QueryRange(segmentTree, 1, 5, A.size());
		RangeMinQuerySegmentTree().UpdateValue(A, 2, -1, segmentTree);
		RangeMinQuerySegmentTree().QueryRange(segmentTree, 1, 5, A.size());
	}
	{
		std::vector<std::vector<int>> board(
		{
			{ 23, 18, 7, 45, 42, 26 },
			{ 37, 22, 32, 24, 25, 38 },
			{ 3, 32, 12, 7, 31, 27 },
			{ 2, 24, 51, 23, 21, 5 },
			{ 78, 14, 23, 12, 13, 9 },
			{ 45, 19, 21, 6, 18, 4 },
			{ 24, 16, 36, 1, 33, 17 },
			{ 15, 21, 8, 34, 55, 28 },
		});
		std::vector<std::vector<int>> segmentTree2D = RMQ2DSegmentTree2D().Construct(board);
		RMQ2DSegmentTree2D().QueryRange(segmentTree2D, 0, 7, 8, 0, 5, 6);//(0,0),(7,5)
		RMQ2DSegmentTree2D().QueryRange(segmentTree2D, 4, 7, 8, 0, 2, 6);//(4,0),(7,2)
		RMQ2DSegmentTree2D().QueryRange(segmentTree2D, 0, 5, 8, 1, 5, 6);//(0,1),(5,5)
		RMQ2DSegmentTree2D().UpdateValue(board, 6, 3, -9, segmentTree2D);
		RMQ2DSegmentTree2D().UpdateValue(board, 7, 2, -5, segmentTree2D);
		RMQ2DSegmentTree2D().UpdateValue(board, 5, 4, -2, segmentTree2D);
		RMQ2DSegmentTree2D().QueryRange(segmentTree2D, 0, 7, 8, 0, 5, 6);//(0,0),(7,5)
		RMQ2DSegmentTree2D().QueryRange(segmentTree2D, 4, 7, 8, 0, 2, 6);//(4,0),(7,2)
		RMQ2DSegmentTree2D().QueryRange(segmentTree2D, 0, 5, 8, 1, 5, 6);//(0,1),(5,5)
	}
	{
		std::vector<int> A({ 1, 3, 5, 7, 9, 11 });
		std::vector<int> segmentTree = RangeSumQuerySegmentTree().Construct(A);
		RangeSumQuerySegmentTree().QueryRange(segmentTree, 1, 3, A.size());
		RangeSumQuerySegmentTree().UpdateValue(A, 1, 10, segmentTree);
		RangeSumQuerySegmentTree().QueryRange(segmentTree, 1, 3, A.size());

		RangeSumQuerySegmentTree2D rsqst2(std::vector<std::vector<int>>(
		{
			{ 3,0,1,4,2 },
			{ 5,6,3,2,1 },
			{ 1,2,0,1,5 },
			{ 4,1,0,1,7 },
			{ 1,0,3,0,5 }
		}));
		rsqst2.QueryRange(2, 4, 1, 3);
		rsqst2.UpdateValue(3, 2, 2);
		rsqst2.QueryRange(2, 4, 1, 3);
		rsqst2.UpdateValue(2, 3, 7);
		rsqst2.QueryRange(2, 4, 1, 3);
	}
	{
		RangeSumQueryWPrefixSums2D rmqwp2(std::vector<std::vector<int>>(
		{
			{ 3,0,1,4,2 },
			{ 5,6,3,2,1 },
			{ 1,2,0,1,5 },
			{ 4,1,0,1,7 },
			{ 1,0,3,0,5 }
		}));
		rmqwp2.sumRegion(2, 1, 4, 3);
		rmqwp2.sumRegion(1, 1, 2, 2);
		rmqwp2.sumRegion(1, 2, 2, 4);

		RangeSumQueryWPrefixSums2DMutable rmqwp2m(std::vector<std::vector<int>>(
		{
			{ 3,0,1,4,2 },
			{ 5,6,3,2,1 },
			{ 1,2,0,1,5 },
			{ 4,1,0,1,7 },
			{ 1,0,3,0,5 }
		}));
		rmqwp2m.sumRegion(2, 1, 4, 3);
		rmqwp2m.update(3, 2, 2);
		rmqwp2m.sumRegion(2, 1, 4, 3);
		rmqwp2m.update(2, 3, 7);
		rmqwp2m.sumRegion(2, 1, 4, 3);

		RangeSumQueryWPrefixSums1DMutable rmqwp1m(std::vector<int>({ 1,3,5 }));
		rmqwp1m.sumRange(0, 2);
		rmqwp1m.update(1, 2);
		rmqwp1m.sumRange(0, 2);
	}
	{
		RangeSumQueryBinaryIndexedTree rmqbit(std::vector<int>({ 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 }));
		rmqbit.sumRegion(0, 11);
		rmqbit.sumRegion(0, 5);
		rmqbit.sumRegion(0, 7);
		rmqbit.update(12, 15);//change 13->15
		rmqbit.sumRegion(0, 13);

		RangeSumQueryBinaryIndexedTree2D rmqbit2d(std::vector<std::vector<int>>(
		{
			{ 3,0,1,4,2 },
			{ 5,6,3,2,1 },
			{ 1,2,0,1,5 },
			{ 4,1,0,1,7 },
			{ 1,0,3,0,5 }
		}));
		rmqbit2d.sumRegion(2, 1, 4, 3);
		rmqbit2d.update(3, 2, 2);
		rmqbit2d.sumRegion(2, 1, 4, 3);
		rmqbit2d.update(2, 3, 7);
		rmqbit2d.sumRegion(2, 1, 4, 3);
	}
	{
		RangeSumCount().Naive(std::vector<int>({ -2,5,-1 }), -2, 2);
		RangeSumCount().SortedPrefixSums(std::vector<int>({ -2,5,-1 }), -2, 2);
		RangeSumCount().SortedPrefixSums(std::vector<int>({ 0,1,0,-2,2,1,0,0,-2 }), 1);
		RangeSumCount().FindAll_SortedPrefixSums(std::vector<int>({ 0,1,0,-2,2,1,0,0,-2 }), 1);
	}
	{
		std::vector<int> inorder({ 31, 41, 59, 26, 53, 58, 97, 23, 93, 84, 33, 64, 62, 83, 27 });
		CartesianTree::TreeNode * root = CartesianTree().Construct_SortedStack(inorder);
		CartesianTree::TreeNode * root_BruteForce = CartesianTree().Construct_BruteForceRecur(inorder);
		rmqlcaOss << "CartesianTree SortedStack and BruteForceRecur for \"" << Debug::ToStr1D<int>()(inorder) << "\":" << std::endl;
		PrintBinaryTree<CartesianTree::TreeNode, std::ostringstream>(root, rmqlcaOss);
		PrintBinaryTree<CartesianTree::TreeNode, std::ostringstream>(root_BruteForce, rmqlcaOss);
		std::cout << rmqlcaOss.str() << std::endl;
		rmqlcaOss.str(std::string());
		CartesianTree().RangeMin_LCA(root, root->left->left, root->right->left->right);
		CartesianTree().RangeMin_LCA(root_BruteForce, root_BruteForce->left->left, root_BruteForce->right->left->right);
		CartesianTree::DeleteTree(root);
		CartesianTree::DeleteTree(root_BruteForce);

		std::vector<int> inorder2({ 32, 45, 16, 18, 9, 33 });
		CartesianTree::TreeNode * root2 = CartesianTree().Construct_SortedStack(inorder2);
		CartesianTree::TreeNode * root2_BruteForce = CartesianTree().Construct_BruteForceRecur(inorder2);
		rmqlcaOss << "CartesianTree SortedStack and BruteForceRecur for \"" << Debug::ToStr1D<int>()(inorder2) << "\":" << std::endl;
		PrintBinaryTree<CartesianTree::TreeNode, std::ostringstream>(root2, rmqlcaOss);
		PrintBinaryTree<CartesianTree::TreeNode, std::ostringstream>(root2_BruteForce, rmqlcaOss);
		std::cout << rmqlcaOss.str() << std::endl;
		rmqlcaOss.str(std::string());
		CartesianTree().RangeMin_LCA(root2, root2->left->left->right, root2->left->right);
		CartesianTree().RangeMin_LCA(root2_BruteForce, root2_BruteForce->left->left->right, root2_BruteForce->left->right);
		CartesianTree::DeleteTree(root2);
		CartesianTree::DeleteTree(root2_BruteForce);

		std::vector<int> inorder3({ 9, 3, 7, 1, 8, 12, 10, 20, 15, 18, 5 });
		CartesianTree::TreeNode * root3 = CartesianTree().Construct_SortedStack(inorder3);
		CartesianTree::TreeNode * root3_BruteForce = CartesianTree().Construct_BruteForceRecur(inorder3);
		rmqlcaOss << "CartesianTree SortedStack and BruteForceRecur for \"" << Debug::ToStr1D<int>()(inorder3) << "\":" << std::endl;
		PrintBinaryTree<CartesianTree::TreeNode, std::ostringstream>(root3, rmqlcaOss);
		PrintBinaryTree<CartesianTree::TreeNode, std::ostringstream>(root3_BruteForce, rmqlcaOss);
		std::cout << rmqlcaOss.str() << std::endl;
		rmqlcaOss.str(std::string());
		CartesianTree().RangeMin_LCA(root3, root3->left->left, root3->right->left->right);
		CartesianTree().RangeMin_LCA(root3_BruteForce, root3_BruteForce->left->left, root3_BruteForce->right->left->right);
		CartesianTree::DeleteTree(root3);
		CartesianTree::DeleteTree(root3_BruteForce);

		for (int i = 0; i < 5; ++i)
		{
			std::vector<int> inorder4 = TestCase::RandVec(10, 1, 99);
			CartesianTree::TreeNode * root4 = CartesianTree().Construct_SortedStack(inorder4);
			CartesianTree::TreeNode * root4_BruteForce = CartesianTree().Construct_BruteForceRecur(inorder4);
			rmqlcaOss << "CartesianTree SortedStack and BruteForceRecur for \"" << Debug::ToStr1D<int>()(inorder4) << "\":" << std::endl;
			PrintBinaryTree<CartesianTree::TreeNode, std::ostringstream>(root4, rmqlcaOss);
			PrintBinaryTree<CartesianTree::TreeNode, std::ostringstream>(root4_BruteForce, rmqlcaOss);
			std::cout << rmqlcaOss.str() << std::endl;
			rmqlcaOss.str(std::string());
			CartesianTree::DeleteTree(root4);
			CartesianTree::DeleteTree(root4_BruteForce);
		}
	}
	{
		std::vector<std::vector<int>> dp2d = RangeMinQueryDP2D().Construct(std::vector<int>({ 16, 18, 33, 98 }));
		RangeMinQueryDP2D().QueryRange(dp2d, 1, 3);
	}
	{
		std::vector<std::vector<int>> sparseTable = RangeMinQuerySparseTable().Construct(std::vector<int>({ 31, 41, 88, 26, 53, 77, 66, 47, 17 }));
		RangeMinQuerySparseTable().QueryRange(sparseTable, 1, 3);
		RangeMinQuerySparseTable().QueryRange(sparseTable, 0, 8);
		RangeMinQuerySparseTable().QueryRange(sparseTable, 4, 8);
		RangeMinQuerySparseTable().QueryRange(sparseTable, 4, 7);
		RangeMinQuerySparseTable().QueryRange(sparseTable, 4, 6);
		RangeMinQuerySparseTable().QueryRange(sparseTable, 5, 7);
		RangeMinQuerySparseTable().QueryRange(sparseTable, 5, 8);
		RangeMinQuerySparseTable().QueryRange(sparseTable, 2, 6);
		RangeMinQuerySparseTable().QueryRange(sparseTable, 2, 7);
		RangeMinQuerySparseTable().QueryRange(sparseTable, 2, 8);
		RangeMinQuerySparseTable().QueryRange(sparseTable, 3, 6);
		RangeMinQuerySparseTable().QueryRange(sparseTable, 3, 7);
		RangeMinQuerySparseTable().QueryRange(sparseTable, 3, 8);
	}
	{
		/*
    ______1______
   /      |      \
  6       2     __9__
 / \           /  |  \
3   5         10  4   8
                  |
				  7
		*/
		LowestCommonAncestorEulerTourRMQ::TreeNode * root = new LowestCommonAncestorEulerTourRMQ::TreeNode(1);
		root->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(6));
		root->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(2));
		root->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(9));
		root->children[0]->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(3));
		root->children[0]->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(5));
		root->children[2]->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(10));
		root->children[2]->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(4));
		root->children[2]->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(8));
		root->children[2]->children[1]->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(7));
		LowestCommonAncestorEulerTourRMQ().Find(root, root->children[2]->children[0], root->children[2]->children[1]->children[0]);//10, 7
		LowestCommonAncestorEulerTourRMQ::DeleteTree(root);

		/*
  ___________1___________
 /           |           \
2   _________3_________   4
   /         |         \
  5        __6__      __7__
          /     \    /     \
	     8       9  10     11
	               /  \
			      12  13
		*/
		root = new LowestCommonAncestorEulerTourRMQ::TreeNode(1);
		root->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(2));
		root->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(3));
		root->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(4));
		root->children[1]->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(5));
		root->children[1]->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(6));
		root->children[1]->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(7));
		root->children[1]->children[1]->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(8));
		root->children[1]->children[1]->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(9));
		root->children[1]->children[2]->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(10));
		root->children[1]->children[2]->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(11));
		root->children[1]->children[2]->children[0]->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(12));
		root->children[1]->children[2]->children[0]->children.push_back(new LowestCommonAncestorEulerTourRMQ::TreeNode(13));
		LowestCommonAncestorEulerTourRMQ().Find(root, root->children[1]->children[1]->children[1], root->children[1]->children[2]->children[0]->children[0]);//9, 12
		LowestCommonAncestorEulerTourRMQ().Find(root, root->children[0], root->children[1]->children[2]->children[1]);//2, 11
		LowestCommonAncestorEulerTourRMQ::DeleteTree(root);
	}
	{
		/*
  ___________1___________
 /           |           \
2   _________3_________   4
   /         |         \
  5        __6__      __7__
          /     \    /     \
	     8       9  10     11
	               /  \
			      12  13
		*/
		LowestCommonAncestorUnionFind::TreeNode * root = new LowestCommonAncestorUnionFind::TreeNode(1);
		root->children.push_back(new LowestCommonAncestorUnionFind::TreeNode(2));
		root->children.push_back(new LowestCommonAncestorUnionFind::TreeNode(3));
		root->children.push_back(new LowestCommonAncestorUnionFind::TreeNode(4));
		root->children[1]->children.push_back(new LowestCommonAncestorUnionFind::TreeNode(5));
		root->children[1]->children.push_back(new LowestCommonAncestorUnionFind::TreeNode(6));
		root->children[1]->children.push_back(new LowestCommonAncestorUnionFind::TreeNode(7));
		root->children[1]->children[1]->children.push_back(new LowestCommonAncestorUnionFind::TreeNode(8));
		root->children[1]->children[1]->children.push_back(new LowestCommonAncestorUnionFind::TreeNode(9));
		root->children[1]->children[2]->children.push_back(new LowestCommonAncestorUnionFind::TreeNode(10));
		root->children[1]->children[2]->children.push_back(new LowestCommonAncestorUnionFind::TreeNode(11));
		root->children[1]->children[2]->children[0]->children.push_back(new LowestCommonAncestorUnionFind::TreeNode(12));
		root->children[1]->children[2]->children[0]->children.push_back(new LowestCommonAncestorUnionFind::TreeNode(13));
		std::vector<std::pair<LowestCommonAncestorUnionFind::TreeNode*, LowestCommonAncestorUnionFind::TreeNode*>> targetNodePairs;
		targetNodePairs.push_back(std::make_pair(root->children[1]->children[1]->children[1], root->children[1]->children[2]->children[0]->children[0]));
		targetNodePairs.push_back(std::make_pair(root->children[1]->children[2]->children[0]->children[1], root->children[1]->children[2]->children[1]));
		targetNodePairs.push_back(std::make_pair(root->children[0], root->children[1]->children[2]->children[0]));
		LowestCommonAncestorUnionFind().Find_Tarjan1(root, targetNodePairs);
		LowestCommonAncestorUnionFind().Find_Tarjan2(root, targetNodePairs);
		LowestCommonAncestorUnionFind::DeleteTree(root);
	}
	{
		/*
  ___________1___________
 /           |           \
2   _________3_________   4
   /         |         \
  5        __6__      __7__
          /     \    /     \
	     8       9  10     11
	               /  \
			      12  13
		*/
		LowestCommonAncestorSectionDad::TreeNode * root = new LowestCommonAncestorSectionDad::TreeNode(1);
		root->children.push_back(new LowestCommonAncestorSectionDad::TreeNode(2));
		root->children.push_back(new LowestCommonAncestorSectionDad::TreeNode(3));
		root->children.push_back(new LowestCommonAncestorSectionDad::TreeNode(4));
		root->children[1]->children.push_back(new LowestCommonAncestorSectionDad::TreeNode(5));
		root->children[1]->children.push_back(new LowestCommonAncestorSectionDad::TreeNode(6));
		root->children[1]->children.push_back(new LowestCommonAncestorSectionDad::TreeNode(7));
		root->children[1]->children[1]->children.push_back(new LowestCommonAncestorSectionDad::TreeNode(8));
		root->children[1]->children[1]->children.push_back(new LowestCommonAncestorSectionDad::TreeNode(9));
		root->children[1]->children[2]->children.push_back(new LowestCommonAncestorSectionDad::TreeNode(10));
		root->children[1]->children[2]->children.push_back(new LowestCommonAncestorSectionDad::TreeNode(11));
		root->children[1]->children[2]->children[0]->children.push_back(new LowestCommonAncestorSectionDad::TreeNode(12));
		root->children[1]->children[2]->children[0]->children.push_back(new LowestCommonAncestorSectionDad::TreeNode(13));
		std::vector<LowestCommonAncestorSectionDad::TreeNode *> dfsNodes;
		std::unordered_map<LowestCommonAncestorSectionDad::TreeNode *, int> nodeIdxMap;
		std::vector<int> dad;
		std::vector<int> level;
		std::vector<int> sectionDad;
		LowestCommonAncestorSectionDad().Construct(root, dfsNodes, nodeIdxMap, dad, level, sectionDad);
		LowestCommonAncestorSectionDad().Query(dfsNodes, nodeIdxMap, dad, level, sectionDad, root->children[1]->children[1]->children[1], root->children[1]->children[2]->children[0]->children[0]);
		LowestCommonAncestorSectionDad().Query(dfsNodes, nodeIdxMap, dad, level, sectionDad, root->children[1]->children[2]->children[0]->children[1], root->children[1]->children[2]->children[1]);
		LowestCommonAncestorSectionDad().Query(dfsNodes, nodeIdxMap, dad, level, sectionDad, root->children[0], root->children[1]->children[2]->children[0]);
		LowestCommonAncestorSectionDad::DeleteTree(root);
	}
	{
		/*
  ___________1___________
 /           |           \
2   _________3_________   4
   /         |         \
  5        __6__      __7__
          /     \    /     \
	     8       9  10     11
	               /  \
			      12  13
		*/
		LowestCommonAncestorDP2D::TreeNode * root = new LowestCommonAncestorDP2D::TreeNode(1);
		root->children.push_back(new LowestCommonAncestorDP2D::TreeNode(2));
		root->children.push_back(new LowestCommonAncestorDP2D::TreeNode(3));
		root->children.push_back(new LowestCommonAncestorDP2D::TreeNode(4));
		root->children[1]->children.push_back(new LowestCommonAncestorDP2D::TreeNode(5));
		root->children[1]->children.push_back(new LowestCommonAncestorDP2D::TreeNode(6));
		root->children[1]->children.push_back(new LowestCommonAncestorDP2D::TreeNode(7));
		root->children[1]->children[1]->children.push_back(new LowestCommonAncestorDP2D::TreeNode(8));
		root->children[1]->children[1]->children.push_back(new LowestCommonAncestorDP2D::TreeNode(9));
		root->children[1]->children[2]->children.push_back(new LowestCommonAncestorDP2D::TreeNode(10));
		root->children[1]->children[2]->children.push_back(new LowestCommonAncestorDP2D::TreeNode(11));
		root->children[1]->children[2]->children[0]->children.push_back(new LowestCommonAncestorDP2D::TreeNode(12));
		root->children[1]->children[2]->children[0]->children.push_back(new LowestCommonAncestorDP2D::TreeNode(13));
		std::vector<LowestCommonAncestorDP2D::TreeNode *> dfsNodes;
		std::unordered_map<LowestCommonAncestorDP2D::TreeNode *, int> nodeIdxMap;
		std::vector<int> dad;
		std::vector<int> level;
		std::vector<std::vector<int>> dp2d;
		LowestCommonAncestorDP2D().Construct(root, dfsNodes, nodeIdxMap, dad, level, dp2d);
		LowestCommonAncestorDP2D().Query(dfsNodes, nodeIdxMap, dad, level, dp2d, root->children[1]->children[1]->children[1], root->children[1]->children[2]->children[0]->children[0]);//9, 12
		LowestCommonAncestorDP2D().Query(dfsNodes, nodeIdxMap, dad, level, dp2d, root->children[1]->children[2]->children[0]->children[1], root->children[1]->children[2]->children[1]);//13, 11
		LowestCommonAncestorDP2D().Query(dfsNodes, nodeIdxMap, dad, level, dp2d, root->children[0], root->children[1]->children[2]->children[0]);//2, 10
		LowestCommonAncestorDP2D().Query(dfsNodes, nodeIdxMap, dad, level, dp2d, root->children[1]->children[2]->children[0]->children[1], root->children[1]->children[2]->children[0]->children[0]);//13, 12
		LowestCommonAncestorDP2D().Query(dfsNodes, nodeIdxMap, dad, level, dp2d, root->children[1]->children[2]->children[0], root->children[1]->children[2]->children[1]);//10, 11
		LowestCommonAncestorDP2D::DeleteTree(root);
	}

#endif
#ifdef _Scheduling_
    RdCout ? redirect_cout::to_file("Out_Scheduling.txt") : redirect_cout::to_cout();
    PrintH("Scheduling");
    {
        RoundRobinScheduling().Test();
    }

#endif
#ifdef _ThreadSafe_
	//RdCout ? redirect_cout::to_file("Out_ThreadSafe.txt") : redirect_cout::to_cout();
	PrintH("ThreadSafe");
	{
		//RealTimeCountHitsInLastSecMinHr().Solve();//press "e"+ENTER to exit
	}
	{
		//Sync2InterleavingThreads::Solve();
		//Sync2InterleavingThreads::Solve2();
	}
	{
		//thread_mgr::Test();
		//thread_pool::Test();
        //thread_pool2::Test();
	}
	{
		//ImplementAsyncCallback::Test();
	}
	{
		//thread_timer::Test();
	}
	{
		//SyncReadersWriters::Test();
	}
	{
		//SyncProducersConsumers::Test();
	}
	{
		//SyncCigaretteSmokers::Test();
	}
	{
		//SyncDiningPhilosophers::Test();
	}
    {
        //SyncPrintInOrder123_Atomic().Test();
        //SyncPrintInOrder123_PromiseFuture().Test();
        //SyncPrintInOrder123_MutexCondition().Test();
    }
    {
        //SyncPrintFooBarAlter_Atomic(10).Test();
        //SyncPrintFooBarAlter_MutexCondition(10).Test();
    }
    {
        //SyncPrintZeroOddZeroEven_MutexCondition(10).Test();
    }
    {
        //SyncBuildH2O_MutexCondition().Test();
    }
    {
        //SyncPrintFizzBuzz_MutexCondition(20).Test();
    }

#endif

#ifdef _DesignPattern_
    RdCout ? redirect_cout::to_file("Out_DesignPattern.txt") : redirect_cout::to_cout();
    PrintH("DesignPattern");
    {
        //redirect_cout::to_cout();
        //DesignPattern_Singleton::Test();
        //DesignPattern_Command::Test();
        //DesignPattern_ChainOfResponsibility::Test();
        //DesignPattern_FactoryMethod::Test();
        //DesignPattern_Builder::Test();

        //DesignPattern_Interpreter::Test();
        DesignPattern_Memento::Test();
        //DesignPattern_Strategy::Test();
        //DesignPattern_TemplateMethod::Test();
        //DesignPattern_Visitor::Test();
    }
    {
        DesignMealCombinationSystem::Kitchen k(400,200,400,600,400,300,300,400);
    }
    {
        DesignLeetcodeOJ::OJSingleton::Instance().Print();
        DesignLeetcodeOJ::OJSingleton::Instance().Print();
        DesignLeetcodeOJ::OJSingleton::Instance().Print();
    }
#endif

#ifdef _CPP_
    RdCout ? redirect_cout::to_file("Out_CPP.txt") : redirect_cout::to_cout();
    PrintH("CPP");
    {
        MakeFinal::Test();
        MakeFinal::Test2();
    }
#endif

#ifdef _PrintFileNameByTag_
	{
		PrintFileNameByTag p;
	}
#endif
#ifdef _PrintVSSolutionTree_
	{
		PrintVSSolutionTree p;
	}
#endif

    redirect_cout::to_cout();
    std::cout << "Hit ENTER to continue ..." << std::endl;
    std::cin.ignore();
	return 0;
}

